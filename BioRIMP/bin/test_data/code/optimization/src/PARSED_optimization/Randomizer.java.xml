<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\Daavid\git\unalcol\BioRIMP\test_data\code\optimization\src\unalcol\optimization\testbed\real\lsgo_benchmark\Randomizer.java"><package>package <name><name>unalcol</name>.<name>optimization</name>.<name>testbed</name>.<name>real</name>.<name>lsgo_benchmark</name></name>;</package>
<comment type="block">/*
 * Copyright (c) 2009 Thomas Weise for NICAL
 * http://www.it-weise.de/
 * tweise@gmx.de
 *
 * GNU LESSER GENERAL PUBLIC LICENSE (Version 2.1, February 1999)
 */</comment>

<import>import <name><name>java</name>.<name>util</name>.<name>Random</name></name>;</import>

<comment type="javadoc">/**
 * A standardized implementation of the randomization of shift vectors and
 * matrices used for the experiments. The implementation of the basic
 * random methods is the same as in Java 1.6. By overriding these methods
 * here, we basically ensure that the behavior of the randmizer is the same
 * for all past and future versions of Java.
 * 
 * @author Thomas Weise
 */</comment>
<class><specifier>public</specifier> class <name>Randomizer</name> <super><extends>extends <name>Random</name></extends></super> <block>{
  <comment type="javadoc">/** use serialVersionUID y */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>

  <comment type="javadoc">/** M */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>M</name> =<init> <expr>0x5DEECE66DL</expr></init></decl>;</decl_stmt>

  <comment type="javadoc">/** a */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>A</name> =<init> <expr>0xBL</expr></init></decl>;</decl_stmt>

  <comment type="javadoc">/** mask */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>MASK</name> =<init> <expr>(1L &lt;&lt; 48) - 1</expr></init></decl>;</decl_stmt>

  <comment type="javadoc">/** The randomization seed */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>m_seed</name></decl>;</decl_stmt>

  <comment type="javadoc">/** the internal variable holding the next gaussian number */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <name>double</name></type> <name>m_nextNextGaussian</name></decl>;</decl_stmt>

  <comment type="javadoc">/**
   * the internal variable indicating whether there is a next gaussian
   * number stored
   */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>m_haveNextNextGaussian</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

  <comment type="javadoc">/**
   * Creates a new random number generator.
   */</comment>
  <constructor><specifier>public</specifier> <name>Randomizer</name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>

  <comment type="javadoc">/**
   * Creates a new random number generator using a single {@code long}
   * seed.
   * 
   * @param seed
   *          the initial seed
   */</comment>
  <constructor><specifier>public</specifier> <name>Randomizer</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>long</name></type> <name>seed</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name>.<name>m_seed</name></name> = <name>seed</name></expr>;</expr_stmt>
  }</block></constructor>

  <comment type="javadoc">/**
   * Sets the seed of this random number generator using a single {@code
   * long} seed.
   * 
   * @param seed
   *          the new seed
   */</comment>
  <comment type="line">// @Override</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>setSeed</name><parameter_list>(<param><decl><type><name>long</name></type> <name>seed</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><name><name>this</name>.<name>m_seed</name></name> = <name>seed</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>super</name>.<name>setSeed</name></name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <comment type="javadoc">/**
   * Generates the next pseudorandom number.
   * 
   * @param bits
   *          random bits
   * @return the random bits
   */</comment>
  <comment type="line">// @Override</comment>
  <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>int</name></type> <name>next</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>bits</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>this</name>.<name>m_seed</name></name> = <name>s</name> = (((<name><name>this</name>.<name>m_seed</name></name> * <name>M</name>) + <name>A</name>) &amp; <name>MASK</name>)</expr>;</expr_stmt>
    <return>return <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>s</name> &gt;&gt;&gt; (48 - <name>bits</name>)</expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Returns a pseudorandom, uniformly distributed {@code int} value
   * between 0 (inclusive) and the specified value (exclusive), drawn from
   * this random number generator's sequence.
   * 
   * @param n
   *          the bound on the random number to be returned. Must be
   *          positive.
   * @return the next pseudorandom, uniformly distributed {@code int} value
   *         between {@code 0} (inclusive) and {@code n} (exclusive) from
   *         this random number generator's sequence
   */</comment>
  <comment type="line">// @Override</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>nextInt</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>bits</name>, <name>val</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>n</name> &amp; (-<name>n</name>)) == <name>n</name></expr>)</condition><then> <block>{<comment type="line">// i.e., n is a power of 2</comment>
      <return>return <expr><call>(<name>int</name>) <argument_list>(<argument><expr>(<name>n</name> * (<name>long</name>) <call><name>next</name><argument_list>(<argument><expr>31</expr></argument>)</argument_list></call>) &gt;&gt; 31</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <do>do <block>{
      <expr_stmt><expr><name>bits</name> = <call><name>next</name><argument_list>(<argument><expr>31</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>val</name> = <name>bits</name> % <name>n</name></expr>;</expr_stmt>
    }</block> while <condition>(<expr><name>bits</name> - <name>val</name> + (<name>n</name> - 1) &lt; 0</expr>)</condition>;</do>

    <return>return <expr><name>val</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Returns the next pseudorandom, uniformly distributed {@code double}
   * value between {@code 0.0} and {@code 1.0} from this random number
   * generator's sequence.
   * 
   * @return the next pseudorandom, uniformly distributed {@code double}
   *         value between {@code 0.0} and {@code 1.0} from this random
   *         number generator's sequence
   * @see Math#random
   */</comment>
  <comment type="line">// @Override</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>double</name></type> <name>nextDouble</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr>(((<call>(<name>long</name>) <argument_list>(<argument><expr><call><name>next</name><argument_list>(<argument><expr>26</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;&lt; 27) + <call><name>next</name><argument_list>(<argument><expr>27</expr></argument>)</argument_list></call>) / <call>(<name>double</name>) <argument_list>(<argument><expr>1L &lt;&lt; 53</expr></argument>)</argument_list></call>)</expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Returns the next pseudorandom, Gaussian ("normally") distributed
   * {@code double} value with mean {@code 0.0} and standard deviation
   * {@code 1.0} from this random number generator's sequence.
   * 
   * @return the next pseudorandom, Gaussian ("normally") distributed
   *         {@code double} value with mean {@code 0.0} and standard
   *         deviation {@code 1.0} from this random number generator's
   *         sequence
   */</comment>
  <comment type="line">// @Override</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>double</name></type> <name>nextGaussian</name><parameter_list>()</parameter_list> <block>{
    <decl_stmt><decl><type><name>double</name></type> <name>multiplier</name>, <name>v1</name>, <name>v2</name>, <name>s</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>this</name>.<name>m_haveNextNextGaussian</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>this</name>.<name>m_haveNextNextGaussian</name></name> = false</expr>;</expr_stmt>
      <return>return <expr><name><name>this</name>.<name>m_nextNextGaussian</name></name></expr>;</return>
    }</block></then></if>

    <do>do <block>{
      <expr_stmt><expr><name>v1</name> = ((2d * <call><name><name>this</name>.<name>nextDouble</name></name><argument_list>()</argument_list></call>) - 1d)</expr>;</expr_stmt>
      <expr_stmt><expr><name>v2</name> = ((2d * <call><name><name>this</name>.<name>nextDouble</name></name><argument_list>()</argument_list></call>) - 1d)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> = ((<name>v1</name> * <name>v1</name>) + (<name>v2</name> * <name>v2</name>))</expr>;</expr_stmt>
    }</block> while <condition>(<expr>(<name>s</name> &gt;= 1d) || (<name>s</name> == 0d)</expr>)</condition>;</do>
    <expr_stmt><expr><name>multiplier</name> = <call><name><name>StrictMath</name>.<name>sqrt</name></name><argument_list>(<argument><expr>-2.d * <call><name><name>StrictMath</name>.<name>log</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> / <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>this</name>.<name>m_nextNextGaussian</name></name> = (<name>v2</name> * <name>multiplier</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name>.<name>m_haveNextNextGaussian</name></name> = true</expr>;</expr_stmt>

    <return>return <expr>(<name>v1</name> * <name>multiplier</name>)</expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Create a new shifting vector
   * 
   * @param dim
   *          the dimension of the vector
   * @param min
   *          the minimum value a decision variable can take on
   * @param max
   *          the maximum value a decision variable can take on
   * @return the shift vector
   */</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>double</name><index>[]</index></type> <name>createShiftVector</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>dim</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>double</name></type> <name>min</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name>double</name></type> <name>max</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>double</name><index>[]</index></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>double</name></type> <name>hw</name>, <name>middle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>hw</name> = (0.5d * (<name>max</name> - <name>min</name>))</expr>;</expr_stmt>
    <expr_stmt><expr><name>middle</name> = (<name>min</name> + <name>hw</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> = new <name><name>double</name><index>[<expr><name>dim</name></expr>]</index></name></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = (<name>dim</name> - 1)</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
      <do>do <block>{
        <expr_stmt><expr><name>s</name> = (<name>middle</name> + (<call><name><name>this</name>.<name>nextGaussian</name></name><argument_list>()</argument_list></call> * <name>hw</name>))</expr>;</expr_stmt>
      }</block> while <condition>(<expr>(<name>s</name> &lt; <name>min</name>) || (<name>s</name> &gt; <name>max</name>)</expr>)</condition>;</do>
      <expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> = <name>s</name></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>d</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Create a random permutation vector of the numbers 0 to dim-1
   * 
   * @param dim
   *          the number of dimensions
   * @return the permutation vector
   */</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>createPermVector</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>dim</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name>, <name>t</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>d</name> = new <name><name>int</name><index>[<expr><name>dim</name></expr>]</index></name></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = (<name>dim</name> - 1)</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
    }</block></for>

    <for>for (<init><expr><name>i</name> = (<name>dim</name> &lt;&lt; 3)</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>j</name> = <call><name><name>this</name>.<name>nextInt</name></name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <do>do <block>{
        <expr_stmt><expr><name>k</name> = <call><name><name>this</name>.<name>nextInt</name></name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block> while <condition>(<expr><name>k</name> == <name>j</name></expr>)</condition>;</do>

      <expr_stmt><expr><name>t</name> = <name><name>d</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>d</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>d</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>d</name><index>[<expr><name>k</name></expr>]</index></name> = <name>t</name></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>d</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Create a random rotation matrix
   * 
   * @param dim
   *          the number of dimensions
   * @return the rotation matrix
   */</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>double</name><index>[]</index><index>[]</index></type> <name>createRotMatrix</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>dim</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>double</name><index>[]</index><index>[]</index></type> <name>m</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>dp</name>, <name>t</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>m</name> = new <name><name>double</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>dim</name></expr>]</index></name></expr>;</expr_stmt>

    <label><name>outer</name>:</label> <for>for (<init>;</init><condition>;</condition><incr/>) <block>{

      <comment type="line">// initialize</comment>
      <for>for (<init><expr><name>i</name> = (<name>dim</name> - 1)</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
        <for>for (<init><expr><name>j</name> = (<name>dim</name> - 1)</expr>;</init> <condition><expr><name>j</name> &gt;= 0</expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <block>{
          <expr_stmt><expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> = <call><name><name>this</name>.<name>nextGaussian</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      }</block></for>

      <comment type="line">// main loop of gram/schmidt</comment>
      <for>for (<init><expr><name>i</name> = (<name>dim</name> - 1)</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{

        <comment type="line">//</comment>
        <for>for (<init><expr><name>j</name> = (<name>dim</name> - 1)</expr>;</init> <condition><expr><name>j</name> &gt; <name>i</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <block>{

          <comment type="line">// dot product</comment>
          <expr_stmt><expr><name>dp</name> = 0d</expr>;</expr_stmt>
          <for>for (<init><expr><name>k</name> = (<name>dim</name> - 1)</expr>;</init> <condition><expr><name>k</name> &gt;= 0</expr>;</condition> <incr><expr><name>k</name>--</expr></incr>) <block>{
            <expr_stmt><expr><name>dp</name> += (<name><name>m</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> * <name><name>m</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
          }</block></for>

          <comment type="line">// subtract</comment>
          <for>for (<init><expr><name>k</name> = (<name>dim</name> - 1)</expr>;</init> <condition><expr><name>k</name> &gt;= 0</expr>;</condition> <incr><expr><name>k</name>--</expr></incr>) <block>{
            <expr_stmt><expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> -= (<name>dp</name> * <name><name>m</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
          }</block></for>
        }</block></for>

        <comment type="line">// normalize</comment>
        <expr_stmt><expr><name>dp</name> = 0d</expr>;</expr_stmt>
        <for>for (<init><expr><name>k</name> = (<name>dim</name> - 1)</expr>;</init> <condition><expr><name>k</name> &gt;= 0</expr>;</condition> <incr><expr><name>k</name>--</expr></incr>) <block>{
          <expr_stmt><expr><name>t</name> = <name><name>m</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>dp</name> += (<name>t</name> * <name>t</name>)</expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// linear dependency -&gt; restart</comment>
        <if>if <condition>(<expr><name>dp</name> &lt;= 0d</expr>)</condition><then> <block>{
          <continue>continue outer;</continue>
        }</block></then></if>
        <expr_stmt><expr><name>dp</name> = (1d / <call><name><name>Math</name>.<name>sqrt</name></name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

        <for>for (<init><expr><name>k</name> = (<name>dim</name> - 1)</expr>;</init> <condition><expr><name>k</name> &gt;= 0</expr>;</condition> <incr><expr><name>k</name>--</expr></incr>) <block>{
          <expr_stmt><expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> *= <name>dp</name></expr>;</expr_stmt>
        }</block></for>
      }</block></for>

      <return>return <expr><name>m</name></expr>;</return>
    }</block></for>
  }</block></function>

  <comment type="javadoc">/**
   * Create a random rotation matrix
   * 
   * @param dim
   *          the number of dimensions
   * @return the rotation matrix
   */</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>double</name><index>[]</index></type> <name>createRotMatrix1D</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>dim</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>double</name><index>[]</index><index>[]</index></type> <name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>double</name><index>[]</index></type> <name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>a</name> = <call><name><name>this</name>.<name>createRotMatrix</name></name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> = new <name><name>double</name><index>[<expr><name>dim</name> * <name>dim</name></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>k</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>dim</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>dim</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>a</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></for>
    }</block></for>

    <return>return <expr><name>b</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * The test function used to check whether the routines here have been
   * implemented correctly.
   * 
   * @param params
   *          the parameters
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>void</name></type> <name>main</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>params</name></decl></param>)</parameter_list> <block>{
    <comment type="line">// double[][] m;</comment>
    <decl_stmt><decl><type><name>double</name><index>[]</index></type> <name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <comment type="block">/* i, */</comment><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>D</name> =<init> <expr>10</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>Randomizer</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>seed</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>r</name> = new <call><name>Randomizer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>r</name>.<name>setSeed</name></name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>r</name>.<name>setSeed</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>o</name> = <call><name><name>r</name>.<name>createShiftVector</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr>-100d</expr></argument>, <argument><expr>100d</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>D</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
      <if>if <condition>(<expr><name>j</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr><name><name>o</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>r</name>.<name>setSeed</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>o</name> = <call><name><name>r</name>.<name>createShiftVector</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr>-100d</expr></argument>, <argument><expr>100d</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>D</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
      <if>if <condition>(<expr><name>j</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr><name><name>o</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>r</name>.<name>setSeed</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <call><name><name>r</name>.<name>createPermVector</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>D</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
      <if>if <condition>(<expr><name>j</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>j</name></expr>]</index></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>r</name>.<name>setSeed</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <call><name><name>r</name>.<name>createPermVector</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>D</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
      <if>if <condition>(<expr><name>j</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>j</name></expr>]</index></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <comment type="line">//</comment>
    <comment type="line">// System.out.println();</comment>
    <comment type="line">// System.out.println();</comment>
    <comment type="line">//</comment>
    <comment type="line">// m = r.createRotMatrix(D);</comment>
    <comment type="line">// for (i = 0; i &lt; D; i++) {</comment>
    <comment type="line">// for (j = 0; j &lt; D; j++) {</comment>
    <comment type="line">// if (j &gt; 0) {</comment>
    <comment type="line">// System.out.print(' ');</comment>
    <comment type="line">// }</comment>
    <comment type="line">// System.out.print(m[i][j]);</comment>
    <comment type="line">// }</comment>
    <comment type="line">// System.out.println();</comment>
    <comment type="line">// }</comment>

  }</block></function>
}</block></class>
</unit>
