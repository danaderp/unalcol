<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\Daavid\git\unalcol\BioRIMP\test_data\code\optimization\src\unalcol\optimization\testbed\real\lsgo_benchmark\Utils.java"><package>package <name><name>unalcol</name>.<name>optimization</name>.<name>testbed</name>.<name>real</name>.<name>lsgo_benchmark</name></name>;</package>
<comment type="block">/*
 * Copyright (c) 2009 Thomas Weise for NICAL
 * http://www.it-weise.de/
 * tweise@gmx.de
 *
 * GNU LESSER GENERAL PUBLIC LICENSE (Version 2.1, February 1999)
 */</comment>

<import>import <name><name>java</name>.<name>io</name>.<name>BufferedReader</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>BufferedWriter</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileInputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileWriter</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>InputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>InputStreamReader</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>URI</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>URL</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>regex</name>.<name>Pattern</name></name>;</import>

<comment type="javadoc">/**
 * With this class, we provide utility functions such as the creation,
 * loading, or storing of vectors and matrices.
 * 
 * @author Thomas Weise
 */</comment>
<class><specifier>public</specifier> <specifier>final</specifier> class <name>Utils</name> <block>{

  <comment type="javadoc">/**
   * Load a shifting vector from a file
   * 
   * @param file
   *          the path to the file to load
   * @return the vector loaded
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>double</name><index>[]</index></type> <name>loadShiftVector</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>file</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>FileInputStream</name></type> <name>r</name></decl>;</decl_stmt>
    <try>try <block>{
      <expr_stmt><expr><name>r</name> = new <call><name>FileInputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <try>try <block>{
        <return>return <expr><call><name>loadShiftVector</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t1</name></decl></param>) <block>{
        <try>try <block>{
          <expr_stmt><expr><call><name><name>r</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t2</name></decl></param>) <block>{
          <comment type="line">// not interesting here</comment>
        }</block></catch></try>
        <throw>throw <expr><name>t1</name></expr>;</throw>
      }</block></catch></try>

    }</block> <catch>catch (<param><decl><type><name>RuntimeException</name></type> <name>t1</name></decl></param>) <block>{
      <throw>throw <expr><name>t1</name></expr>;</throw>
    }</block></catch> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Load a shifting vector from an uri
   * 
   * @param uri
   *          the uri to load from
   * @return the vector loaded
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>double</name><index>[]</index></type> <name>loadShiftVector</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>URI</name></type> <name>uri</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>URL</name></type> <name>u</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>InputStream</name></type> <name>r</name></decl>;</decl_stmt>
    <try>try <block>{
      <expr_stmt><expr><name>u</name> = <call><name><name>uri</name>.<name>toURL</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> = <call><name><name>u</name>.<name>openStream</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <try>try <block>{
        <return>return <expr><call><name>loadShiftVector</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t1</name></decl></param>) <block>{
        <try>try <block>{
          <expr_stmt><expr><call><name><name>r</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t2</name></decl></param>) <block>{
          <comment type="line">// not interesting here</comment>
        }</block></catch></try>
        <throw>throw <expr><name>t1</name></expr>;</throw>
      }</block></catch></try>

    }</block> <catch>catch (<param><decl><type><name>RuntimeException</name></type> <name>t1</name></decl></param>) <block>{
      <throw>throw <expr><name>t1</name></expr>;</throw>
    }</block></catch> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Load a shifting vector from an input stream
   * 
   * @param in
   *          the input stream to load from
   * @return the vector loaded
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>double</name><index>[]</index></type> <name>loadShiftVector</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>in</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>BufferedReader</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name><index>[]</index></type> <name>buf</name>, <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fill</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>

    <try>try <block>{
      <expr_stmt><expr><name>buf</name> = new <name><name>double</name><index>[<expr>1000</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>fill</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> = new <call><name>BufferedReader</name><argument_list>(<argument><expr>new <call><name>InputStreamReader</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <try>try <block>{

        <while>while <condition>(<expr>(<name>s</name> = <call><name><name>r</name>.<name>readLine</name></name><argument_list>()</argument_list></call>) != <name>null</name></expr>)</condition> <block>{
          <expr_stmt><expr><name>s</name> = <call><name><name>s</name>.<name>trim</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name><name>s</name>.<name>length</name></name><argument_list>()</argument_list></call> &lt;= 0</expr>)</condition><then> <block>{
            <continue>continue;</continue>
          }</block></then></if>

          <expr_stmt><expr><name>d</name> = <call><name><name>Double</name>.<name>parseDouble</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>fill</name> &gt;= <name><name>buf</name>.<name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>tmp</name> = new <name><name>double</name><index>[<expr><name>fill</name> &lt;&lt; 1</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buf</name> = <name>tmp</name></expr>;</expr_stmt>
          }</block></then></if>

          <expr_stmt><expr><name><name>buf</name><index>[<expr><name>fill</name>++</expr>]</index></name> = <name>d</name></expr>;</expr_stmt>
        }</block></while>

      }</block> <finally>finally <block>{
        <expr_stmt><expr><call><name><name>r</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></finally></try>

      <if>if <condition>(<expr><name>fill</name> == <name><name>buf</name>.<name>length</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>buf</name></expr>;</return>
      }</block></then></if>

      <expr_stmt><expr><name>tmp</name> = new <name><name>double</name><index>[<expr><name>fill</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>tmp</name></expr>;</return>

    }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Store a shifting vector to a file
   * 
   * @param file
   *          the path to the file to load
   * @param o
   *          the vector to be stored
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>void</name></type> <name>storeShiftVector</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>file</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>BufferedWriter</name></type> <name>w</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <try>try <block>{
      <expr_stmt><expr><name>w</name> = new <call><name>BufferedWriter</name><argument_list>(<argument><expr>new <call><name>FileWriter</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <try>try <block>{

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>o</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
          <if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>w</name>.<name>newLine</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><call><name><name>w</name>.<name>write</name></name><argument_list>(<argument><expr><call><name><name>Double</name>.<name>toString</name></name><argument_list>(<argument><expr><name><name>o</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>(<name>i</name> % 100) &lt;= 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>w</name>.<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></for>

      }</block> <finally>finally <block>{
        <expr_stmt><expr><call><name><name>w</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></finally></try>
    }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Load a permutation vector from a file
   * 
   * @param file
   *          the path to the file to load
   * @return the vector loaded
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>loadPermVector</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>file</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>FileInputStream</name></type> <name>r</name></decl>;</decl_stmt>
    <try>try <block>{
      <expr_stmt><expr><name>r</name> = new <call><name>FileInputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <try>try <block>{
        <return>return <expr><call><name>loadPermVector</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t1</name></decl></param>) <block>{
        <try>try <block>{
          <expr_stmt><expr><call><name><name>r</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t2</name></decl></param>) <block>{
          <comment type="line">// not interesting here</comment>
        }</block></catch></try>
        <throw>throw <expr><name>t1</name></expr>;</throw>
      }</block></catch></try>

    }</block> <catch>catch (<param><decl><type><name>RuntimeException</name></type> <name>t1</name></decl></param>) <block>{
      <throw>throw <expr><name>t1</name></expr>;</throw>
    }</block></catch> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Load a permutation vector from an uri
   * 
   * @param uri
   *          the uri to load from
   * @return the vector loaded
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>loadPermVector</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>URI</name></type> <name>uri</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>URL</name></type> <name>u</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>InputStream</name></type> <name>r</name></decl>;</decl_stmt>
    <try>try <block>{
      <expr_stmt><expr><name>u</name> = <call><name><name>uri</name>.<name>toURL</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> = <call><name><name>u</name>.<name>openStream</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <try>try <block>{
        <return>return <expr><call><name>loadPermVector</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t1</name></decl></param>) <block>{
        <try>try <block>{
          <expr_stmt><expr><call><name><name>r</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t2</name></decl></param>) <block>{
          <comment type="line">// not interesting here</comment>
        }</block></catch></try>
        <throw>throw <expr><name>t1</name></expr>;</throw>
      }</block></catch></try>

    }</block> <catch>catch (<param><decl><type><name>RuntimeException</name></type> <name>t1</name></decl></param>) <block>{
      <throw>throw <expr><name>t1</name></expr>;</throw>
    }</block></catch> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Load a permutation vector from an input stream
   * 
   * @param in
   *          the input stream
   * @return the vector loaded
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>loadPermVector</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>in</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>BufferedReader</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>buf</name>, <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fill</name>, <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>s</name></decl>;</decl_stmt>

    <try>try <block>{
      <expr_stmt><expr><name>buf</name> = new <name><name>int</name><index>[<expr>1000</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>fill</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> = new <call><name>BufferedReader</name><argument_list>(<argument><expr>new <call><name>InputStreamReader</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <try>try <block>{

        <while>while <condition>(<expr>(<name>s</name> = <call><name><name>r</name>.<name>readLine</name></name><argument_list>()</argument_list></call>) != <name>null</name></expr>)</condition> <block>{
          <expr_stmt><expr><name>s</name> = <call><name><name>s</name>.<name>trim</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name><name>s</name>.<name>length</name></name><argument_list>()</argument_list></call> &lt;= 0</expr>)</condition><then> <block>{
            <continue>continue;</continue>
          }</block></then></if>

          <expr_stmt><expr><name>d</name> = <call><name><name>Integer</name>.<name>parseInt</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>fill</name> &gt;= <name><name>buf</name>.<name>length</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>tmp</name> = new <name><name>int</name><index>[<expr><name>fill</name> &lt;&lt; 1</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buf</name> = <name>tmp</name></expr>;</expr_stmt>
          }</block></then></if>

          <expr_stmt><expr><name><name>buf</name><index>[<expr><name>fill</name>++</expr>]</index></name> = (<name>d</name> - 1)</expr>;</expr_stmt>
        }</block></while>

      }</block> <finally>finally <block>{
        <expr_stmt><expr><call><name><name>r</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></finally></try>

      <if>if <condition>(<expr><name>fill</name> == <name><name>buf</name>.<name>length</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>buf</name></expr>;</return>
      }</block></then></if>

      <expr_stmt><expr><name>tmp</name> = new <name><name>int</name><index>[<expr><name>fill</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>tmp</name></expr>;</return>

    }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Store a permutation vector to a file
   * 
   * @param file
   *          the path to the file to load
   * @param P
   *          the vector to be stored
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>void</name></type> <name>storePermVector</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>file</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>P</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>BufferedWriter</name></type> <name>w</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <try>try <block>{
      <expr_stmt><expr><name>w</name> = new <call><name>BufferedWriter</name><argument_list>(<argument><expr>new <call><name>FileWriter</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <try>try <block>{

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>P</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
          <if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>w</name>.<name>newLine</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><call><name><name>w</name>.<name>write</name></name><argument_list>(<argument><expr><call><name><name>Integer</name>.<name>toString</name></name><argument_list>(<argument><expr><name><name>P</name><index>[<expr><name>i</name></expr>]</index></name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>(<name>i</name> % 100) &lt;= 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>w</name>.<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></for>

      }</block> <finally>finally <block>{
        <expr_stmt><expr><call><name><name>w</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></finally></try>
    }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Load a rotation matrix from a file
   * 
   * @param file
   *          the path to the file to load
   * @return the matrix loaded
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>double</name><index>[]</index></type> <name>loadRotMatrix</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>file</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>FileInputStream</name></type> <name>r</name></decl>;</decl_stmt>
    <try>try <block>{
      <expr_stmt><expr><name>r</name> = new <call><name>FileInputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <try>try <block>{
        <return>return <expr><call><name>loadRotMatrix</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t1</name></decl></param>) <block>{
        <try>try <block>{
          <expr_stmt><expr><call><name><name>r</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t2</name></decl></param>) <block>{
          <comment type="line">// not interesting here</comment>
        }</block></catch></try>
        <throw>throw <expr><name>t1</name></expr>;</throw>
      }</block></catch></try>

    }</block> <catch>catch (<param><decl><type><name>RuntimeException</name></type> <name>t1</name></decl></param>) <block>{
      <throw>throw <expr><name>t1</name></expr>;</throw>
    }</block></catch> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Load a rotation matrix from an uri
   * 
   * @param uri
   *          the uri to load from
   * @return the matrix loaded
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>double</name><index>[]</index></type> <name>loadRotMatrix</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>URI</name></type> <name>uri</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>URL</name></type> <name>u</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>InputStream</name></type> <name>r</name></decl>;</decl_stmt>
    <try>try <block>{
      <expr_stmt><expr><name>u</name> = <call><name><name>uri</name>.<name>toURL</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> = <call><name><name>u</name>.<name>openStream</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <try>try <block>{
        <return>return <expr><call><name>loadRotMatrix</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t1</name></decl></param>) <block>{
        <try>try <block>{
          <expr_stmt><expr><call><name><name>r</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t2</name></decl></param>) <block>{
          <comment type="line">// not interesting here</comment>
        }</block></catch></try>
        <throw>throw <expr><name>t1</name></expr>;</throw>
      }</block></catch></try>

    }</block> <catch>catch (<param><decl><type><name>RuntimeException</name></type> <name>t1</name></decl></param>) <block>{
      <throw>throw <expr><name>t1</name></expr>;</throw>
    }</block></catch> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Load a rotation matrix from an input stream
   * 
   * @param in
   *          the input stream
   * @return the matrix loaded
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>double</name><index>[]</index></type> <name>loadRotMatrix</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>in</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>BufferedReader</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name><index>[]</index></type> <name>buf</name>, <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fill</name>, <name>i</name>, <name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>ss</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>Pattern</name></type> <name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> = <call><name><name>Pattern</name>.<name>compile</name></name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//$NON-NLS-1$</comment>

    <try>try <block>{
      <expr_stmt><expr><name>buf</name> = new <name><name>double</name><index>[<expr>1000</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>fill</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> = new <call><name>BufferedReader</name><argument_list>(<argument><expr>new <call><name>InputStreamReader</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <try>try <block>{

        <label><name>outer</name>:</label> <while>while <condition>(<expr>(<name>s</name> = <call><name><name>r</name>.<name>readLine</name></name><argument_list>()</argument_list></call>) != <name>null</name></expr>)</condition> <block>{
          <expr_stmt><expr><name>s</name> = <call><name><name>s</name>.<name>trim</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><call><name><name>s</name>.<name>length</name></name><argument_list>()</argument_list></call> &lt;= 0</expr>)</condition><then> <block>{
            <continue>continue outer;</continue>
          }</block></then></if>

          <expr_stmt><expr><name>s</name> = <call><name><name>s</name>.<name>replace</name></name><argument_list>(<argument><expr>'\t'</expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call>.<call><name>replace</name><argument_list>(<argument><expr>'\f'</expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call>.<call><name>replace</name><argument_list>(<argument><expr>'\b'</expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>ss</name> = <call><name><name>p</name>.<name>split</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>l</name> = <name><name>ss</name>.<name>length</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>l</name> &lt;= 0</expr>)</condition><then> <block>{
            <continue>continue outer;</continue>
          }</block></then></if>

          <label><name>inner</name>:</label> <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>l</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>s</name> = <name><name>ss</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>trim</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>s</name>.<name>length</name></name><argument_list>()</argument_list></call> &lt;= 0</expr>)</condition><then> <block>{
              <continue>continue inner;</continue>
            }</block></then></if>

            <expr_stmt><expr><name>d</name> = <call><name><name>Double</name>.<name>parseDouble</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>fill</name> &gt;= <name><name>buf</name>.<name>length</name></name></expr>)</condition><then> <block>{
              <expr_stmt><expr><name>tmp</name> = new <name><name>double</name><index>[<expr><name>fill</name> &lt;&lt; 1</expr>]</index></name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>buf</name> = <name>tmp</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>fill</name>++</expr>]</index></name> = <name>d</name></expr>;</expr_stmt>
          }</block></for>
        }</block></while>

      }</block> <finally>finally <block>{
        <expr_stmt><expr><call><name><name>r</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></finally></try>

      <if>if <condition>(<expr><name>fill</name> == <name><name>buf</name>.<name>length</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>buf</name></expr>;</return>
      }</block></then></if>

      <expr_stmt><expr><name>tmp</name> = new <name><name>double</name><index>[<expr><name>fill</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>tmp</name></expr>;</return>

    }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="javadoc">/**
   * Store a rotation matrix to a file
   * 
   * @param file
   *          the path to the file to load
   * @param o
   *          the matrix to be stored
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>void</name></type> <name>storeRotMatrix</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>file</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>BufferedWriter</name></type> <name>w</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <try>try <block>{
      <expr_stmt><expr><name>w</name> = new <call><name>BufferedWriter</name><argument_list>(<argument><expr>new <call><name>FileWriter</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <try>try <block>{
        <expr_stmt><expr><name>len</name> = (<call>(<name>int</name>) <argument_list>(<argument><expr>0.9d + <call><name><name>Math</name>.<name>sqrt</name></name><argument_list>(<argument><expr><name><name>o</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>o</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
          <if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>(<name>i</name> % <name>len</name>) &lt;= 0</expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name><name>w</name>.<name>newLine</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
              <expr_stmt><expr><call><name><name>w</name>.<name>write</name></name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
          }</block></then></if>
          <expr_stmt><expr><call><name><name>w</name>.<name>write</name></name><argument_list>(<argument><expr><call><name><name>Double</name>.<name>toString</name></name><argument_list>(<argument><expr><name><name>o</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>(<name>i</name> % 100) &lt;= 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>w</name>.<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></for>

      }</block> <finally>finally <block>{
        <expr_stmt><expr><call><name><name>w</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></finally></try>
    }</block> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
      <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// bypass exception checking</comment>
    }</block></catch></try>
  }</block></function>

  <comment type="line">// /** the default seed for randomized function parameters */</comment>
  <comment type="line">// protected static final long DEFAULT_SEED = 1;</comment>

  <comment type="line">// /**</comment>
  <comment type="line">// * Create a random permutation vector</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @return the permutation vector</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final int[] defaultRandomPermVector(final int dim) {</comment>
  <comment type="line">// return createRandomPermVector(dim, DEFAULT_SEED);</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Create a random permutation vector</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @return the permutation vector</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final int[] createRandomPermVector(final int dim) {</comment>
  <comment type="line">// return createRandomPermVector(dim, new Random());</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Create a random permutation vector</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @param seed</comment>
  <comment type="line">// * the random seed</comment>
  <comment type="line">// * @return the permutation vector</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final int[] createRandomPermVector(final int dim,</comment>
  <comment type="line">// final long seed) {</comment>
  <comment type="line">// return createRandomPermVector(dim, new Random(seed));</comment>
  <comment type="line">// }</comment>

  <comment type="line">// /**</comment>
  <comment type="line">// * Create a random permutation vector</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @param r</comment>
  <comment type="line">// * the randomizer</comment>
  <comment type="line">// * @return the permutation vector</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final int[] createRandomPermVector(final int dim,</comment>
  <comment type="line">// final Random r) {</comment>
  <comment type="line">// final int[] d;</comment>
  <comment type="line">// int i, j, k, t;</comment>
  <comment type="line">//</comment>
  <comment type="line">// d = new int[dim];</comment>
  <comment type="line">//</comment>
  <comment type="line">// for (i = (dim - 1); i &gt;= 0; i--) {</comment>
  <comment type="line">// d[i] = i;</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// synchronized (r) {</comment>
  <comment type="line">// for (i = (dim &lt;&lt; 3); i &gt;= 0; i--) {</comment>
  <comment type="line">// j = r.nextInt(dim);</comment>
  <comment type="line">// do {</comment>
  <comment type="line">// k = r.nextInt(dim);</comment>
  <comment type="line">// } while (k == j);</comment>
  <comment type="line">//</comment>
  <comment type="line">// t = d[j];</comment>
  <comment type="line">// d[j] = d[k];</comment>
  <comment type="line">// d[k] = t;</comment>
  <comment type="line">// }</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// return d;</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Create a random rotation matrix</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @return the rotation matrix</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final double[] createRandomRotMatrix(final int dim) {</comment>
  <comment type="line">// return createRandomRotMatrix(dim, new Random());</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Obtain the default rotation matrix</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @return the default rotation matrix</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final double[] defaultRandomRotMatrix(final int dim) {</comment>
  <comment type="line">// return createRandomRotMatrix(dim, DEFAULT_SEED);</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Create a random rotation matrix</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @param seed</comment>
  <comment type="line">// * the random seed</comment>
  <comment type="line">// * @return the rotation matrix</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final double[] createRandomRotMatrix(final int dim,</comment>
  <comment type="line">// final long seed) {</comment>
  <comment type="line">// return createRandomRotMatrix(dim, new Random(seed));</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Create a random rotation matrix</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @param r</comment>
  <comment type="line">// * the randomizer</comment>
  <comment type="line">// * @return the rotation matrix</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final double[] createRandomRotMatrix(final int dim,</comment>
  <comment type="line">// final Random r) {</comment>
  <comment type="line">// final double[] m;</comment>
  <comment type="line">// int i, j, k;</comment>
  <comment type="line">// double dp, t;</comment>
  <comment type="line">//</comment>
  <comment type="line">// m = new double[dim * dim];</comment>
  <comment type="line">//</comment>
  <comment type="line">// synchronized (r) {</comment>
  <comment type="line">// outer: for (;;) {</comment>
  <comment type="line">//</comment>
  <comment type="line">// // initialize</comment>
  <comment type="line">// for (i = (m.length - 1); i &gt;= 0; i--) {</comment>
  <comment type="line">// m[i] = r.nextDouble();</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// // main loop</comment>
  <comment type="line">// for (i = (dim - 1); i &gt;= 0; i--) {</comment>
  <comment type="line">//</comment>
  <comment type="line">// //</comment>
  <comment type="line">// for (j = (dim - 1); j &gt; i; j--) {</comment>
  <comment type="line">//</comment>
  <comment type="line">// // dot product</comment>
  <comment type="line">// dp = 0d;</comment>
  <comment type="line">// for (k = (dim - 1); k &gt;= 0; k--) {</comment>
  <comment type="line">// dp += (m[(i * dim) + k] * m[(j * dim) + k]);</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// // subtract</comment>
  <comment type="line">// for (k = (dim - 1); k &gt;= 0; k--) {</comment>
  <comment type="line">// m[(i * dim) + k] -= (dp * m[(j * dim) + k]);</comment>
  <comment type="line">// }</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// // normalize</comment>
  <comment type="line">// dp = 0d;// subtract</comment>
  <comment type="line">// for (k = (dim - 1); k &gt;= 0; k--) {</comment>
  <comment type="line">// t = m[(i * dim) + k];</comment>
  <comment type="line">// dp += (t * t);</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// // linear dependency -&gt; restart</comment>
  <comment type="line">// if (dp &lt;= 0d) {</comment>
  <comment type="line">// continue outer;</comment>
  <comment type="line">// }</comment>
  <comment type="line">// dp = (1d / Math.sqrt(dp));</comment>
  <comment type="line">//</comment>
  <comment type="line">// for (k = (dim - 1); k &gt;= 0; k--) {</comment>
  <comment type="line">// m[(i * dim) + k] *= dp;</comment>
  <comment type="line">// }</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// return m;</comment>
  <comment type="line">// }</comment>
  <comment type="line">// }</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Create the default shift vector</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @param min</comment>
  <comment type="line">// * the minimum value a decision variable can take on</comment>
  <comment type="line">// * @param max</comment>
  <comment type="line">// * the maximum value a decision variable can take on</comment>
  <comment type="line">// * @return the shift vector</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final double[] defaultRandomShiftVector(final int dim,</comment>
  <comment type="line">// final double min, final double max) {</comment>
  <comment type="line">// return createRandomShiftVector(dim, min, max, DEFAULT_SEED);</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Create a random shift vector</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @param min</comment>
  <comment type="line">// * the minimum value a decision variable can take on</comment>
  <comment type="line">// * @param max</comment>
  <comment type="line">// * the maximum value a decision variable can take on</comment>
  <comment type="line">// * @param seed</comment>
  <comment type="line">// * the randomizer seed</comment>
  <comment type="line">// * @return the shift vector</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final double[] createRandomShiftVector(final int dim,</comment>
  <comment type="line">// final double min, final double max, final long seed) {</comment>
  <comment type="line">// return createRandomShiftVector(dim, min, max, new Random(seed));</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Create a random shift vector</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @param min</comment>
  <comment type="line">// * the minimum value a decision variable can take on</comment>
  <comment type="line">// * @param max</comment>
  <comment type="line">// * the maximum value a decision variable can take on</comment>
  <comment type="line">// * @return the shift vector</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final double[] createRandomShiftVector(final int dim,</comment>
  <comment type="line">// final double min, final double max) {</comment>
  <comment type="line">// return createRandomShiftVector(dim, min, max, new Random());</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Create a random shift vector</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param dim</comment>
  <comment type="line">// * the number of dimensions</comment>
  <comment type="line">// * @param min</comment>
  <comment type="line">// * the minimum value a decision variable can take on</comment>
  <comment type="line">// * @param max</comment>
  <comment type="line">// * the maximum value a decision variable can take on</comment>
  <comment type="line">// * @param r</comment>
  <comment type="line">// * the randomizer</comment>
  <comment type="line">// * @return the shift vector</comment>
  <comment type="line">// */</comment>
  <comment type="line">// public static final double[] createRandomShiftVector(final int dim,</comment>
  <comment type="line">// final double min, final double max, final Random r) {</comment>
  <comment type="line">// final double[] d;</comment>
  <comment type="line">// final double w, hw, middle;</comment>
  <comment type="line">// int i;</comment>
  <comment type="line">//</comment>
  <comment type="line">// w = (max - min);</comment>
  <comment type="line">// hw = (0.5d * w);</comment>
  <comment type="line">// middle = (min + hw);</comment>
  <comment type="line">// d = new double[dim];</comment>
  <comment type="line">//</comment>
  <comment type="line">// synchronized (r) {</comment>
  <comment type="line">// for (i = (dim - 1); i &gt;= 0; i--) {</comment>
  <comment type="line">// d[i] = (middle + (r.nextDouble() * w) - hw);</comment>
  <comment type="line">// }</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// return d;</comment>
  <comment type="line">// }</comment>

  <comment type="javadoc">/**
   * The test function used to check whether the routines here have been
   * implemented correctly.
   * 
   * @param params
   *          the parameters
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>void</name></type> <name>main</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>params</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>double</name><index>[]</index></type> <name>m</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name>, <name>i</name>, <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>n</name> = 50</expr>;</expr_stmt>
    <comment type="line">//storeRotMatrix("E:\\1.txt", createRandomRotMatrix(n)); //$NON-NLS-1$</comment>
    <comment type="line">//m = loadRotMatrix("E:\\1.txt"); //$NON-NLS-1$</comment>
    <expr_stmt><expr><name>m</name> = <call><name>loadRotMatrix</name><argument_list>(<argument><expr>"e:/ackley_M_D50.txt"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//$NON-NLS-1$</comment>
    <comment type="line">// m = createRandomRotMatrix(n);</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name>j</name> &gt; 0</expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr>'\t'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr><name><name>m</name><index>[<expr><name>i</name> * <name>n</name> + <name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></function>
}</block></class>
</unit>
