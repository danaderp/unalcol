<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C#" filename="C:\Users\Daavid\git\unalcol\redress2\srcML\SparseCoOccurrenceMatrix.cs"><using>using <name>System</name>;</using>
<using>using <name><name>System</name>.<name>Collections</name>.<name>Generic</name></name>;</using>
<using>using <name><name>System</name>.<name>Drawing</name></name>;</using>
<using>using <name><name>System</name>.<name>IO</name></name>;</using>
<using>using <name><name>System</name>.<name>Linq</name></name>;</using>
<using>using <name><name>System</name>.<name>Text</name></name>;</using>

<namespace>namespace <name><name>Sando</name>.<name>Core</name>.<name>Tools</name></name>
<block>{
    <class><specifier>public</specifier> class <name>SparseCoOccurrenceMatrix</name> <super>: <name>IWordCoOccurrenceMatrix</name></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>readonly</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>allWords</name> =<init> <expr>new <call><name><name>List</name><argument_list>&lt;<argument><name>string</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>readonly</specifier> <name><name>List</name><argument_list>&lt;<argument><name>BoxedInt</name></argument>&gt;</argument_list></name></type> <name>A</name> =<init> <expr>new <call><name><name>List</name><argument_list>&lt;<argument><name>BoxedInt</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>readonly</specifier> <name><name>List</name><argument_list>&lt;<argument><name>BoxedInt</name></argument>&gt;</argument_list></name></type> <name>IA</name> =<init> <expr>new <call><name><name>List</name><argument_list>&lt;<argument><name>BoxedInt</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>readonly</specifier> <name><name>List</name><argument_list>&lt;<argument><name>BoxedInt</name></argument>&gt;</argument_list></name></type> <name>JA</name> =<init> <expr>new <call><name><name>List</name><argument_list>&lt;<argument><name>BoxedInt</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>readonly</specifier> <name>object</name></type> <name>locker</name> =<init> <expr>new <call><name>object</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>SparseCoOccurrenceMatrix</name><parameter_list>()</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>TimedProcessor</name>.<name>GetInstance</name></name><argument_list>()</argument_list></call>.<call><name>AddTimedTask</name><argument_list>(<argument><expr><name>SaveToFile</name></expr></argument>, <argument><expr>13 * 60 * 1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <class><specifier>private</specifier> class <name>BoxedInt</name> <super>: <name><name>IComparable</name><argument_list>&lt;<argument><name>BoxedInt</name></argument>&gt;</argument_list></name></super>
        <block>{
            <decl_stmt><decl><type><specifier>public</specifier> <name>int</name></type> <name>Value</name> <block>{ <function_decl><name>get</name>;</function_decl> <function_decl><name>set</name>;</function_decl> }</block></decl></decl_stmt>

            <constructor><specifier>public</specifier> <name>BoxedInt</name><parameter_list>(<param><decl><type><name>int</name></type> <name>Value</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><name><name>this</name>.<name>Value</name></name> = <name>Value</name></expr>;</expr_stmt>
            }</block></constructor>

            <function><type><specifier>public</specifier> <name>int</name></type> <name>CompareTo</name><parameter_list>(<param><decl><type><name>BoxedInt</name></type> <name>other</name></decl></param>)</parameter_list>
            <block>{
                <return>return <expr><call><name><name>this</name>.<name>Value</name>.<name>CompareTo</name></name><argument_list>(<argument><expr><name><name>other</name>.<name>Value</name></name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></function>
        }</block></class>

        <function><type><specifier>private</specifier> <name>int</name></type> <name>GetValue</name><parameter_list>(<param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>column</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>var</name></type> <name>columnNumbers</name> =<init> <expr><call><name>GetNonZeroColumnNumbers</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call>.<call><name>ToList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>var</name></type> <name>allRow</name> =<init> <expr><call><name><name>A</name>.<name>GetRange</name></name><argument_list>(<argument><expr><call><name><name>IA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call>.<name>Value</name></expr></argument>, <argument><expr><name><name>columnNumbers</name>.<name>Count</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>var</name></type> <name>index</name> =<init> <expr><call><name><name>columnNumbers</name>.<name>BinarySearch</name></name><argument_list>(<argument><expr>new <call><name>BoxedInt</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><name>index</name> &gt;= 0 ? <call><name><name>allRow</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call>.<name>Value</name> : 0</expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name><name>IEnumerable</name><argument_list>&lt;<argument><name>BoxedInt</name></argument>&gt;</argument_list></name></type> <name>GetNonZeroColumnNumbers</name><parameter_list>(<param><decl><type><name>int</name></type> <name>row</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>var</name></type> <name>start</name> =<init> <expr><call><name><name>IA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call>.<name>Value</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>var</name></type> <name>length</name> =<init> <expr><name>row</name> + 1 &lt; <name><name>IA</name>.<name>Count</name> ?</name> <call><name><name>IA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>row</name> + 1</expr></argument>)</argument_list></call>.<name>Value</name> - <name>start</name> 
                : <name><name>JA</name>.<name>Count</name></name> - <name>start</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>JA</name>.<name>GetRange</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>InsertRowAndColumnAt</name><parameter_list>(<param><decl><type><name>int</name></type> <name>index</name></decl></param>, <param><decl><type><name>int</name></type> <name>value</name></decl></param>)</parameter_list>
        <block>{
            <comment type="line">// Update A.</comment>
            <decl_stmt><decl><type><name>var</name></type> <name>AIndex</name> =<init> <expr><name><name>IA</name>.<name>Count</name></name> &gt; <name>index</name> &amp;&amp; <name>index</name> &gt;= 0 ? <call><name><name>IA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call>.<name>Value</name> :
                <name>index</name> - 1 &gt;= 0 &amp;&amp; <name>index</name> - 1 &lt; <name><name>IA</name>.<name>Count</name> ?</name> <call><name><name>IA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>index</name> - 1</expr></argument>)</argument_list></call>.<name>Value</name> 
                    + <call><name>GetNonZeroColumnNumbers</name><argument_list>(<argument><expr><name>index</name> - 1</expr></argument>)</argument_list></call>.<call><name>Count</name><argument_list>()</argument_list></call> : 0</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>A</name>.<name>Insert</name></name><argument_list>(<argument><expr><name>AIndex</name></expr></argument>, <argument><expr>new <call><name>BoxedInt</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Update IA.</comment>
            <expr_stmt><expr><call><name><name>IA</name>.<name>Insert</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr>new <call><name>BoxedInt</name><argument_list>(<argument><expr><name>AIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>index</name> + 1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>IA</name>.<name>Count</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <expr_stmt><expr><call><name><name>IA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<name>Value</name> ++</expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// Update JA.</comment>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>JA</name>.<name>Count</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <expr_stmt><expr><call><name><name>JA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<name>Value</name> = <call><name><name>JA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<name>Value</name> &gt;= <name>index</name>
                    ? <call><name><name>JA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<name>Value</name> + 1
                        : <call><name><name>JA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<name>Value</name></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name><name>JA</name>.<name>Insert</name></name><argument_list>(<argument><expr><name>AIndex</name></expr></argument>, <argument><expr>new <call><name>BoxedInt</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>IncrementCell</name><parameter_list>(<param><decl><type><name>int</name></type> <name>row</name></decl></param>, <param><decl><type><name>int</name></type> <name>column</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>var</name></type> <name>columns</name> =<init> <expr><call><name>GetNonZeroColumnNumbers</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call>.<call><name>ToList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>var</name></type> <name>index</name> =<init> <expr><call><name><name>columns</name>.<name>BinarySearch</name></name><argument_list>(<argument><expr>new <call><name>BoxedInt</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>index</name> &gt;= 0</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>A</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><call><name><name>IA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call>.<name>Value</name> + <name>index</name></expr></argument>)</argument_list></call>.<name>Value</name>++</expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>
            
            <comment type="line">// Update A</comment>
            <decl_stmt><decl><type><name>var</name></type> <name>position</name> =<init> <expr>~<name>index</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>var</name></type> <name>AIndex</name> =<init> <expr><name>position</name> + <call><name><name>IA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call>.<name>Value</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>A</name>.<name>Insert</name></name><argument_list>(<argument><expr><name>AIndex</name></expr></argument>, <argument><expr>new <call><name>BoxedInt</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Update IA</comment>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>row</name> + 1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>IA</name>.<name>Count</name></name></expr>;</condition> <incr><expr><name>i</name> ++</expr></incr>)
            <block>{
                <expr_stmt><expr><call><name><name>IA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<name>Value</name>++</expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// Udpate JA</comment>
            <expr_stmt><expr><call><name><name>JA</name>.<name>Insert</name></name><argument_list>(<argument><expr><name>AIndex</name></expr></argument>, <argument><expr>new <call><name>BoxedInt</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <decl_stmt><decl><type><specifier>private</specifier> <specifier>const</specifier> <name>int</name></type> <name>GRAM_NUMBER</name> =<init> <expr>3</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>const</specifier> <name>int</name></type> <name>MAX_WORD_LENGTH</name> =<init> <expr>3</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>const</specifier> <name>int</name></type> <name>MAX_COOCCURRENCE_WORDS_COUNT</name> =<init> <expr>100</expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>readonly</specifier> <name>WorkQueueBasedProcess</name></type> <name>queue</name> =<init> <expr>new <call><name>WorkQueueBasedProcess</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>const</specifier> <name>string</name></type> <name>fileName</name> =<init> <expr>"SparseMatrix.txt"</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>string</name></type> <name>directory</name></decl>;</decl_stmt>

       
        <function><type><specifier>public</specifier> <name>int</name></type> <name>GetCoOccurrenceCount</name><parameter_list>(<param><decl><type><name>string</name></type> <name>word1</name></decl></param>, <param><decl><type><name>string</name></type> <name>word2</name></decl></param>)</parameter_list>
        <block>{
            <lock>lock (<expr><name>locker</name></expr>)
            <block>{
                <decl_stmt><decl><type><name>var</name></type> <name>row</name> =<init> <expr><call><name><name>allWords</name>.<name>BinarySearch</name></name><argument_list>(<argument><expr><name>word1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>var</name></type> <name>column</name> =<init> <expr><call><name><name>allWords</name>.<name>BinarySearch</name></name><argument_list>(<argument><expr><name>word2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <return>return <expr><name>row</name> &gt;= 0 &amp;&amp; <name>column</name> &gt;= 0 ? <call><name>GetValue</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call> : 0</expr>;</return>
            }</block></lock>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>Initialize</name><parameter_list>(<param><decl><type><name>string</name></type> <name>directory</name></decl></param>)</parameter_list>
        <block>{
            <lock>lock (<expr><name>locker</name></expr>)
            <block>{
                <expr_stmt><expr><name><name>this</name>.<name>directory</name></name> = <name>directory</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ClearMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ReadFromFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></lock>            
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>ReadFromFile</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><call><name><name>File</name>.<name>Exists</name></name><argument_list>(<argument><expr><call><name>GetMatrixFilePath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>var</name></type> <name>lines</name> =<init> <expr><call><name><name>File</name>.<name>ReadAllLines</name></name><argument_list>(<argument><expr><call><name>GetMatrixFilePath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>allWords</name>.<name>AddRange</name></name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr>0</expr>]</index></name>.<call><name>Split</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>A</name>.<name>AddRange</name></name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr>1</expr>]</index></name>.<call><name>Split</name><argument_list>()</argument_list></call>.<call><name>Select</name><argument_list>(<argument><expr><name>i</name> =&gt; new <call><name>BoxedInt</name><argument_list>(<argument><expr><call><name><name>int</name>.<name>Parse</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>IA</name>.<name>AddRange</name></name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr>2</expr>]</index></name>.<call><name>Split</name><argument_list>()</argument_list></call>.<call><name>Select</name><argument_list>(<argument><expr><name>i</name> =&gt; new <call><name>BoxedInt</name><argument_list>(<argument><expr><call><name><name>int</name>.<name>Parse</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>JA</name>.<name>AddRange</name></name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr>3</expr>]</index></name>.<call><name>Split</name><argument_list>()</argument_list></call>.<call><name>Select</name><argument_list>(<argument><expr><name>i</name> =&gt; new <call><name>BoxedInt</name><argument_list>(<argument><expr><call><name><name>int</name>.<name>Parse</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>ClearMemory</name><parameter_list>()</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>this</name>.<name>allWords</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name>.<name>A</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name>.<name>IA</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name>.<name>JA</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>Dispose</name><parameter_list>()</parameter_list>
        <block>{
            <lock>lock (<expr><name>locker</name></expr>)
            <block>{
                <expr_stmt><expr><call><name><name>TimedProcessor</name>.<name>GetInstance</name></name><argument_list>()</argument_list></call>.<call><name>RemoveTimedTask</name><argument_list>(<argument><expr><name>SaveToFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SaveToFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ClearMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></lock>
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>SaveToFile</name><parameter_list>()</parameter_list>
        <block>{
            <lock>lock (<expr><name>locker</name></expr>)
            <block>{
                <if>if <condition>(<expr><call><name><name>Directory</name>.<name>Exists</name></name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>allWords</name>.<name>Any</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <block>{
                    <decl_stmt><decl><type><name>var</name></type> <name>lineOne</name> =<init> <expr><call><name><name>allWords</name>.<name>Aggregate</name></name><argument_list>(<argument><expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>builder</name>, <name>word</name>) =&gt; <call><name><name>builder</name>.<name>Append</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call>.<call><name>Append</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>                    
                    <decl_stmt><decl><type><name>var</name></type> <name>lineTwo</name> =<init> <expr><call><name><name>A</name>.<name>Select</name></name><argument_list>(<argument><expr><name>i</name> =&gt; <call><name><name>i</name>.<name>Value</name>.<name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>Aggregate</name><argument_list>(<argument><expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>builder</name>, <name>number</name>) =&gt; <call><name><name>builder</name>.<name>Append</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call>.<call><name>Append</name><argument_list>( <argument><expr>" "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>var</name></type> <name>lineThree</name> =<init> <expr><call><name><name>IA</name>.<name>Select</name></name><argument_list>(<argument><expr><name>i</name> =&gt; <call><name><name>i</name>.<name>Value</name>.<name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>Aggregate</name><argument_list>(<argument><expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>builder</name>, <name>number</name>) =&gt; <call><name><name>builder</name>.<name>Append</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call>.<call><name>Append</name><argument_list>( <argument><expr>" "</expr></argument> )</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>var</name></type> <name>lineFour</name> =<init> <expr><call><name><name>JA</name>.<name>Select</name></name><argument_list>(<argument><expr><name>i</name> =&gt; <call><name><name>i</name>.<name>Value</name>.<name>ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>Aggregate</name><argument_list>(<argument><expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>builder</name>, <name>number</name>) =&gt; <call><name><name>builder</name>.<name>Append</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call>.<call><name>Append</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>var</name></type> <name>lines</name> =<init> <expr>new <name><name>string</name><index>[]</index></name> <block>{<expr><call><name><name>lineOne</name>.<name>ToString</name></name><argument_list>()</argument_list></call>.<call><name>TrimEnd</name><argument_list>()</argument_list></call></expr>, <expr><call><name><name>lineTwo</name>.<name>ToString</name></name><argument_list>()</argument_list></call>.<call><name>TrimEnd</name><argument_list>()</argument_list></call></expr>, <expr><call><name><name>lineThree</name>.<name>ToString</name></name><argument_list>()</argument_list></call>.<call><name>TrimEnd</name><argument_list>()</argument_list></call></expr>, <expr><call><name><name>lineFour</name>.<name>ToString</name></name><argument_list>()</argument_list></call>.<call><name>TrimEnd</name><argument_list>()</argument_list></call></expr>}</block></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>File</name>.<name>WriteAllLines</name></name><argument_list>(<argument><expr><call><name>GetMatrixFilePath</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></lock>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>HandleCoOcurrentWordsAsync</name><parameter_list>(<param><decl><type><name><name>IEnumerable</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>words</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>queue</name>.<name>Enqueue</name></name><argument_list>(<argument><expr><name>n</name> =&gt; <block>{ 
                <expr_stmt><expr><call><name>HandleCoOcurrentWordsSync</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
            }</block></expr></argument>, <argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name><name>Dictionary</name><argument_list>&lt;<argument><name>string</name></argument>, <argument><name>int</name></argument>&gt;</argument_list></name></type> <name>GetCoOccurredWordsAndCount</name><parameter_list>(<param><decl><type><name>string</name></type> <name>word</name></decl></param>)</parameter_list>
        <block>{
            <lock>lock (<expr><name>locker</name></expr>)
            <block>{
                <decl_stmt><decl><type><name>var</name></type> <name>row</name> =<init> <expr><call><name><name>allWords</name>.<name>BinarySearch</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>row</name> &lt; 0</expr>)</condition><then> <return>return <expr>new <call><name><name>Dictionary</name><argument_list>&lt;<argument><name>string</name></argument>, <argument><name>int</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return></then></if>
                <decl_stmt><decl><type><name>var</name></type> <name>columns</name> =<init> <expr><call><name>GetNonZeroColumnNumbers</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <return>return <expr><call><name><name>columns</name>.<name>Select</name></name><argument_list>(<argument><expr><name>c</name> =&gt; <call><name><name>allWords</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name><name>c</name>.<name>Value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>.<call><name>ToDictionary</name><argument_list>(<argument><expr><name>k</name> =&gt; <name>k</name></expr></argument>,
                    <argument><expr><name>k</name> =&gt; <call><name>GetCoOccurrenceCount</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            }</block></lock>
        }</block></function>

        <function><type><specifier>public</specifier> <name><name>Dictionary</name><argument_list>&lt;<argument><name>string</name></argument>, <argument><name>int</name></argument>&gt;</argument_list></name></type> <name>GetAllWordsAndCount</name><parameter_list>()</parameter_list>
        <block>{
            <lock>lock (<expr><name>locker</name></expr>)
            <block>{
                <return>return <expr><call><name><name>allWords</name>.<name>ToDictionary</name></name><argument_list>(<argument><expr><name>w</name> =&gt; <name>w</name></expr></argument>, <argument><expr><name>w</name> =&gt; <call><name>GetCoOccurrenceCount</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            }</block></lock>
        }</block></function>

        <function><type><specifier>public</specifier> <name><name>IEnumerable</name><argument_list>&lt;<argument><name>IMatrixEntry</name></argument>&gt;</argument_list></name></type> <name>GetEntries</name><parameter_list>(<param><decl><type><name><name>Predicate</name><argument_list>&lt;<argument><name>IMatrixEntry</name></argument>&gt;</argument_list></name></type> <name>predicate</name></decl></param>)</parameter_list>
        <block>{
            <lock>lock (<expr><name>locker</name></expr>)
            <block>{
                <decl_stmt><decl><type><name>var</name></type> <name>results</name> =<init> <expr>new <call><name><name>List</name><argument_list>&lt;<argument><name>IMatrixEntry</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>JA</name>.<name>Count</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <block>{
                    <decl_stmt><decl><type><name>var</name></type> <name>row</name> =<init> <expr><call><name>GetRowByAIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>var</name></type> <name>column</name> =<init> <expr><call><name><name>JA</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<name>Value</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>var</name></type> <name>count</name> =<init> <expr><call><name><name>A</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<name>Value</name></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>var</name></type> <name>rowWord</name> =<init> <expr><call><name><name>allWords</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>var</name></type> <name>columnWord</name> =<init> <expr><call><name><name>allWords</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>var</name></type> <name>entry</name> =<init> <expr>new <call><name>MatrixEntry</name><argument_list>(<argument><expr><name>rowWord</name></expr></argument>, <argument><expr><name>columnWord</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><call><name><name>predicate</name>.<name>Invoke</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name><name>results</name>.<name>Add</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></for>
                <return>return <expr><name>results</name></expr>;</return>
            }</block></lock>
        }</block></function>

        <function><type><specifier>private</specifier> <name>int</name></type> <name>GetRowByAIndex</name><parameter_list>(<param><decl><type><name>int</name></type> <name>aIndex</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>var</name></type> <name>IAIndex</name> =<init> <expr><call><name><name>IA</name>.<name>BinarySearch</name></name><argument_list>(<argument><expr>new <call><name>BoxedInt</name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><name>IAIndex</name> &gt;= 0 ? <name>IAIndex</name> : ~<name>IAIndex</name> - 1</expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>HandleCoOcurrentWordsSync</name><parameter_list>(<param><decl><type><name><name>IEnumerable</name><argument_list>&lt;<argument><name>string</name></argument>&gt;</argument_list></name></type> <name>words</name></decl></param>)</parameter_list>
        <block>{
            <lock>lock (<expr><name>locker</name></expr>)
            <block>{
                <expr_stmt><expr><name>words</name> = <call><name>SelectWords</name><argument_list>(<argument><expr><call><name><name>words</name>.<name>ToList</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>ToList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Add new words.</comment>
                <decl_stmt><decl><type><name>var</name></type> <name>newWords</name> =<init> <expr><call><name><name>words</name>.<name>Except</name></name><argument_list>(<argument><expr><name>allWords</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <foreach>foreach (<init><decl><type><name>var</name></type> <name>nw</name> <init>in <expr><name>newWords</name></expr></init></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>var</name></type> <name>index</name> =<init> <expr><call><name><name>allWords</name>.<name>BinarySearch</name></name><argument_list>(<argument><expr><name>nw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>InsertRowAndColumnAt</name><argument_list>(<argument><expr>~<name>index</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>allWords</name>.<name>Insert</name></name><argument_list>(<argument><expr>~<name>index</name></expr></argument>, <argument><expr><name>nw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></foreach>

                <comment type="line">// Increment occurrence.</comment>
                <decl_stmt><decl><type><name>var</name></type> <name>entries</name> =<init> <expr><call><name>GetBigramEntries</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <foreach>foreach (<init><decl><type><name>var</name></type> <name>entry</name> <init>in <expr><name>entries</name></expr></init></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>int</name></type> <name>rowNumber</name>, <name>columnNumber</name></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>ComputeWordPosition</name><argument_list>(<argument><expr><name><name>entry</name>.<name>Row</name></name></expr></argument>, <argument><expr><name><name>entry</name>.<name>Column</name></name></expr></argument>, <argument><specifier>out</specifier> <expr><name>rowNumber</name></expr></argument>, 
                        <argument><specifier>out</specifier> <expr><name>columnNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>IncrementCell</name><argument_list>(<argument><expr><name>rowNumber</name></expr></argument>, <argument><expr><name>columnNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></foreach>
            }</block></lock>
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>ComputeWordPosition</name><parameter_list>(<param><decl><type><name>String</name></type> <name>rowWord</name></decl></param>, <param><decl><type><name>string</name></type> <name>columnWord</name></decl></param>, 
            <param><decl><type><specifier>out</specifier> <name>int</name></type> <name>row</name></decl></param>, <param><decl><type><specifier>out</specifier> <name>int</name></type> <name>column</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>row</name> = <call><name><name>allWords</name>.<name>BinarySearch</name></name><argument_list>(<argument><expr><name>rowWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>column</name> = <call><name><name>allWords</name>.<name>BinarySearch</name></name><argument_list>(<argument><expr><name>columnWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>private</specifier> <name><name>IEnumerable</name><argument_list>&lt;<argument><name>MatrixEntry</name></argument>&gt;</argument_list></name></type> <name>GetBigramEntries</name><parameter_list>(<param><decl><type><name><name>IEnumerable</name><argument_list>&lt;<argument><name>string</name></argument>&gt;</argument_list></name></type> <name>words</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>var</name></type> <name>list</name> =<init> <expr><call><name><name>words</name>.<name>ToList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>var</name></type> <name>allEntries</name> =<init> <expr>new <call><name><name>List</name><argument_list>&lt;<argument><name>MatrixEntry</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> + <name>GRAM_NUMBER</name> - 1 &lt; <name><name>list</name>.<name>Count</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <expr_stmt><expr><call><name><name>allEntries</name>.<name>AddRange</name></name><argument_list>(<argument><expr><call><name>InternalGetEntries</name><argument_list>(<argument><expr><call><name><name>list</name>.<name>GetRange</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>GRAM_NUMBER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// Check if having leftovers.</comment>
            <if>if <condition>(<expr><name>i</name> + <name>GRAM_NUMBER</name> - 1 != <name><name>list</name>.<name>Count</name></name> - 1 &amp;&amp; <call><name><name>list</name>.<name>Any</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>allEntries</name>.<name>AddRange</name></name><argument_list>(<argument><expr><call><name>InternalGetEntries</name><argument_list>(<argument><expr><call><name><name>list</name>.<name>GetRange</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>list</name>.<name>Count</name></name> - <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <return>return <expr><name>allEntries</name></expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name><name>IEnumerable</name><argument_list>&lt;<argument><name>MatrixEntry</name></argument>&gt;</argument_list></name></type> <name>InternalGetEntries</name><parameter_list>(<param><decl><type><name><name>IEnumerable</name><argument_list>&lt;<argument><name>string</name></argument>&gt;</argument_list></name></type> <name>words</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>var</name></type> <name>list</name> =<init> <expr><call><name><name>words</name>.<name>ToList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>var</name></type> <name>allEntries</name> =<init> <expr>new <call><name><name>List</name><argument_list>&lt;<argument><name>MatrixEntry</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>list</name>.<name>Count</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <decl_stmt><decl><type><name>var</name></type> <name>word1</name> =<init> <expr><call><name><name>list</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name>i</name></expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name><name>list</name>.<name>Count</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
                <block>{
                    <decl_stmt><decl><type><name>var</name></type> <name>word2</name> =<init> <expr><call><name><name>list</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>allEntries</name>.<name>Add</name></name><argument_list>(<argument><expr>new <call><name>MatrixEntry</name><argument_list>(<argument><expr><name>word1</name></expr></argument>, <argument><expr><name>word2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>allEntries</name>.<name>Add</name></name><argument_list>(<argument><expr>new <call><name>MatrixEntry</name><argument_list>(<argument><expr><name>word2</name></expr></argument>, <argument><expr><name>word1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></for>
            <return>return <expr><name>allEntries</name></expr>;</return>
        }</block></function>


        <function><type><specifier>private</specifier> <name><name>IEnumerable</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>SelectWords</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>string</name></argument>&gt;</argument_list></name></type> <name>words</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>words</name> = <call><name>FilterOutBadWords</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call>.<call><name>ToList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>words</name> = (<name><name>words</name>.<name>Count</name></name> &gt; <name>MAX_COOCCURRENCE_WORDS_COUNT</name>)
                ? <call><name><name>words</name>.<name>GetRange</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>MAX_COOCCURRENCE_WORDS_COUNT</name></expr></argument>)</argument_list></call>
                   : <name>words</name></expr>;</expr_stmt>
            <return>return <expr><call><name><name>words</name>.<name>Distinct</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name><name>IEnumerable</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>FilterOutBadWords</name><parameter_list>(<param><decl><type><name><name>IEnumerable</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>words</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><call><name><name>words</name>.<name>Where</name></name><argument_list>(<argument><expr><name>w</name> =&gt; <name><name>w</name>.<name>Length</name></name> &gt;= <name>MAX_WORD_LENGTH</name>
                || <call><name><name>w</name>.<name>Contains</name></name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call> || <call><name><name>w</name>.<name>Contains</name></name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <class><specifier>private</specifier> class <name>MatrixEntry</name> <super>: <name>IMatrixEntry</name></super>
        <block>{
            <decl_stmt><decl><type><specifier>public</specifier> <name>string</name></type> <name>Row</name> <block>{ <function_decl><name>get</name>;</function_decl> private <function_decl><name>set</name>;</function_decl> }</block></decl></decl_stmt>
            <decl_stmt><decl><type><specifier>public</specifier> <name>string</name></type> <name>Column</name> <block>{ <function_decl><name>get</name>;</function_decl> private <function_decl><name>set</name>;</function_decl> }</block></decl></decl_stmt>
            <decl_stmt><decl><type><specifier>public</specifier> <name>int</name></type> <name>Count</name> <block>{ <function_decl><name>get</name>;</function_decl> private <function_decl><name>set</name>;</function_decl> }</block></decl></decl_stmt>

            <constructor><specifier>public</specifier> <name>MatrixEntry</name><parameter_list>(<param><decl><type><name>String</name></type> <name>Row</name></decl></param>, <param><decl><type><name>String</name></type> <name>Column</name></decl></param>, <param><decl><type><name>int</name></type> <name>Count</name> =<init> <expr>0</expr></init></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><name><name>this</name>.<name>Row</name></name> = <name>Row</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>Column</name></name> = <name>Column</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>Count</name></name> = <name>Count</name></expr>;</expr_stmt>
            }</block></constructor>
        }</block></class>

        <function><type><specifier>private</specifier> <name>string</name></type> <name>GetMatrixFilePath</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>Path</name>.<name>Combine</name></name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>
}</block></namespace>
</unit>
