<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\Daavid\git\unalcol\redress2\test_data\code\optimizacion\src\unalcol\types\collection\vector\Vector.java"><comment type="block">/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */</comment>
<package>package <name><name>unalcol</name>.<name>types</name>.<name>collection</name>.<name>vector</name></name>;</package>

<import>import <name><name>unalcol</name>.<name>random</name>.<name>integer</name>.<name>UniformIntegerGenerator</name></name>;</import>
<import>import <name><name>unalcol</name>.<name>types</name>.<name>collection</name>.<name>Location</name></name>;</import>
<import>import <name><name>unalcol</name>.<name>types</name>.<name>collection</name>.<name>array</name>.<name>ArrayCollectionLocation</name></name>;</import>
<import>import <name><name>unalcol</name>.<name>types</name>.<name>collection</name>.<name>array</name>.<name>MutableArrayCollection</name></name>;</import>

<comment type="javadoc">/**
 *
 * @author jgomez
 */</comment>
<class><specifier>public</specifier> class <name><name>Vector</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name> <super><extends>extends <name><name>ImmutableVector</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends> <implements>implements <name><name>MutableArrayCollection</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></implements></super> <block>{
    <decl_stmt><decl><type><specifier>protected</specifier> <name>int</name></type> <name>a</name>, <name>b</name>, <name>c</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_C</name> =<init> <expr>144</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_B</name> =<init> <expr>89</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_A</name> =<init> <expr>55</expr></init></decl>;</decl_stmt>
    
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>void</name></type> <name>find_fib</name><parameter_list>( <param><decl><type><name>int</name></type> <name>s</name></decl></param> )</parameter_list><block>{
        <expr_stmt><expr><name>a</name> = <name>DEFAULT_A</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>b</name> = <name>DEFAULT_B</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> = <name>DEFAULT_C</name></expr>;</expr_stmt>
        <while>while<condition>(<expr><name>s</name>&gt;<name>c</name></expr>)</condition><block>{
            <expr_stmt><expr><name>a</name>=<name>b</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>b</name>=<name>c</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name>=<name>a</name>+<name>b</name></expr>;</expr_stmt>
        }</block></while>
    }</block></function>
    
    <constructor><specifier>public</specifier> <name>Vector</name><parameter_list>( <param><decl><type><name><name>T</name><index>[]</index></name></type> <name>buffer</name></decl></param> )</parameter_list><block>{
        <expr_stmt><expr><call><name>super</name><argument_list>( <argument><expr><name>buffer</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> = <name><name>buffer</name>.<name>length</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>find_fib</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>Vector</name><parameter_list>( <param><decl><type><name><name>T</name><index>[]</index></name></type> <name>buffer</name></decl></param>, <param><decl><type><name>int</name></type> <name>s</name></decl></param> )</parameter_list><block>{
        <expr_stmt><expr><call><name>super</name><argument_list>( <argument><expr><name>buffer</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> = <name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>find_fib</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>Vector</name><parameter_list>()</parameter_list><block>{
        <expr_stmt><expr><call><name>super</name><argument_list>( <argument><expr>(<name><name>T</name><index>[]</index></name>)new <name><name>Object</name><index>[<expr><name>DEFAULT_C</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> = <name>DEFAULT_A</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>b</name> = <name>DEFAULT_B</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> = <name>DEFAULT_C</name></expr>;</expr_stmt>
    }</block></constructor>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>clear</name><parameter_list>()</parameter_list><block>{
        <expr_stmt><expr><name>size</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>buffer</name>=(<name><name>T</name><index>[]</index></name>)new <name><name>Object</name><index>[<expr><name>DEFAULT_C</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> = <name>DEFAULT_A</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>b</name> = <name>DEFAULT_B</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> = <name>DEFAULT_C</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>protected</specifier> <name>T</name><index>[]</index></type> <name>grow</name><parameter_list>()</parameter_list><block>{
        <comment type="line">// It requires than a &gt; buffer.length/2</comment>
        <expr_stmt><expr><name>a</name> = <name>b</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>b</name> = <name>c</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> = <name>a</name>+<name>b</name></expr>;</expr_stmt>
        <return>return <expr>(<name><name>T</name><index>[]</index></name>)new <name><name>Object</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</return>        
    }</block></function><empty_stmt>;</empty_stmt>

    <function><type><specifier>protected</specifier> <name>T</name><index>[]</index></type> <name>shrink</name><parameter_list>()</parameter_list><block>{
        <comment type="line">// It maintains a &gt; buffer.length/2</comment>
        <if>if<condition>( <expr><name>a</name> &gt;= <name>DEFAULT_B</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>c</name> = <name>b</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>b</name> = <name>a</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>a</name> = <name>c</name>-<name>b</name></expr>;</expr_stmt>
        }</block></then></if>    
        <if>if<condition>(<expr><name><name>buffer</name>.<name>length</name></name>!=<name>c</name></expr>)</condition><then>
            <return>return <expr>(<name><name>T</name><index>[]</index></name>)new <name><name>Object</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</return></then>        
        <else>else
            <return>return <expr><name>buffer</name></expr>;</return></else></if>
    }</block></function><empty_stmt>;</empty_stmt>

    <comment type="javadoc">/**
     * Inserts a data element in the structure
     * @param data Data element to be inserted
     * @return &lt;i&gt;true&lt;/i&gt; if the element could be added, &lt;i&gt;false&lt;/i&gt; otherwise
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>add</name><parameter_list>(<param><decl><type><name>T</name></type> <name>data</name></decl></param>)</parameter_list><block>{
        <if>if<condition>( <expr><name><name>buffer</name>.<name>length</name></name> == <name>size</name></expr> )</condition><then><block>{
            <decl_stmt><decl><type><name>T</name><index>[]</index></type> <name>newData</name> =<init> <expr><call><name>grow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>( <argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>newData</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer</name> = <name>newData</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name></expr>]</index></name> = <name>data</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name>++</expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Inserts a data element in the structure
     * @param data Data element to be inserted
     * @return &lt;i&gt;true&lt;/i&gt; if the element could be added, &lt;i&gt;false&lt;/i&gt; otherwise
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>del</name><parameter_list>(<param><decl><type><name>T</name></type> <name>data</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>k</name> =<init> <expr><call><name>findIndex</name><argument_list>( <argument><expr><name>data</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>k</name> != -1</expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>leftShift</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>true</expr>;</return>
        }</block></then></if>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Removes the element indicated by the locator
     * @param locator The location information of the object to be deleted
     * @return &lt;i&gt;true&lt;/i&gt; if the element could be removed, &lt;i&gt;false&lt;/i&gt; otherwise
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>del</name><parameter_list>( <param><decl><type><name><name>Location</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>locator</name></decl></param> )</parameter_list><block>{
        <if>if<condition>( <expr><name>locator</name> <name>instanceof</name> <name>ArrayCollectionLocation</name></expr> )</condition><then><block>{
            <decl_stmt><decl><type><name><name>ArrayCollectionLocation</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>loc</name> =<init> <expr>((<name>ArrayCollectionLocation</name>)<name>locator</name>)</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>leftShift</name><argument_list>( <argument><expr><call><name><name>loc</name>.<name>getPos</name></name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>true</expr>;</return>
        }</block></then></if>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <function><type><specifier>protected</specifier> <name>void</name></type> <name>leftShift</name><parameter_list>( <param><decl><type><name>int</name></type> <name>index</name></decl></param> )</parameter_list> <throws>throws <argument><expr><name>IndexOutOfBoundsException</name></expr></argument></throws><block>{
        <expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
        <if>if<condition>( <expr><name>size</name> &lt; <name>a</name></expr> )</condition><then><block>{
            <decl_stmt><decl><type><name>T</name><index>[]</index></type> <name>newData</name> =<init> <expr><call><name>shrink</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>newData</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>index</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name>+1</expr></argument>, <argument><expr><name>newData</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>size</name>-<name>index</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer</name> = <name>newData</name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name>+1</expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>size</name>-<name>index</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>protected</specifier> <name>void</name></type> <name>rightShift</name><parameter_list>( <param><decl><type><name>int</name></type> <name>index</name></decl></param> )</parameter_list> <throws>throws <argument><expr><name>IndexOutOfBoundsException</name></expr></argument></throws><block>{
        <decl_stmt><decl><type><name>T</name><index>[]</index></type> <name>newData</name> =<init> <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name><name>buffer</name>.<name>length</name></name> == <name>size</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>newData</name> = <call><name>grow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>( <argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>newData</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>index</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>newData</name></expr></argument>, <argument><expr><name>index</name>+1</expr></argument>, <argument><expr><name>size</name>-<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>buffer</name></name> = <name>newData</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name>++</expr>;</expr_stmt>
    }</block></function>


    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>set</name><parameter_list>( <param><decl><type><name>int</name></type> <name>index</name></decl></param>, <param><decl><type><name>T</name></type> <name>data</name></decl></param> )</parameter_list> <throws>throws <argument><expr><name>IndexOutOfBoundsException</name></expr></argument></throws><block>{
        <if>if<condition>( <expr>0 &lt;= <name>index</name> &amp;&amp; <name>index</name> &lt; <name>size</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name><name>this</name>.<name>buffer</name><index>[<expr><name>index</name></expr>]</index></name> = <name>data</name></expr>;</expr_stmt>
            <return>return <expr>true</expr>;</return>
        }</block></then><else>else<block>{
            <throw>throw <expr>new <call><name>ArrayIndexOutOfBoundsException</name><argument_list>( <argument><expr><name>index</name></expr></argument> )</argument_list></call></expr>;</throw>
        }</block></else></if>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>add</name><parameter_list>( <param><decl><type><name>int</name></type> <name>index</name></decl></param>, <param><decl><type><name>T</name></type> <name>data</name></decl></param> )</parameter_list> <throws>throws <argument><expr><name>IndexOutOfBoundsException</name></expr></argument></throws><block>{
            <expr_stmt><expr><call><name>rightShift</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>buffer</name><index>[<expr><name>index</name></expr>]</index></name> = <name>data</name></expr>;</expr_stmt>
            <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>remove</name><parameter_list>( <param><decl><type><name>int</name></type> <name>index</name></decl></param> )</parameter_list> <throws>throws <argument><expr><name>IndexOutOfBoundsException</name></expr></argument></throws><block>{
            <expr_stmt><expr><call><name>leftShift</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>shuffle</name><parameter_list>()</parameter_list><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>m</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name>, <name>k</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>T</name></type> <name>temp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><call><name>size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>UniformIntegerGenerator</name></type> <name>g</name> =<init> <expr>new <call><name>UniformIntegerGenerator</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>indices</name> =<init> <expr><call><name><name>g</name>.<name>generate</name></name><argument_list>(<argument><expr>2 * <name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>j</name> = <name><name>indices</name><index>[<expr><name>m</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name> = <name><name>indices</name><index>[<expr><name>m</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>temp</name> = <name><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>buffer</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>k</name></expr>]</index></name> = <name>temp</name></expr>;</expr_stmt>
        }</block></for>
    }</block></function>
        
}</block></class>
</unit>
