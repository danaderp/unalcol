<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\Daavid\git\unalcol\redress2\test_data\code\optimizacion\src\unalcol\optimization\testbed\real\lsgo_benchmark\Kernel.java"><package>package <name><name>unalcol</name>.<name>optimization</name>.<name>testbed</name>.<name>real</name>.<name>lsgo_benchmark</name></name>;</package>
<comment type="block">/*
 * Copyright (c) 2009 Thomas Weise for NICAL
 * http://www.it-weise.de/
 * tweise@gmx.de
 *
 * GNU LESSER GENERAL PUBLIC LICENSE (Version 2.1, February 1999)
 */</comment>

<comment type="javadoc">/**
 * The internal mathematical kernel of the benchmark suite.
 * 
 * @author Thomas Weise
 */</comment>
<class><specifier>final</specifier> class <name>Kernel</name> <block>{

  <comment type="javadoc">/** two pi */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>TPI</name> =<init> <expr>(<name><name>Math</name>.<name>PI</name></name> + <name><name>Math</name>.<name>PI</name></name>)</expr></init></decl>;</decl_stmt>

  <comment type="javadoc">/**
   * Multiply a vector with a matrix.
   * 
   * @param vec
   *          the vector
   * @param mat
   *          the matrix
   * @param dest
   *          the destination vector
   */</comment>
  <function><type><specifier>final</specifier> <specifier>static</specifier> <name>void</name></type> <name>multiply</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>vec</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>mat</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>dest</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name>, <name>upper</name>, <name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>count</name> = <name><name>dest</name>.<name>length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>upper</name> = (<name>count</name> - 1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>max</name> = (<name>count</name> * <name>upper</name>)</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = <name>upper</name></expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>
      <for>for (<init><expr><name>k</name> = <name>upper</name></expr>, <expr><name>j</name> = <name>max</name> + <name>i</name></expr>;</init> <condition><expr><name>k</name> &gt;= 0</expr>;</condition> <incr><expr><name>k</name>--</expr>, <expr><name>j</name> -= <name>count</name></expr></incr>) <block>{
        <expr_stmt><expr><name>s</name> += (<name><name>mat</name><index>[<expr><name>j</name></expr>]</index></name> * <name><name>vec</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
      }</block></for>

      <expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> = <name>s</name></expr>;</expr_stmt>
    }</block></for>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted sphere function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedSphere</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name>, <name>z</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>count</name> - 1 + <name>start</name>)</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>j</name> &gt;= <name>start</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>j</name></expr>]</index></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> += (<name>z</name> * <name>z</name>)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted permutated sphere function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param P
   *          the permutation
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedPermSphere</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>P</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name>, <name>z</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>count</name> - 1 + <name>start</name>)</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>j</name> &gt;= <name>start</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>k</name> = <name><name>P</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> += (<name>z</name> * <name>z</name>)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s</name></expr>;</return>
  }</block></function>

  <comment type="line">// /**</comment>
  <comment type="line">// * Compute the shifted elliptic function</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param x</comment>
  <comment type="line">// * the input vector</comment>
  <comment type="line">// * @param o</comment>
  <comment type="line">// * the global optimum</comment>
  <comment type="line">// * @param start</comment>
  <comment type="line">// * the start index</comment>
  <comment type="line">// * @param count</comment>
  <comment type="line">// * the number of elements to consider in the computation</comment>
  <comment type="line">// * @return the result</comment>
  <comment type="line">// */</comment>
  <comment type="line">// static final double shiftedElliptic(final double[] x, final double[]</comment>
  <comment type="line">// o,</comment>
  <comment type="line">// final int start, final int count) {</comment>
  <comment type="line">// int i, j;</comment>
  <comment type="line">// final double pow;</comment>
  <comment type="line">// double s, z;</comment>
  <comment type="line">//</comment>
  <comment type="line">// s = 0d;</comment>
  <comment type="line">// i = (count - 1);</comment>
  <comment type="line">// j = (i + start);</comment>
  <comment type="line">// pow = (1d / i);</comment>
  <comment type="line">// for (; i &gt;= 0; i--, j--) {</comment>
  <comment type="line">// z = (x[j] - o[j]);</comment>
  <comment type="line">// s += (Math.pow(1e6, i * pow) * z * z);</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// return s;</comment>
  <comment type="line">// }</comment>

  <comment type="javadoc">/**
   * Create a lookup table for the pow function
   * 
   * @param count
   *          the counter
   * @return the table
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name><index>[]</index></type> <name>createPowLookup</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>double</name><index>[]</index></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>double</name></type> <name>pow</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>d</name> = new <name><name>double</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> = (<name>count</name> - 1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>pow</name> = (1d / <name>i</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> = 1e6d</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><index>[<expr>0</expr>]</index></name> = 1d</expr>;</expr_stmt>

    <for>for (<init><expr>--<name>i</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name><name>Math</name>.<name>pow</name></name><argument_list>(<argument><expr>1e6d</expr></argument>, <argument><expr><name>i</name> * <name>pow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>d</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted elliptic function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @param lookup
   *          the lookup table
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedElliptic</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>lookup</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
    <comment type="line">// final double pow;</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name>, <name>z</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> = (<name>count</name> - 1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>i</name> + <name>start</name>)</expr>;</expr_stmt>
    <comment type="line">// pow = (1d / i);</comment>
    <for>for (<init>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>j</name></expr>]</index></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> += (<comment type="block">/* Math.pow(1e6, i pow) */</comment><name><name>lookup</name><index>[<expr><name>i</name></expr>]</index></name> * <name>z</name> * <name>z</name>)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted permutated elliptic function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param P
   *          the permutation
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @param lookup
   *          the lookup table
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedPermElliptic</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>P</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>lookup</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <comment type="line">// final double pow;</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name>, <name>z</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> = (<name>count</name> - 1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>i</name> + <name>start</name>)</expr>;</expr_stmt>
    <comment type="line">// pow = (1d / i);</comment>
    <for>for (<init>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>k</name> = <name><name>P</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> += (<comment type="block">/* Math.pow(1e6, i pow) */</comment><name><name>lookup</name><index>[<expr><name>i</name></expr>]</index></name> * <name>z</name> * <name>z</name>)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted, permutated, and rotated elliptic function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param P
   *          the permutation
   * @param M
   *          the rotation matrix
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @param z
   *          a temporary array
   * @param lookup
   *          the lookup table
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedPermRotElliptic</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>P</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>M</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>z</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>lookup</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>upper</name>, <name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <comment type="line">// final double pow;</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>rz</name>, <name>s</name></decl>;</decl_stmt>

    <comment type="line">// compute z</comment>
    <expr_stmt><expr><name>i</name> = <name>upper</name> = (<name>count</name> - 1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>i</name> + <name>start</name>)</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>k</name> = <name><name>P</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> = (<name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
    }</block></for>

    <comment type="line">// rotate and compute function at the same time:</comment>
    <expr_stmt><expr><name>max</name> = (<name>count</name> * <name>upper</name>)</expr>;</expr_stmt>
    <comment type="line">// pow = (1d / upper);</comment>
    <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = <name>upper</name></expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{

      <comment type="line">// rotate</comment>
      <expr_stmt><expr><name>rz</name> = 0d</expr>;</expr_stmt>
      <for>for (<init><expr><name>k</name> = <name>upper</name></expr>, <expr><name>j</name> = <name>max</name> + <name>i</name></expr>;</init> <condition><expr><name>k</name> &gt;= 0</expr>;</condition> <incr><expr><name>k</name>--</expr>, <expr><name>j</name> -= <name>count</name></expr></incr>) <block>{
        <expr_stmt><expr><name>rz</name> += (<name><name>M</name><index>[<expr><name>j</name></expr>]</index></name> * <name><name>z</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
      }</block></for>

      <comment type="line">// compute function</comment>
      <expr_stmt><expr><name>s</name> += (<comment type="block">/* Math.pow(1e6, i pow) */</comment><name><name>lookup</name><index>[<expr><name>i</name></expr>]</index></name> * <name>rz</name> * <name>rz</name>)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted rastrigin's function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedRastrigin</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name>, <name>z</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>count</name> - 1 + <name>start</name>)</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>j</name> &gt;= <name>start</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>j</name></expr>]</index></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> += ((<name>z</name> * <name>z</name>) - (10d * <call><name><name>Math</name>.<name>cos</name></name><argument_list>(<argument><expr><name>TPI</name> * <name>z</name></expr></argument>)</argument_list></call>) + 10d)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted permutated rastrigin's function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param P
   *          the permutation
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedPermRastrigin</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>P</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name>, <name>z</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>count</name> - 1 + <name>start</name>)</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>j</name> &gt;= <name>start</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>k</name> = <name><name>P</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> += ((<name>z</name> * <name>z</name>) - (10d * <call><name><name>Math</name>.<name>cos</name></name><argument_list>(<argument><expr><name>TPI</name> * <name>z</name></expr></argument>)</argument_list></call>) + 10d)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted, permutated, and rotated rastrigin function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param P
   *          the permutation
   * @param M
   *          the rotation matrix
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @param z
   *          a temporary array
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedPermRotRastrigin</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>P</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>M</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>z</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>upper</name>, <name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>rz</name>, <name>s</name></decl>;</decl_stmt>

    <comment type="line">// compute z</comment>
    <expr_stmt><expr><name>i</name> = <name>upper</name> = (<name>count</name> - 1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>i</name> + <name>start</name>)</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>k</name> = <name><name>P</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> = (<name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
    }</block></for>

    <comment type="line">// rotate and compute function at the same time:</comment>
    <expr_stmt><expr><name>max</name> = (<name>count</name> * <name>upper</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = <name>upper</name></expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{

      <comment type="line">// rotate</comment>
      <expr_stmt><expr><name>rz</name> = 0d</expr>;</expr_stmt>
      <for>for (<init><expr><name>k</name> = <name>upper</name></expr>, <expr><name>j</name> = <name>max</name> + <name>i</name></expr>;</init> <condition><expr><name>k</name> &gt;= 0</expr>;</condition> <incr><expr><name>k</name>--</expr>, <expr><name>j</name> -= <name>count</name></expr></incr>) <block>{
        <expr_stmt><expr><name>rz</name> += (<name><name>M</name><index>[<expr><name>j</name></expr>]</index></name> * <name><name>z</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
      }</block></for>

      <comment type="line">// compute function</comment>
      <expr_stmt><expr><name>s</name> += ((<name>rz</name> * <name>rz</name>) - (10d * <call><name><name>Math</name>.<name>cos</name></name><argument_list>(<argument><expr><name>TPI</name> * <name>rz</name></expr></argument>)</argument_list></call>) + 10d)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted ackley's function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedAckley</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s1</name>, <name>s2</name>, <name>z</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s1</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>s2</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>count</name> - 1 + <name>start</name>)</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>j</name> &gt;= <name>start</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>j</name></expr>]</index></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s1</name> += (<name>z</name> * <name>z</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s2</name> += <call><name><name>Math</name>.<name>cos</name></name><argument_list>(<argument><expr><name>TPI</name> * <name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <return>return <comment type="block">/*
            * (-20d Math.exp(-0.2d Math.sqrt(s1 / count))) - // Math.exp(s2
            * / count) + 20d + Math.E;
            */</comment>
    <expr><call><name>protAckley</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * The protected ackley's function
   * 
   * @param s1
   *          the first sum
   * @param s2
   *          the second sum
   * @param count
   *          the counter
   * @return the result
   */</comment>
  <function><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>protAckley</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>double</name></type> <name>s1</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>double</name></type> <name>s2</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name>double</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>double</name></type> <name>e1</name>, <name>e2</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s1</name> == 0d</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>e1</name> = 1d</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>e1</name> = <call><name><name>Math</name>.<name>exp</name></name><argument_list>(<argument><expr>-0.2d * <call><name><name>Math</name>.<name>sqrt</name></name><argument_list>(<argument><expr><name>s1</name> / <name>count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>s2</name> == <name>count</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>e2</name> = <name><name>Math</name>.<name>E</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>e2</name> = <call><name><name>Math</name>.<name>exp</name></name><argument_list>(<argument><expr><name>s2</name> / <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr>((20d - (20d * <name>e1</name>)) + (<name><name>Math</name>.<name>E</name></name> - <name>e2</name>))</expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted permutated ackley's function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param P
   *          the permutation
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedPermAckley</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>P</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s1</name>, <name>s2</name>, <name>z</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s1</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>s2</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>count</name> - 1 + <name>start</name>)</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>j</name> &gt;= <name>start</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>k</name> = <name><name>P</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s1</name> += (<name>z</name> * <name>z</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s2</name> += <call><name><name>Math</name>.<name>cos</name></name><argument_list>(<argument><expr><name>TPI</name> * <name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <return>return <comment type="block">/*
            * (-20d Math.exp(-0.2d Math.sqrt(s1 / count))) - // Math.exp(s2
            * / count) + 20d + Math.E;
            */</comment>
    <expr><call><name>protAckley</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted, permutated, and rotated ackley's function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param P
   *          the permutation
   * @param M
   *          the rotation matrix
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @param z
   *          a temporary array
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedPermRotAckley</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>P</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>M</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>z</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>upper</name>, <name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>rz</name>, <name>s1</name>, <name>s2</name></decl>;</decl_stmt>

    <comment type="line">// compute z</comment>
    <expr_stmt><expr><name>i</name> = <name>upper</name> = (<name>count</name> - 1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>i</name> + <name>start</name>)</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>k</name> = <name><name>P</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> = (<name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
    }</block></for>

    <comment type="line">// rotate and compute function at the same time:</comment>
    <expr_stmt><expr><name>max</name> = (<name>count</name> * <name>upper</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>s1</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>s2</name> = 0d</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = <name>upper</name></expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{

      <comment type="line">// rotate</comment>
      <expr_stmt><expr><name>rz</name> = 0d</expr>;</expr_stmt>
      <for>for (<init><expr><name>k</name> = <name>upper</name></expr>, <expr><name>j</name> = <name>max</name> + <name>i</name></expr>;</init> <condition><expr><name>k</name> &gt;= 0</expr>;</condition> <incr><expr><name>k</name>--</expr>, <expr><name>j</name> -= <name>count</name></expr></incr>) <block>{
        <expr_stmt><expr><name>rz</name> += (<name><name>M</name><index>[<expr><name>j</name></expr>]</index></name> * <name><name>z</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
      }</block></for>

      <comment type="line">// compute function</comment>
      <expr_stmt><expr><name>s1</name> += (<name>rz</name> * <name>rz</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s2</name> += <call><name><name>Math</name>.<name>cos</name></name><argument_list>(<argument><expr><name>TPI</name> * <name>rz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <return>return <comment type="block">/*
            * (-20d Math.exp(-0.2d Math.sqrt(s1 / count))) - // Math.exp(s2
            * / count) + 20d + Math.E;
            */</comment>
    <expr><call><name>protAckley</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted version of schwefel's problem 1.2
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedSchwefel12</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s1</name>, <name>s2</name>, <name>z</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s1</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>s2</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = (<name>start</name> + <name>count</name>)</expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = <name>start</name></expr>;</init> <condition><expr><name>j</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>j</name></expr>]</index></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s1</name> += <name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>s2</name> += (<name>s1</name> * <name>s1</name>)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s2</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted permutated schwefel's problem 1.2
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param P
   *          the permutation
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedPermSchwefel12</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>P</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s1</name>, <name>s2</name>, <name>z</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s1</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>s2</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = (<name>start</name> + <name>count</name>)</expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = <name>start</name></expr>;</init> <condition><expr><name>j</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name>k</name> = <name><name>P</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s1</name> += <name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>s2</name> += (<name>s1</name> * <name>s1</name>)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s2</name></expr>;</return>
  }</block></function>

  <comment type="line">// upsi, schwefel's problem 1.2 is already nonseparable, so we do not</comment>
  <comment type="line">// need to rotate it :-D</comment>
  <comment type="line">//</comment>
  <comment type="line">// /**</comment>
  <comment type="line">// * Compute the shifted, permutated, and rotated schwefel's problem 1.2</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param x</comment>
  <comment type="line">// * the input vector</comment>
  <comment type="line">// * @param o</comment>
  <comment type="line">// * the global optimum</comment>
  <comment type="line">// * @param P</comment>
  <comment type="line">// * the permutation</comment>
  <comment type="line">// * @param M</comment>
  <comment type="line">// * the rotation matrix</comment>
  <comment type="line">// * @param start</comment>
  <comment type="line">// * the start index</comment>
  <comment type="line">// * @param count</comment>
  <comment type="line">// * the number of elements to consider in the computation</comment>
  <comment type="line">// * @param z</comment>
  <comment type="line">// * a temporary array</comment>
  <comment type="line">// * @return the result</comment>
  <comment type="line">// */</comment>
  <comment type="line">// static final double shiftedPermRotSchwefel12(final double[] x,</comment>
  <comment type="line">// final double[] o, final int[] P, final double[] M, final int start,</comment>
  <comment type="line">// final int count, final double[] z) {</comment>
  <comment type="line">// final int upper, max;</comment>
  <comment type="line">// int i, j, k;</comment>
  <comment type="line">// double rz, s1, s2;</comment>
  <comment type="line">//</comment>
  <comment type="line">// // compute z</comment>
  <comment type="line">// i = upper = (count - 1);</comment>
  <comment type="line">// j = (i + start);</comment>
  <comment type="line">// for (; i &gt;= 0; i--, j--) {</comment>
  <comment type="line">// k = P[j];</comment>
  <comment type="line">// z[i] = (x[k] - o[k]);</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// // rotate and compute function at the same time:</comment>
  <comment type="line">// max = (count * upper);</comment>
  <comment type="line">// s1 = 0d;</comment>
  <comment type="line">// s2 = 0d;</comment>
  <comment type="line">// for (i = 0; i &lt; count; i++) {</comment>
  <comment type="line">//</comment>
  <comment type="line">// // rotate</comment>
  <comment type="line">// rz = 0d;</comment>
  <comment type="line">// for (k = upper, j = max + i; k &gt;= 0; k--, j -= count) {</comment>
  <comment type="line">// rz += (M[j] * z[k]);</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// // compute function</comment>
  <comment type="line">// s1 += rz;</comment>
  <comment type="line">// s2 += (s1 * s1);</comment>
  <comment type="line">// }</comment>
  <comment type="line">//</comment>
  <comment type="line">// return s2;</comment>
  <comment type="line">// }</comment>

  <comment type="javadoc">/**
   * Compute the shifted version of rosenbrock's function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedRosenbrock</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name>, <name>z</name>, <name>oz</name>, <name>t</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>j</name> = (<name>count</name> + <name>start</name> - 1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>j</name></expr>]</index></name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>

    <for>for (<init><expr>--<name>j</name></expr>;</init> <condition><expr><name>j</name> &gt;= <name>start</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>oz</name> = <name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>j</name></expr>]</index></name>)</expr>;</expr_stmt>

      <expr_stmt><expr><name>t</name> = ((<name>z</name> * <name>z</name>) - <name>oz</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> += (100d * <name>t</name> * <name>t</name>)</expr>;</expr_stmt>

      <expr_stmt><expr><name>t</name> = (<name>z</name> - 1d)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> += (<name>t</name> * <name>t</name>)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s</name></expr>;</return>
  }</block></function>

  <comment type="javadoc">/**
   * Compute the shifted permutated rosenbrock's function
   * 
   * @param x
   *          the input vector
   * @param o
   *          the global optimum
   * @param P
   *          the permutation
   * @param start
   *          the start index
   * @param count
   *          the number of elements to consider in the computation
   * @return the result
   */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>double</name></type> <name>shiftedPermRosenbrock</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>x</name></decl></param>,
      <param><decl><type><specifier>final</specifier> <name><name>double</name><index>[]</index></name></type> <name>o</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>P</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>start</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>s</name>, <name>z</name>, <name>oz</name>, <name>t</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = 0d</expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>count</name> + <name>start</name> - 1)</expr>;</expr_stmt>

    <expr_stmt><expr><name>k</name> = <name><name>P</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>

    <for>for (<init><expr>--<name>j</name></expr>;</init> <condition><expr><name>j</name> &gt;= <name>start</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>oz</name> = <name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>k</name> = <name><name>P</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> = (<name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> - <name><name>o</name><index>[<expr><name>k</name></expr>]</index></name>)</expr>;</expr_stmt>

      <expr_stmt><expr><name>t</name> = ((<name>z</name> * <name>z</name>) - <name>oz</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> += (100d * <name>t</name> * <name>t</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>t</name> = (<name>z</name> - 1d)</expr>;</expr_stmt>
      <expr_stmt><expr><name>s</name> += (<name>t</name> * <name>t</name>)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>s</name></expr>;</return>
  }</block></function>

  <comment type="line">// /**</comment>
  <comment type="line">// * Compute the bth power of a</comment>
  <comment type="line">// *</comment>
  <comment type="line">// * @param a</comment>
  <comment type="line">// * the base</comment>
  <comment type="line">// * @param b</comment>
  <comment type="line">// * the exponent</comment>
  <comment type="line">// * @return a^b</comment>
  <comment type="line">// */</comment>
  <comment type="line">// private static final double pow(final double a, final double b) {</comment>
  <comment type="line">// return StrictMath.exp(b * StrictMath.log(a));</comment>
  <comment type="line">// }</comment>

  <comment type="javadoc">/**
   * The test function used to check whether the routines here have been
   * implemented correctly.
   * 
   * @param params
   *          the parameters
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>void</name></type> <name>main</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>params</name></decl></param>)</parameter_list> <block>{
    <comment type="line">// double[] x, m, o, z;</comment>
    <comment type="line">// int[] p;</comment>
    <comment type="line">//</comment>
    <comment type="line">// x = new double[] { 1d, 2d, 3d };</comment>
    <comment type="line">// m = new double[] { 3, -4, 1, 5, 3, -7, -9, 2, 6 };</comment>
    <comment type="line">// o = new double[] { 7d, 5d, 2d };</comment>
    <comment type="line">// p = new int[] { 0, 1, 2 };</comment>
    <comment type="line">// z = new double[3];</comment>
    <comment type="line">//</comment>
    <comment type="line">// System.out.println(shiftedPermRotElliptic(x, o, p, m, 0, 3, z));</comment>

    <decl_stmt><decl><type><name>long</name></type> <name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="line">// t = -System.nanoTime();</comment>
    <comment type="line">// for(i=10000;i&gt;=0;i--){</comment>
    <comment type="line">// pow(2,3);</comment>
    <comment type="line">// }</comment>
    <comment type="line">// System.out.println(System.nanoTime()-t);</comment>

    <expr_stmt><expr><name>t</name> = -<call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 10000</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
      <expr_stmt><expr><call><name><name>Math</name>.<name>pow</name></name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call> - <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

}</block></class>
</unit>
