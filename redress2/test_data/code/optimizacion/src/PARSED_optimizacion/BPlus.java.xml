<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\Daavid\git\unalcol\redress2\test_data\code\optimizacion\src\unalcol\types\collection\tree\bplus\BPlus.java"><comment type="block">/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */</comment>

<package>package <name><name>unalcol</name>.<name>types</name>.<name>collection</name>.<name>tree</name>.<name>bplus</name></name>;</package>
<import>import <name><name>unalcol</name>.<name>types</name>.<name>collection</name></name>.*;</import>
<import>import <name><name>unalcol</name>.<name>sort</name></name>.*;</import>
<import>import <name><name>unalcol</name>.<name>types</name>.<name>collection</name>.<name>tree</name>.<name>bplus</name>.<name>memory</name></name>.*;</import>
<import>import <name><name>unalcol</name>.<name>types</name>.<name>integer</name></name>.*;</import>
<import>import <name><name>unalcol</name>.<name>random</name>.<name>integer</name>.<name>UniformIntegerGenerator</name></name>;</import>

<comment type="javadoc">/**
 *
 * @author jgomez
 */</comment>
<class><specifier>public</specifier> class <name><name>BPlus</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name> <super><extends>extends <name><name>ImmutableBPlus</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends> <implements>implements <name><name>MutableCollection</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></implements></super> <block>{
    <constructor><specifier>public</specifier> <name>BPlus</name><parameter_list>( <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name><name>Order</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>order</name></decl></param>,
                  <param><decl><type><name><name>BPlusInnerNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>root</name></decl></param>, <param><decl><type><name><name>BPlusLeafNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>leaf</name></decl></param> )</parameter_list><block>{
        <expr_stmt><expr><call><name>super</name><argument_list>( <argument><expr><name>order</name></expr></argument>, <argument><expr>(<name><name>BPlusInnerNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name>)<call><name><name>root</name>.<name>newInstance</name></name><argument_list>(<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name>.<name>root</name>.<name>insert</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>leaf</name>.<name>newInstance</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>BPlus</name><parameter_list>( <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name><name>Order</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>order</name></decl></param> )</parameter_list><block>{
        <expr_stmt><expr><call><name>this</name><argument_list>( <argument><expr><name>n</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr>new <call><name><name>Search</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>BPlus</name><parameter_list>( <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name><name>Order</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>order</name></decl></param>, <param><decl><type><name><name>Search</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>search</name></decl></param> )</parameter_list><block>{
        <expr_stmt><expr><call><name>this</name><argument_list>( <argument><expr><name>n</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, 
              <argument><expr>new <call><name><name>MemoryInnerNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name><name>MemoryLeafNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>
    
    <function><type><specifier>public</specifier> <name>void</name></type> <name>balance</name><parameter_list>( <param><decl><type><name><name>BPlusInnerNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>node</name></decl></param>, <param><decl><type><name>int</name></type> <name>k</name></decl></param> )</parameter_list><block>{
        <decl_stmt><decl><type><name><name>BPlusNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>theNode</name> =<init> <expr><call><name><name>node</name>.<name>next</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>(<expr><call><name><name>theNode</name>.<name>underFill</name></name><argument_list>()</argument_list></call></expr>)</condition><then><block>{
            <if>if<condition>( <expr><name>k</name>&lt;<call><name><name>node</name>.<name>n</name></name><argument_list>()</argument_list></call>-1</expr> )</condition><then><block>{
                <if>if<condition>( <expr><call><name><name>theNode</name>.<name>n</name></name><argument_list>()</argument_list></call> + <call><name><name>node</name>.<name>next</name></name><argument_list>(<argument><expr><name>k</name>+1</expr></argument>)</argument_list></call>.<call><name>n</name><argument_list>()</argument_list></call> &lt;= 2*<call><name><name>theNode</name>.<name>underFillSize</name></name><argument_list>()</argument_list></call></expr> )</condition><then><block>{
                    <comment type="line">// merge next(k) with next(k+1) and remove node next(k+1)</comment>
                    <expr_stmt><expr><call><name><name>theNode</name>.<name>merge</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>node</name>.<name>remove</name></name><argument_list>(<argument><expr><name>k</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then><else>else<block>{
                    <comment type="line">// move left key of next(k+1) to next(k)</comment>
                    <expr_stmt><expr><call><name><name>node</name>.<name>next</name></name><argument_list>(<argument><expr><name>k</name>+1</expr></argument>)</argument_list></call>.<call><name>leftShift</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then><else>else<block>{
                <if>if<condition>( <expr><call><name><name>node</name>.<name>n</name></name><argument_list>()</argument_list></call>&gt;1</expr> )</condition><then><block>{
                    <if>if<condition>(<expr><call><name><name>theNode</name>.<name>n</name></name><argument_list>()</argument_list></call> + <call><name><name>node</name>.<name>next</name></name><argument_list>(<argument><expr><name>k</name>-1</expr></argument>)</argument_list></call>.<call><name>n</name><argument_list>()</argument_list></call> &lt;= 2*<call><name><name>theNode</name>.<name>underFillSize</name></name><argument_list>()</argument_list></call></expr> )</condition><then><block>{
                        <comment type="line">// merge next(k-1) with next(k) and remove node next(k)</comment>
                        <expr_stmt><expr><call><name><name>node</name>.<name>next</name></name><argument_list>(<argument><expr><name>k</name>-1</expr></argument>)</argument_list></call>.<call><name>merge</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>node</name>.<name>remove</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then><else>else<block>{
                        <comment type="line">// move right key of next(k-1) to next(k)</comment>
                        <expr_stmt><expr><call><name><name>node</name>.<name>next</name></name><argument_list>(<argument><expr><name>k</name>-1</expr></argument>)</argument_list></call>.<call><name>rightShift</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then></if>
            }</block></else></if>
        }</block></then><else>else<block>{
            <if>if<condition>( <expr><call><name><name>theNode</name>.<name>isFull</name></name><argument_list>()</argument_list></call></expr> )</condition><then><block>{
                <expr_stmt><expr><call><name><name>theNode</name>.<name>split</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>node</name>.<name>insert</name></name><argument_list>(<argument><expr><name>k</name>+1</expr></argument>, <argument><expr><call><name><name>theNode</name>.<name>right</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></function>
    
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>del</name><parameter_list>( <param><decl><type><name><name>BPlusNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>node</name></decl></param>, <param><decl><type><name>T</name></type> <name>data</name></decl></param> )</parameter_list><block>{
        <if>if<condition>( <expr><name>node</name>==<name>null</name></expr>)</condition><then> <return>return <expr>false</expr>;</return></then></if>
        <if>if<condition>( <expr><name>node</name> <name>instanceof</name> <name>BPlusInnerNode</name></expr>)</condition><then><block>{
            <decl_stmt><decl><type><name><name>BPlusInnerNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>inode</name> =<init> <expr>(<name><name>BPlusInnerNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name>)<name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>BPlusNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>theNode</name></decl>;</decl_stmt>
            <if>if<condition>(<expr><call><name><name>inode</name>.<name>n</name></name><argument_list>()</argument_list></call>&gt;1</expr>)</condition><then><block>{
                <decl_stmt><decl><type><name>int</name></type> <name>k</name> =<init> <expr><call><name>search</name><argument_list>(<argument><expr><call><name><name>inode</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name><name>node</name>.<name>n</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>-1</expr></init></decl>;</decl_stmt>
                <if>if<condition>( <expr><name>k</name>&lt;0</expr> )</condition><then> <return>return <expr>false</expr>;</return></then></if>
                <expr_stmt><expr><name>theNode</name> = <call><name><name>inode</name>.<name>next</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if<condition>( <expr><call><name>del</name><argument_list>(<argument><expr><name>theNode</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
                    <expr_stmt><expr><call><name>balance</name><argument_list>(<argument><expr><name>inode</name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr>true</expr>;</return>
                }</block></then><else>else<block>{ <return>return <expr>false</expr>;</return> }</block></else></if>
            }</block></then><else>else
                <expr_stmt><expr><name>theNode</name> = <call><name><name>inode</name>.<name>next</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                <if>if<condition>( <expr><call><name>del</name><argument_list>(<argument><expr><name>theNode</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
                    <expr_stmt><expr><call><name>balance</name><argument_list>(<argument><expr><name>inode</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr>true</expr>;</return>
                }</block></then><else>else<block>{ <return>return <expr>false</expr>;</return> }</block></else></if>
        }</block></then><else>else<block>{
            <decl_stmt><decl><type><name><name>BPlusLeafNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>lnode</name> =<init> <expr>(<name><name>BPlusLeafNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name>)<name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>k</name> =<init> <expr><call><name>search</name><argument_list>(<argument><expr><call><name><name>lnode</name>.<name>keys</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name><name>node</name>.<name>n</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>-1</expr></init></decl>;</decl_stmt>
            <if>if<condition>( <expr><name>k</name>&lt;0</expr> )</condition><then> <return>return <expr>false</expr>;</return></then></if>
            <if>if<condition>( <expr><call><name><name>order</name>.<name>compare</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name><name>lnode</name>.<name>key</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr> )</condition><then><block>{
                <return>return <expr><call><name><name>lnode</name>.<name>remove</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then><else>else
                <return>return <expr>false</expr>;</return></else></if>
        }</block></else></if>
    }</block></function>
    
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>del</name><parameter_list>( <param><decl><type><name>T</name></type> <name>key</name></decl></param> )</parameter_list><block>{
        <return>return <expr><call><name>del</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>add</name><parameter_list>( <param><decl><type><name><name>BPlusNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>node</name></decl></param>, <param><decl><type><name>T</name></type> <name>data</name></decl></param> )</parameter_list><block>{
        <if>if<condition>( <expr><name>node</name> <name>instanceof</name> <name>BPlusInnerNode</name></expr>)</condition><then><block>{
            <decl_stmt><decl><type><name><name>BPlusInnerNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>inode</name> =<init> <expr>(<name><name>BPlusInnerNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name>)<name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>BPlusNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>theNode</name></decl>;</decl_stmt>
            <if>if<condition>(<expr><call><name><name>inode</name>.<name>n</name></name><argument_list>()</argument_list></call>&gt;1</expr>)</condition><then><block>{
                <decl_stmt><decl><type><name>int</name></type> <name>k</name> =<init> <expr><call><name>search</name><argument_list>(<argument><expr><call><name><name>inode</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name><name>node</name>.<name>n</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>-1</expr></init></decl>;</decl_stmt>
                <if>if<condition>( <expr><name>k</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>k</name>=0</expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>theNode</name> = <call><name><name>inode</name>.<name>next</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if<condition>( <expr><call><name>add</name><argument_list>(<argument><expr><name>theNode</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
                    <expr_stmt><expr><call><name>balance</name><argument_list>(<argument><expr><name>inode</name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr>true</expr>;</return>
                }</block></then><else>else<block>{ <return>return <expr>false</expr>;</return> }</block></else></if>
            }</block></then><else>else
                <expr_stmt><expr><name>theNode</name> = <call><name><name>inode</name>.<name>next</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                <if>if<condition>( <expr><call><name>add</name><argument_list>(<argument><expr><name>theNode</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
                    <expr_stmt><expr><call><name>balance</name><argument_list>(<argument><expr><name>inode</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr>true</expr>;</return>
                }</block></then><else>else<block>{ <return>return <expr>false</expr>;</return> }</block></else></if>
        }</block></then><else>else<block>{
            <decl_stmt><decl><type><name><name>BPlusLeafNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>lnode</name> =<init> <expr>(<name><name>BPlusLeafNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name>)<name>node</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>(<argument><expr><name>lnode</name>!=<name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>k</name> =<init> <expr><call><name>search</name><argument_list>(<argument><expr><call><name><name>lnode</name>.<name>keys</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name><name>node</name>.<name>n</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if<condition>( <expr><name>k</name>&lt;0</expr> )</condition><then> <return>return <expr>false</expr>;</return></then></if>
            <if>if<condition>( <expr><name>k</name>&gt;0 &amp;&amp; <call><name><name>order</name>.<name>compare</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name><name>lnode</name>.<name>key</name></name><argument_list>(<argument><expr><name>k</name>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr> )</condition><then><block>{
                <return>return <expr>false</expr>;</return>
            }</block></then><else>else<block>{
                <return>return <expr><call><name><name>lnode</name>.<name>insert</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>    
        }</block></else></if>
    }</block></function>
    
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>add</name><parameter_list>( <param><decl><type><name>T</name></type> <name>key</name></decl></param> )</parameter_list><block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>flag</name> =<init> <expr><call><name>add</name><argument_list>(<argument><expr><name>root</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>(<expr><name>flag</name> &amp;&amp; <call><name><name>root</name>.<name>isFull</name></name><argument_list>()</argument_list></call></expr>)</condition><then><block>{
            <decl_stmt><decl><type><name><name>BPlusInnerNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>newRoot</name> =<init> <expr>(<name><name>BPlusInnerNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name>)<call><name><name>root</name>.<name>newInstance</name></name><argument_list>(<argument><expr><call><name><name>root</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>root</name>.<name>split</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>            
            <decl_stmt><decl><type><name><name>BPlusNode</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>rroot</name> =<init> <expr><call><name><name>root</name>.<name>right</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 
            <expr_stmt><expr><call><name><name>newRoot</name>.<name>append</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>newRoot</name>.<name>append</name></name><argument_list>(<argument><expr><name>rroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>root</name> = <name>newRoot</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>flag</name></expr>;</return>
    }</block></function>


    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>del</name><parameter_list>(<param><decl><type><name><name>Location</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>locator</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>false</expr>;</return> 
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>paint</name><parameter_list>(<param><decl><type><name><name>BPlus</name><argument_list>&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>tree</name></decl></param>)</parameter_list><block>{
        <for>for(<init><decl><type><name>Integer</name></type> <name>j</name> :<range> <expr><name>tree</name></expr></range></decl></init>)<block>{
            <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr><name>j</name> + "#"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>
    
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>main</name><parameter_list>( <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>args</name></decl></param> )</parameter_list><block>{
        <decl_stmt><decl><type><name>UniformIntegerGenerator</name></type> <name>g</name> =<init> <expr>new <call><name>UniformIntegerGenerator</name><argument_list>(<argument><expr>100</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>numbers</name> =<init> <expr><call><name><name>g</name>.<name>generate</name></name><argument_list>(<argument><expr>200</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>BPlus</name><argument_list>&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>tree</name> =<init> <expr>new <call><name><name>BPlus</name><argument_list>&lt;&gt;</argument_list></name><argument_list>(<argument><expr>4</expr></argument>, <argument><expr>new <call><name>IntegerOrder</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for( <init><decl><type><name>int</name></type> <name>i</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>i</name>&lt;<name><name>numbers</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr> )<block>{
<comment type="line">//            System.out.println( "root" );</comment>
<comment type="line">//            tree.root.print( 0, true );</comment>
            <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>( <argument><expr><name>i</name> + " trying .... " + <name><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><call><name><name>tree</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
                <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>( <argument><expr>"Done " + <name><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="line">//                tree.print();</comment>
                <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"***************"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then><else>else<block>{
                <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>( <argument><expr>"Already there... " + <name><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><call><name>paint</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        
        
        <for>for( <init><decl><type><name>int</name></type> <name>i</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>i</name>&lt;30</expr>;</condition> <incr><expr><name>i</name>++</expr></incr> )<block>{
            <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>( <argument><expr><name>i</name> + " removing.... " + <name><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><call><name><name>tree</name>.<name>del</name></name><argument_list>(<argument><expr><name><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
                <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>( <argument><expr>"Done " + <name><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="line">//                tree.print();</comment>
                <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"***************"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then><else>else<block>{
                <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>( <argument><expr>"Is not there... " + <name><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <for>for(<init><decl><type><name>Integer</name></type> <name>j</name> :<range> <expr><name>tree</name></expr></range></decl></init>)<block>{
            <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr><name>j</name> + "#"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>
}</block></class>
</unit>
