<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\Daavid\git\unalcol\redress2\test_data\code\optimizacion\src\unalcol\random\rngpack\RanMT.java"><package>package <name><name>unalcol</name>.<name>random</name>.<name>rngpack</name></name>;</package>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>

<import>import <name><name>unalcol</name>.<name>random</name>.<name>raw</name></name>.*;</import>

<comment type="line">//</comment>
<comment type="line">// RngPack 1.1a by Paul Houle</comment>
<comment type="line">// http://www.honeylocust.com/RngPack/</comment>
<comment type="line">//</comment>
<comment type="javadoc">/**
 *
 * &lt;A HREF="http://www.math.keio.ac.jp/matumoto/emt.htm"&gt;Mersenne Twister&lt;/A&gt; --
 * advanced psuedorandom generator with a period of 2&lt;SUP&gt;19937&lt;/SUP&gt;-1
 * &lt;P&gt;
 *
 * &lt;P&gt;
 * &lt;A HREF="/RngPack/src/edu/cornell/lassp/houle/RngPack/RanMT.java"&gt;
 * Source code &lt;/A&gt; is available.
 * &lt;P&gt;
 * This class is derived from Sean Luke's
 * &lt;A HREF="http://www.cs.umd.edu/users/seanl/gp/"&gt;implementation&lt;/A&gt;
 *
 *
 *
 *
 * &lt;h3&gt;License&lt;/h3&gt;
 *
 * Copyright (c) 2003 by Paul Houle. &lt;br&gt;
 * Derived from a work copyright (c) 2003 by Sean Luke. &lt;br&gt;
 * Portions copyright (c) 1993 by Michael Lecuyer. &lt;br&gt;
 * All rights reserved. &lt;br&gt;
 *
 * &lt;p&gt;Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * &lt;ul&gt;
 * &lt;li&gt; Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * &lt;li&gt; Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * &lt;li&gt; Neither the name of the copyright owners, their employers, nor the
 * names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * &lt;/ul&gt;
 * &lt;p&gt;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNERS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 *
 * This code is a unified (modified) version of the RanMT
 * &lt;A HREF="/RngPack/src/edu/cornell/lassp/houle/RngPack/Ranmar.java"&gt; source code&lt;/A&gt;
 * from RngPack 1.1a by Paul Houle
 *
 * @author &lt;A HREF="http://www.honeylocust.com/"&gt; Paul Houle &lt;/A&gt;
 * (E-mail: &lt;A HREF="mailto:paul@honeylocust.com"&gt;paul@honeylocust.com&lt;/A&gt;)
 * Modified by &lt;A HREF="http://dis.unal.edu.co/~jgomez"&gt; Jonatan Gomez &lt;/A&gt;
 * (E-mail: &lt;A HREF="mailto:jgomezpe@unal.edu.co"&gt;jgomezpe@unal.edu.co&lt;/A&gt; )
 * @version 1.0
 */</comment>


<class><specifier>public</specifier> class <name>RanMT</name> <super><extends>extends <name>SeedableGenerator</name></extends></super><block>{

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>N</name> =<init> <expr>624</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>M</name> =<init> <expr>397</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MATRIX_A</name> =<init> <expr>0x9908b0df</expr></init></decl>;</decl_stmt>   <comment type="line">//    private static final * constant vector a</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>UPPER_MASK</name> =<init> <expr>0x80000000</expr></init></decl>;</decl_stmt> <comment type="line">// most significant w-r bits</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>LOWER_MASK</name> =<init> <expr>0x7fffffff</expr></init></decl>;</decl_stmt> <comment type="line">// least significant r bits</comment>


    <comment type="line">// Tempering parameters</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>TEMPERING_MASK_B</name> =<init> <expr>0x9d2c5680</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>TEMPERING_MASK_C</name> =<init> <expr>0xefc60000</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name><name>mt</name><index>[]</index></name></decl>;</decl_stmt> <comment type="line">// the array for the state vector</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>mti</name></decl>;</decl_stmt> <comment type="line">// mti==N+1 means mt[N] is not initialized</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name><name>mag01</name><index>[]</index></name></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>RanMT</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>this</name>.<name>initSeed</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call>%10000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">//this.initSeed(4357);</comment>
    }</block></constructor>

    <comment type="block">/*
     *
     * Note that this uses only the LSB 32 bits from the long
     *
     */</comment>

    <constructor><specifier>public</specifier> <name>RanMT</name><parameter_list>(<param><decl><type><name>long</name></type> <name>seed</name></decl></param>)</parameter_list> <block>{
	<expr_stmt><expr><call><name><name>this</name>.<name>initSeed</name></name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>RanMT</name><parameter_list>(<param><decl><type><name>Date</name></type> <name>d</name></decl></param>)</parameter_list> <block>{
	<expr_stmt><expr><call><name><name>this</name>.<name>initSeed</name></name><argument_list>(<argument><expr><call><name><name>d</name>.<name>getTime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     *
     * If a 32 bit seed isn't enough for you,  you can pass an array of
     * 624 integers.  Any array of integers is fine so long as they
     * aren't all zero.
     *
     */</comment>

    <constructor><specifier>public</specifier> <name>RanMT</name><parameter_list>(<param><decl><type><name>int</name></type> <name><name>array</name><index>[]</index></name></decl></param>)</parameter_list> <block>{
	<expr_stmt><expr><call><name><name>this</name>.<name>setSeed</name></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>initSeed</name><parameter_list>(<param><decl><type><name>long</name></type> <name>_seed</name></decl></param>)</parameter_list><block>{
        <expr_stmt><expr><name>seed</name> = <name>_seed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mt</name> = new <name><name>int</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>mag01</name> = new <name><name>int</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mag01</name><index>[<expr>0</expr>]</index></name> = 0x0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mag01</name><index>[<expr>1</expr>]</index></name> = <name>MATRIX_A</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mt</name><index>[<expr>0</expr>]</index></name>= <call>(<name>int</name>)<argument_list>(<argument><expr><name>seed</name> &amp; 0xfffffff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>mti</name>=1</expr>;</init> <condition><expr><name>mti</name>&lt;<name>N</name></expr>;</condition> <incr><expr><name>mti</name>++</expr></incr>)
            <block>{
		<expr_stmt><expr><name><name>mt</name><index>[<expr><name>mti</name></expr>]</index></name> =
		    (1812433253 * (<name><name>mt</name><index>[<expr><name>mti</name>-1</expr>]</index></name> ^ (<name><name>mt</name><index>[<expr><name>mti</name>-1</expr>]</index></name> &gt;&gt;&gt; 30)) + <name>mti</name>)</expr>;</expr_stmt>
		<comment type="block">/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */</comment>
		<comment type="block">/* In the previous versions, MSBs of the seed affect   */</comment>
		<comment type="block">/* only MSBs of the array mt[].                        */</comment>
		<comment type="block">/* 2002/01/09 modified by Makoto Matsumoto             */</comment>
		<expr_stmt><expr><name><name>mt</name><index>[<expr><name>mti</name></expr>]</index></name> &amp;= 0xffffffff</expr>;</expr_stmt>
		<comment type="block">/* for &gt;32 bit machines */</comment>
            }</block></for>
        <return>return <expr><name>seed</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * An alternative, more complete, method of seeding the
     * pseudo random number generator.  array must be an
     * array of 624 ints, and they can be any value as long as
     * they're not *all* zero.
     */</comment>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>setSeed</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>array</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>initSeed</name><argument_list>(<argument><expr>19650218</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name>=1</expr>;</expr_stmt> <expr_stmt><expr><name>j</name>=0</expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> = (<name>N</name>&gt;<name><name>array</name>.<name>length</name></name> ? <name>N</name> : <name><name>array</name>.<name>length</name></name>)</expr>;</expr_stmt>
        <for>for (<init>;</init> <condition><expr><name>k</name>!=0</expr>;</condition> <incr><expr><name>k</name>--</expr></incr>) <block>{
            <expr_stmt><expr><name><name>mt</name><index>[<expr><name>i</name></expr>]</index></name> = (<name><name>mt</name><index>[<expr><name>i</name></expr>]</index></name> ^ ((<name><name>mt</name><index>[<expr><name>i</name>-1</expr>]</index></name> ^ (<name><name>mt</name><index>[<expr><name>i</name>-1</expr>]</index></name> &gt;&gt;&gt; 30)) * 1664525)) + <name><name>array</name><index>[<expr><name>j</name></expr>]</index></name> + <name>j</name></expr>;</expr_stmt> <comment type="block">/* non linear */</comment>
            <expr_stmt><expr><name><name>mt</name><index>[<expr><name>i</name></expr>]</index></name> &amp;= 0xffffffff</expr>;</expr_stmt> <comment type="block">/* for WORDSIZE &gt; 32 machines */</comment>
            <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>i</name>&gt;=<name>N</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name><name>mt</name><index>[<expr>0</expr>]</index></name> = <name><name>mt</name><index>[<expr><name>N</name>-1</expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>i</name>=1</expr>;</expr_stmt> }</block></then></if>
            <if>if <condition>(<expr><name>j</name>&gt;=<name><name>array</name>.<name>length</name></name></expr>)</condition><then> <expr_stmt><expr><name>j</name>=0</expr>;</expr_stmt></then></if>
	}</block></for>
        <for>for (<init><expr><name>k</name>=<name>N</name>-1</expr>;</init> <condition><expr><name>k</name>!=0</expr>;</condition> <incr><expr><name>k</name>--</expr></incr>) <block>{
            <expr_stmt><expr><name><name>mt</name><index>[<expr><name>i</name></expr>]</index></name> = (<name><name>mt</name><index>[<expr><name>i</name></expr>]</index></name> ^ ((<name><name>mt</name><index>[<expr><name>i</name>-1</expr>]</index></name> ^ (<name><name>mt</name><index>[<expr><name>i</name>-1</expr>]</index></name> &gt;&gt;&gt; 30)) * 1566083941)) - <name>i</name></expr>;</expr_stmt> <comment type="block">/* non linear */</comment>
            <expr_stmt><expr><name><name>mt</name><index>[<expr><name>i</name></expr>]</index></name> &amp;= 0xffffffff</expr>;</expr_stmt> <comment type="block">/* for WORDSIZE &gt; 32 machines */</comment>
            <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>i</name>&gt;=<name>N</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>mt</name><index>[<expr>0</expr>]</index></name> = <name><name>mt</name><index>[<expr><name>N</name>-1</expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>i</name>=1</expr>;</expr_stmt>
	    }</block></then></if>
	}</block></for>
        <expr_stmt><expr><name><name>mt</name><index>[<expr>0</expr>]</index></name> = 0x80000000</expr>;</expr_stmt> <comment type="block">/* MSB is 1; assuring non-zero initial array */</comment>
    }</block></function>




    <function><type><specifier>public</specifier> <name>double</name></type> <name>next</name><parameter_list>()</parameter_list> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>z</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>mti</name> &gt;= <name>N</name></expr>)</condition><then> <block>{   <comment type="line">// generate N words at one time</comment>

	    <decl_stmt><decl><type><name>int</name></type> <name>kk</name></decl>;</decl_stmt>

	    <for>for (<init><expr><name>kk</name> = 0</expr>;</init> <condition><expr><name>kk</name> &lt; <name>N</name> - <name>M</name></expr>;</condition> <incr><expr><name>kk</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>y</name> = (<name><name>mt</name><index>[<expr><name>kk</name></expr>]</index></name> &amp; <name>UPPER_MASK</name>) | (<name><name>mt</name><index>[<expr><name>kk</name>+1</expr>]</index></name> &amp; <name>LOWER_MASK</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mt</name><index>[<expr><name>kk</name></expr>]</index></name> = <name><name>mt</name><index>[<expr><name>kk</name>+<name>M</name></expr>]</index></name> ^ (<name>y</name> &gt;&gt;&gt; 1) ^ <name><name>mag01</name><index>[<expr><name>y</name> &amp; 0x1</expr>]</index></name></expr>;</expr_stmt>
	    }</block></for>
	    <for>for (<init>;</init> <condition><expr><name>kk</name> &lt; <name>N</name>-1</expr>;</condition> <incr><expr><name>kk</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>y</name> = (<name><name>mt</name><index>[<expr><name>kk</name></expr>]</index></name> &amp; <name>UPPER_MASK</name>) | (<name><name>mt</name><index>[<expr><name>kk</name>+1</expr>]</index></name> &amp; <name>LOWER_MASK</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mt</name><index>[<expr><name>kk</name></expr>]</index></name> = <name><name>mt</name><index>[<expr><name>kk</name>+(<name>M</name>-<name>N</name>)</expr>]</index></name> ^ (<name>y</name> &gt;&gt;&gt; 1) ^ <name><name>mag01</name><index>[<expr><name>y</name> &amp; 0x1</expr>]</index></name></expr>;</expr_stmt>
	    }</block></for>
	    <expr_stmt><expr><name>y</name> = (<name><name>mt</name><index>[<expr><name>N</name>-1</expr>]</index></name> &amp; <name>UPPER_MASK</name>) | (<name><name>mt</name><index>[<expr>0</expr>]</index></name> &amp; <name>LOWER_MASK</name>)</expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>mt</name><index>[<expr><name>N</name>-1</expr>]</index></name> = <name><name>mt</name><index>[<expr><name>M</name>-1</expr>]</index></name> ^ (<name>y</name> &gt;&gt;&gt; 1) ^ <name><name>mag01</name><index>[<expr><name>y</name> &amp; 0x1</expr>]</index></name></expr>;</expr_stmt>

	    <expr_stmt><expr><name>mti</name> = 0</expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>y</name> = <name><name>mt</name><index>[<expr><name>mti</name>++</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> ^= <name>y</name> &gt;&gt;&gt; 11</expr>;</expr_stmt>                          <comment type="line">// TEMPERING_SHIFT_U(y)</comment>
	<expr_stmt><expr><name>y</name> ^= (<name>y</name> &lt;&lt; 7) &amp; <name>TEMPERING_MASK_B</name></expr>;</expr_stmt>       <comment type="line">// TEMPERING_SHIFT_S(y)</comment>
	<expr_stmt><expr><name>y</name> ^= (<name>y</name> &lt;&lt; 15) &amp; <name>TEMPERING_MASK_C</name></expr>;</expr_stmt>      <comment type="line">// TEMPERING_SHIFT_T(y)</comment>
	<expr_stmt><expr><name>y</name> ^= (<name>y</name> &gt;&gt;&gt; 18)</expr>;</expr_stmt>                        <comment type="line">// TEMPERING_SHIFT_L(y)</comment>

	<if>if <condition>(<expr><name>mti</name> &gt;= <name>N</name></expr>)</condition><then> <block>{  <comment type="line">// generate N words at one time</comment>
	    <decl_stmt><decl><type><name>int</name></type> <name>kk</name></decl>;</decl_stmt>

	    <for>for (<init><expr><name>kk</name> = 0</expr>;</init> <condition><expr><name>kk</name> &lt; <name>N</name> - <name>M</name></expr>;</condition> <incr><expr><name>kk</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>z</name> = (<name><name>mt</name><index>[<expr><name>kk</name></expr>]</index></name> &amp; <name>UPPER_MASK</name>) | (<name><name>mt</name><index>[<expr><name>kk</name>+1</expr>]</index></name> &amp; <name>LOWER_MASK</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mt</name><index>[<expr><name>kk</name></expr>]</index></name> = <name><name>mt</name><index>[<expr><name>kk</name>+<name>M</name></expr>]</index></name> ^ (<name>z</name> &gt;&gt;&gt; 1) ^ <name><name>mag01</name><index>[<expr><name>z</name> &amp; 0x1</expr>]</index></name></expr>;</expr_stmt>
	    }</block></for>
	    <for>for (<init>;</init> <condition><expr><name>kk</name> &lt; <name>N</name>-1</expr>;</condition> <incr><expr><name>kk</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>z</name> = (<name><name>mt</name><index>[<expr><name>kk</name></expr>]</index></name> &amp; <name>UPPER_MASK</name>) | (<name><name>mt</name><index>[<expr><name>kk</name>+1</expr>]</index></name> &amp; <name>LOWER_MASK</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mt</name><index>[<expr><name>kk</name></expr>]</index></name> = <name><name>mt</name><index>[<expr><name>kk</name>+(<name>M</name>-<name>N</name>)</expr>]</index></name> ^ (<name>z</name> &gt;&gt;&gt; 1) ^ <name><name>mag01</name><index>[<expr><name>z</name> &amp; 0x1</expr>]</index></name></expr>;</expr_stmt>
	    }</block></for>
	    <expr_stmt><expr><name>z</name> = (<name><name>mt</name><index>[<expr><name>N</name>-1</expr>]</index></name> &amp; <name>UPPER_MASK</name>) | (<name><name>mt</name><index>[<expr>0</expr>]</index></name> &amp; <name>LOWER_MASK</name>)</expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>mt</name><index>[<expr><name>N</name>-1</expr>]</index></name> = <name><name>mt</name><index>[<expr><name>M</name>-1</expr>]</index></name> ^ (<name>z</name> &gt;&gt;&gt; 1) ^ <name><name>mag01</name><index>[<expr><name>z</name> &amp; 0x1</expr>]</index></name></expr>;</expr_stmt>

	    <expr_stmt><expr><name>mti</name> = 0</expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>z</name> = <name><name>mt</name><index>[<expr><name>mti</name>++</expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> ^= <name>z</name> &gt;&gt;&gt; 11</expr>;</expr_stmt>                          <comment type="line">// TEMPERING_SHIFT_U(z)</comment>
	<expr_stmt><expr><name>z</name> ^= (<name>z</name> &lt;&lt; 7) &amp; <name>TEMPERING_MASK_B</name></expr>;</expr_stmt>       <comment type="line">// TEMPERING_SHIFT_S(z)</comment>
	<expr_stmt><expr><name>z</name> ^= (<name>z</name> &lt;&lt; 15) &amp; <name>TEMPERING_MASK_C</name></expr>;</expr_stmt>      <comment type="line">// TEMPERING_SHIFT_T(z)</comment>
	<expr_stmt><expr><name>z</name> ^= (<name>z</name> &gt;&gt;&gt; 18)</expr>;</expr_stmt>                        <comment type="line">// TEMPERING_SHIFT_L(z)</comment>

	<comment type="block">/* derived from nextDouble documentation in jdk 1.2 docs, see top */</comment>
	<return>return <expr>(((<call>(<name>long</name>)<argument_list>(<argument><expr><name>y</name> &gt;&gt;&gt; 6</expr></argument>)</argument_list></call>) &lt;&lt; 27) + (<name>z</name> &gt;&gt;&gt; 5)) / <call>(<name>double</name>)<argument_list>(<argument><expr>1L &lt;&lt; 53</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
    
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>RawGenerator</name></type> <name>new_instance</name><parameter_list>()</parameter_list><block>{
        <return>return <expr><name>this</name></expr>;</return> <comment type="line">//new RanMT();</comment>
    }</block></function>
    
}</block></class>
</unit>
