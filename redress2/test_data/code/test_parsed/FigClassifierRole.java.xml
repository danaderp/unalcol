<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Temp\test_metrics\ArgoUML\argouml-app\src\org\argouml\uml\diagram\collaboration\ui\FigClassifierRole.java"><comment type="block">/* $Id: FigClassifierRole.java 18726 2010-09-10 08:37:15Z mvw $
 *****************************************************************************
 * Copyright (c) 2009-2010 Contributors - see below
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Michiel van der Wulp
 *****************************************************************************
 *
 * Some portions of this file was previously release using the BSD License:
 */</comment>

<comment type="line">// Copyright (c) 1996-2009 The Regents of the University of California. All</comment>
<comment type="line">// Rights Reserved. Permission to use, copy, modify, and distribute this</comment>
<comment type="line">// software and its documentation without fee, and without a written</comment>
<comment type="line">// agreement is hereby granted, provided that the above copyright notice</comment>
<comment type="line">// and this paragraph appear in all copies.  This software program and</comment>
<comment type="line">// documentation are copyrighted by The Regents of the University of</comment>
<comment type="line">// California. The software program and documentation are supplied "AS</comment>
<comment type="line">// IS", without any accompanying services from The Regents. The Regents</comment>
<comment type="line">// does not warrant that the operation of the program will be</comment>
<comment type="line">// uninterrupted or error-free. The end-user understands that the program</comment>
<comment type="line">// was developed for research purposes and is advised not to rely</comment>
<comment type="line">// exclusively on the program for any reason.  IN NO EVENT SHALL THE</comment>
<comment type="line">// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,</comment>
<comment type="line">// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,</comment>
<comment type="line">// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF</comment>
<comment type="line">// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF</comment>
<comment type="line">// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY</comment>
<comment type="line">// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</comment>
<comment type="line">// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE</comment>
<comment type="line">// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF</comment>
<comment type="line">// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,</comment>
<comment type="line">// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.</comment>

<package>package <name><name>org</name>.<name>argouml</name>.<name>uml</name>.<name>diagram</name>.<name>collaboration</name>.<name>ui</name></name>;</package>

<import>import <name><name>java</name>.<name>awt</name>.<name>Color</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>Dimension</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>Rectangle</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Iterator</name></name>;</import>

<import>import <name><name>org</name>.<name>argouml</name>.<name>model</name>.<name>AddAssociationEvent</name></name>;</import>
<import>import <name><name>org</name>.<name>argouml</name>.<name>model</name>.<name>AttributeChangeEvent</name></name>;</import>
<import>import <name><name>org</name>.<name>argouml</name>.<name>model</name>.<name>UmlChangeEvent</name></name>;</import>
<import>import <name><name>org</name>.<name>argouml</name>.<name>notation</name>.<name>NotationProviderFactory2</name></name>;</import>
<import>import <name><name>org</name>.<name>argouml</name>.<name>uml</name>.<name>diagram</name>.<name>DiagramSettings</name></name>;</import>
<import>import <name><name>org</name>.<name>argouml</name>.<name>uml</name>.<name>diagram</name>.<name>ui</name>.<name>FigNodeModelElement</name></name>;</import>
<import>import <name><name>org</name>.<name>tigris</name>.<name>gef</name>.<name>base</name>.<name>Selection</name></name>;</import>
<import>import <name><name>org</name>.<name>tigris</name>.<name>gef</name>.<name>presentation</name>.<name>Fig</name></name>;</import>
<import>import <name><name>org</name>.<name>tigris</name>.<name>gef</name>.<name>presentation</name>.<name>FigRect</name></name>;</import>
<import>import <name><name>org</name>.<name>tigris</name>.<name>gef</name>.<name>presentation</name>.<name>FigText</name></name>;</import>

<comment type="javadoc">/**
 * Class to display graphics for a UML classifier role in a  collaboration
 * diagram.&lt;p&gt;
 *
 * Stereotypes (if there are any) and name are displayed in the center of the
 * box.
 *
 * @author 10 Apr 2002. Jeremy Bennett (mail@jeremybennett.com). Modifications
 *         to ensure stereotypes are handled correctly.
 *
 * @author agauthie
 */</comment>
<class><specifier>public</specifier> class <name>FigClassifierRole</name> <super><extends>extends <name>FigNodeModelElement</name></extends></super> <block>{

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_HEIGHT</name> =<init> <expr>50</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_WIDTH</name> =<init> <expr>90</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The minimum padding top and bottom.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>PADDING</name> =<init> <expr>5</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The fig that is used for the complete classifier role.
     * Identical in size to {@link FigNodeModelElement#bigPort}.&lt;p&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>FigRect</name></type> <name>cover</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Construct a FigClassifierRole.
     * 
     * @param owner owning UML element
     * @param bounds position and size (size is ignored)
     * @param settings render settings
     */</comment>
    <constructor><specifier>public</specifier> <name>FigClassifierRole</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>owner</name></decl></param>, <param><decl><type><name>Rectangle</name></type> <name>bounds</name></decl></param>, 
            <param><decl><type><name>DiagramSettings</name></type> <name>settings</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>bounds</name></expr></argument>, <argument><expr><name>settings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initClassifierRoleFigs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>bounds</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>setLocation</name><argument_list>(<argument><expr><name><name>bounds</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>bounds</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></constructor>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>protected</specifier> <name>Fig</name></type> <name>createBigPortFig</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// The big port. Color of the big port is irrelevant</comment>
        <return>return <expr>new <call><name>FigRect</name><argument_list>(<argument><expr><name>X0</name></expr></argument>, <argument><expr><name>Y0</name></expr></argument>, <argument><expr><name>DEFAULT_WIDTH</name></expr></argument>, <argument><expr><name>DEFAULT_HEIGHT</name></expr></argument>,
                <argument><expr><name>DEBUG_COLOR</name></expr></argument>, <argument><expr><name>DEBUG_COLOR</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * There should be no size calculations here, 
     * since not all attributes are set yet.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>initClassifierRoleFigs</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// The cover. </comment>
        <expr_stmt><expr><name>cover</name> = new <call><name>FigRect</name><argument_list>(<argument><expr><name>X0</name></expr></argument>, <argument><expr><name>Y0</name></expr></argument>, <argument><expr><name>DEFAULT_WIDTH</name></expr></argument>, <argument><expr><name>DEFAULT_HEIGHT</name></expr></argument>, <argument><expr><name>LINE_COLOR</name></expr></argument>,
                <argument><expr><name>FILL_COLOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// The stereotype. Width is the same as the cover, height is its default</comment>
        <comment type="line">// (since the font is not yet set). The text should be centered.</comment>

        <expr_stmt><expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>setLineWidth</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>setVisible</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//getStereotypeFig().setFilled(false);</comment>
        <expr_stmt><expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>setFillColor</name><argument_list>(<argument><expr><name>DEBUG_COLOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>setBounds</name><argument_list>(<argument><expr><name>X0</name></expr></argument>, <argument><expr><name>Y0</name></expr></argument>, 
                <argument><expr><name>DEFAULT_WIDTH</name></expr></argument>, <argument><expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>getHeight</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// The name. Width is the same as the cover, height is the default.</comment>
        <comment type="line">// The text of the name will be centered by</comment>
        <comment type="line">// default. In the same place as the stereotype, since at this stage</comment>
        <comment type="line">// the stereotype is not displayed. Being a classifier role it is</comment>
        <comment type="line">// underlined</comment>

        <expr_stmt><expr><call><name>getNameFig</name><argument_list>()</argument_list></call>.<call><name>setLineWidth</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>getNameFig</name><argument_list>()</argument_list></call>.<call><name>setReturnAction</name><argument_list>(<argument><expr><name><name>FigText</name>.<name>END_EDITING</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>getNameFig</name><argument_list>()</argument_list></call>.<call><name>setFilled</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>getNameFig</name><argument_list>()</argument_list></call>.<call><name>setUnderline</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>getNameFig</name><argument_list>()</argument_list></call>.<call><name>setBounds</name><argument_list>(<argument><expr><name>X0</name></expr></argument>, <argument><expr><name>Y0</name></expr></argument>, 
                <argument><expr><name>DEFAULT_WIDTH</name></expr></argument>, <argument><expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>getHeight</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// add Figs to the FigNode in back-to-front order</comment>

        <expr_stmt><expr><call><name>addFig</name><argument_list>(<argument><expr><call><name>getBigPort</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addFig</name><argument_list>(<argument><expr><name>cover</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addFig</name><argument_list>(<argument><expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addFig</name><argument_list>(<argument><expr><call><name>getNameFig</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * The NotationProvider for the ClassifierRole. &lt;p&gt;
     * 
     * The syntax is for UML is:
     * &lt;pre&gt;
     * baselist := [base] [, base]*
     * classifierRole := [name] [/ role] [: baselist]
     * &lt;/pre&gt;&lt;/p&gt;
     * 
     * The &lt;code&gt;name&lt;/code&gt; is the Instance name, not used currently.
     * See ClassifierRoleNotationUml for details.&lt;p&gt;
     *
     * This syntax is compatible with the UML 1.4 specification.
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>protected</specifier> <name>int</name></type> <name>getNotationProviderType</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>NotationProviderFactory2</name>.<name>TYPE_CLASSIFIERROLE</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Version of the clone to ensure all sub-figs are copied.&lt;p&gt;
     *
     * Uses the generic superclass clone which gives a list of all the
     * figs. Then initialize our instance variables from this list.&lt;p&gt;
     *
     * @return  A new copy of the the current fig.
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>Object</name></type> <name>clone</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>FigClassifierRole</name></type> <name>figClone</name> =<init> <expr>(<name>FigClassifierRole</name>) <call><name><name>super</name>.<name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Iterator</name></type> <name>it</name> =<init> <expr><call><name><name>figClone</name>.<name>getFigs</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>figClone</name>.<name>setBigPort</name></name><argument_list>(<argument><expr>(<name>FigRect</name>) <call><name><name>it</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>figClone</name>.<name>cover</name></name>   = (<name>FigRect</name>) <call><name><name>it</name>.<name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>it</name>.<name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>figClone</name>.<name>setNameFig</name></name><argument_list>(<argument><expr>(<name>FigText</name>) <call><name><name>it</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>figClone</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Update the stereotype text.&lt;p&gt;
     *
     * If the stereotype text is non-existent, we must make sure it is
     * marked not displayed, and update the display accordingly.&lt;p&gt;
     *
     * Similarly if there is text, we must make sure it is marked
     * displayed.&lt;p&gt;
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>protected</specifier> <name>void</name></type> <name>updateStereotypeText</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>Rectangle</name></type> <name>rect</name> =<init> <expr><call><name>getBounds</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>stereotypeHeight</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>isVisible</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>stereotypeHeight</name> = <call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>getHeight</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>heightWithoutStereo</name> =<init> <expr><call><name>getHeight</name><argument_list>()</argument_list></call> - <name>stereotypeHeight</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>populate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>stereotypeHeight</name> = 0</expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>isVisible</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>stereotypeHeight</name> = <call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>getHeight</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        
        <decl_stmt><decl><type><name>int</name></type> <name>minWidth</name> =<init> <expr><call><name><name>this</name>.<name>getMinimumSize</name></name><argument_list>()</argument_list></call>.<name>width</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>minWidth</name> &gt; <name><name>rect</name>.<name>width</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>rect</name>.<name>width</name></name> = <name>minWidth</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>setBounds</name><argument_list>(
                <argument><expr><name><name>rect</name>.<name>x</name></name></expr></argument>,
                <argument><expr><name><name>rect</name>.<name>y</name></name></expr></argument>,
                <argument><expr><name><name>rect</name>.<name>width</name></name></expr></argument>,
                <argument><expr><name>heightWithoutStereo</name> + <name>stereotypeHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calcBounds</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * @see org.tigris.gef.presentation.Fig#setLineColor(java.awt.Color)
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>setLineColor</name><parameter_list>(<param><decl><type><name>Color</name></type> <name>col</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>cover</name>.<name>setLineColor</name></name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * @see org.tigris.gef.presentation.Fig#getLineColor()
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>Color</name></type> <name>getLineColor</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>cover</name>.<name>getLineColor</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * @see org.tigris.gef.presentation.Fig#setFillColor(java.awt.Color)
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>setFillColor</name><parameter_list>(<param><decl><type><name>Color</name></type> <name>col</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>cover</name>.<name>setFillColor</name></name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * @see org.tigris.gef.presentation.Fig#getFillColor()
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>Color</name></type> <name>getFillColor</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>cover</name>.<name>getFillColor</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * @see org.tigris.gef.presentation.Fig#setFilled(boolean)
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>setFilled</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>f</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>cover</name>.<name>setFilled</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>


    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>isFilled</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>cover</name>.<name>isFilled</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * @see org.tigris.gef.presentation.Fig#setLineWidth(int)
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>setLineWidth</name><parameter_list>(<param><decl><type><name>int</name></type> <name>w</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>cover</name>.<name>setLineWidth</name></name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * @see org.tigris.gef.presentation.Fig#getLineWidth()
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>int</name></type> <name>getLineWidth</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>cover</name>.<name>getLineWidth</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Work out the minimum size that this Fig can be.&lt;p&gt;
     *
     * This should be the size of the stereotype + name + padding. However
     * we allow for the possible case that the cover or big port could be
     * bigger still.&lt;p&gt;
     *
     * @return  The minimum size of this fig.
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>Dimension</name></type> <name>getMinimumSize</name><parameter_list>()</parameter_list> <block>{

        <decl_stmt><decl><type><name>Dimension</name></type> <name>stereoMin</name>  =<init> <expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>getMinimumSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Dimension</name></type> <name>nameMin</name>    =<init> <expr><call><name>getNameFig</name><argument_list>()</argument_list></call>.<call><name>getMinimumSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Dimension</name></type> <name>newMin</name>    =<init> <expr>new <call><name>Dimension</name><argument_list>(<argument><expr><name><name>nameMin</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>nameMin</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!(<name><name>stereoMin</name>.<name>height</name></name> == 0 &amp;&amp; <name><name>stereoMin</name>.<name>width</name></name> == 0)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>newMin</name>.<name>width</name></name>   = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name><name>newMin</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>stereoMin</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newMin</name>.<name>height</name></name> += <name><name>stereoMin</name>.<name>height</name></name></expr>;</expr_stmt>
        }</block></then></if>
        
        <expr_stmt><expr><name><name>newMin</name>.<name>height</name></name> += <name>PADDING</name></expr>;</expr_stmt>

        <return>return <expr><name>newMin</name></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Override setBounds to keep shapes looking right.&lt;p&gt;
     *
     * Set the bounds of all components of the Fig. The stereotype (if any)
     * and name are centred in the fig.&lt;p&gt;
     *
     * We allow for the requested bounds being too small, and impose our
     * minimum size if necessary.&lt;p&gt;
     *
     * @param x  X coordinate of upper left corner
     *
     * @param y  Y coordinate of upper left corner
     *
     * @param w  width of bounding box
     *
     * @param h  height of bounding box
     *
     * @author 10 Apr 2002. Jeremy Bennett (mail@jeremybennett.com). Patch to
     *         allow for stereotype as well.
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>protected</specifier> <name>void</name></type> <name>setStandardBounds</name><parameter_list>(<param><decl><type><name>int</name></type> <name>x</name></decl></param>, <param><decl><type><name>int</name></type> <name>y</name></decl></param>, <param><decl><type><name>int</name></type> <name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>h</name></decl></param>)</parameter_list> <block>{

        <comment type="line">// In the rather unlikely case that we have no name, we give up.</comment>

        <if>if <condition>(<expr><call><name>getNameFig</name><argument_list>()</argument_list></call> == <name>null</name></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>

        <comment type="line">// Remember where we are at present, so we can tell GEF later. Then</comment>
        <comment type="line">// check we are as big as the minimum size</comment>

        <decl_stmt><decl><type><name>Rectangle</name></type> <name>oldBounds</name> =<init> <expr><call><name>getBounds</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Dimension</name></type> <name>minSize</name>   =<init> <expr><call><name>getMinimumSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>newW</name> =<init> <expr>(<name><name>minSize</name>.<name>width</name></name>  &gt; <name>w</name>) ? <name><name>minSize</name>.<name>width</name></name>  : <name>w</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>newH</name> =<init> <expr>(<name><name>minSize</name>.<name>height</name></name> &gt; <name>h</name>) ? <name><name>minSize</name>.<name>height</name></name> : <name>h</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Dimension</name></type> <name>stereoMin</name> =<init> <expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>getMinimumSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Dimension</name></type> <name>nameMin</name>   =<init> <expr><call><name>getNameFig</name><argument_list>()</argument_list></call>.<call><name>getMinimumSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Work out the padding each side, depending on whether the stereotype</comment>
        <comment type="line">// is displayed and set bounds accordingly</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>extraEach</name> =<init> <expr>(<name>newH</name> - <name><name>nameMin</name>.<name>height</name></name> - <name><name>stereoMin</name>.<name>height</name></name>) / 2</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!(<name><name>stereoMin</name>.<name>height</name></name> == 0 &amp;&amp; <name><name>stereoMin</name>.<name>width</name></name> == 0)</expr>)</condition><then> <block>{
            <comment type="block">/* At least one stereotype is visible */</comment>
            <expr_stmt><expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>setBounds</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name> + <name>extraEach</name></expr></argument>, <argument><expr><name>newW</name></expr></argument>, 
                    <argument><expr><call><name>getStereotypeFig</name><argument_list>()</argument_list></call>.<call><name>getHeight</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>getNameFig</name><argument_list>()</argument_list></call>.<call><name>setBounds</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name> + <name><name>stereoMin</name>.<name>height</name></name> + <name>extraEach</name></expr></argument>, <argument><expr><name>newW</name></expr></argument>,
                <argument><expr><name><name>nameMin</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Set the bounds of the bigPort and cover</comment>

        <expr_stmt><expr><call><name>getBigPort</name><argument_list>()</argument_list></call>.<call><name>setBounds</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>newW</name></expr></argument>, <argument><expr><name>newH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cover</name>.<name>setBounds</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>newW</name></expr></argument>, <argument><expr><name>newH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Record the changes in the instance variables of our parent, tell GEF</comment>
        <comment type="line">// and trigger the edges to reconsider themselves.</comment>

        <expr_stmt><expr><name>_x</name> = <name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>_y</name> = <name>y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>_w</name> = <name>newW</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>_h</name> = <name>newH</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>firePropChange</name><argument_list>(<argument><expr>"bounds"</expr></argument>, <argument><expr><name>oldBounds</name></expr></argument>, <argument><expr><call><name>getBounds</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>updateEdges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>protected</specifier> <name>void</name></type> <name>updateLayout</name><parameter_list>(<param><decl><type><name>UmlChangeEvent</name></type> <name>event</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>super</name>.<name>updateLayout</name></name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>event</name> <name>instanceof</name> <name>AddAssociationEvent</name>
                || <name>event</name> <name>instanceof</name> <name>AttributeChangeEvent</name></expr>)</condition><then> <block>{
            <comment type="line">// TODO: We need to be more specific here about what to build</comment>
            <expr_stmt><expr><call><name>renderingChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// TODO: Is this really needed?</comment>
            <expr_stmt><expr><call><name>damage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="block">/*
     * @see org.tigris.gef.presentation.Fig#makeSelection()
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>Selection</name></type> <name>makeSelection</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr>new <call><name>SelectionClassifierRole</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

}</block></class>
</unit>
