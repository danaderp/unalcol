<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\test_sys\HashMap.java"><comment type="block">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */</comment>

<package>package <name><name>java</name>.<name>util</name></name>;</package>
<import>import <name><name>java</name>.<name>io</name></name>.*;</import>

<comment type="javadoc">/**
 * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This
 * implementation provides all of the optional map operations, and permits
 * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;
 * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is
 * unsynchronized and permits nulls.)  This class makes no guarantees as to
 * the order of the map; in particular, it does not guarantee that the order
 * will remain constant over time.
 *
 * &lt;p&gt;This implementation provides constant-time performance for the basic
 * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function
 * disperses the elements properly among the buckets.  Iteration over
 * collection views requires time proportional to the "capacity" of the
 * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number
 * of key-value mappings).  Thus, it's very important not to set the initial
 * capacity too high (or the load factor too low) if iteration performance is
 * important.
 *
 * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its
 * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The
 * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial
 * capacity is simply the capacity at the time the hash table is created.  The
 * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to
 * get before its capacity is automatically increased.  When the number of
 * entries in the hash table exceeds the product of the load factor and the
 * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data
 * structures are rebuilt) so that the hash table has approximately twice the
 * number of buckets.
 *
 * &lt;p&gt;As a general rule, the default load factor (.75) offers a good tradeoff
 * between time and space costs.  Higher values decrease the space overhead
 * but increase the lookup cost (reflected in most of the operations of the
 * &lt;tt&gt;HashMap&lt;/tt&gt; class, including &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The
 * expected number of entries in the map and its load factor should be taken
 * into account when setting its initial capacity, so as to minimize the
 * number of rehash operations.  If the initial capacity is greater
 * than the maximum number of entries divided by the load factor, no
 * rehash operations will ever occur.
 *
 * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt; instance,
 * creating it with a sufficiently large capacity will allow the mappings to
 * be stored more efficiently than letting it perform automatic rehashing as
 * needed to grow the table.
 *
 * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
 * If multiple threads access a hash map concurrently, and at least one of
 * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be
 * synchronized externally.  (A structural modification is any operation
 * that adds or deletes one or more mappings; merely changing the value
 * associated with a key that an instance already contains is not a
 * structural modification.)  This is typically accomplished by
 * synchronizing on some object that naturally encapsulates the map.
 *
 * If no such object exists, the map should be "wrapped" using the
 * {@link Collections#synchronizedMap Collections.synchronizedMap}
 * method.  This is best done at creation time, to prevent accidental
 * unsynchronized access to the map:&lt;pre&gt;
 *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;
 *
 * &lt;p&gt;The iterators returned by all of this class's "collection view methods"
 * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after
 * the iterator is created, in any way except through the iterator's own
 * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a
 * {@link ConcurrentModificationException}.  Thus, in the face of concurrent
 * modification, the iterator fails quickly and cleanly, rather than risking
 * arbitrary, non-deterministic behavior at an undetermined time in the
 * future.
 *
 * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 * as it is, generally speaking, impossible to make any hard guarantees in the
 * presence of unsynchronized concurrent modification.  Fail-fast iterators
 * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.
 * Therefore, it would be wrong to write a program that depended on this
 * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
 * should be used only to detect bugs.&lt;/i&gt;
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href="{@docRoot}/../technotes/guides/collections/index.html"&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @param &lt;K&gt; the type of keys maintained by this map
 * @param &lt;V&gt; the type of mapped values
 *
 * @author  Doug Lea
 * @author  Josh Bloch
 * @author  Arthur van Hoff
 * @author  Neal Gafter
 * @see     Object#hashCode()
 * @see     Collection
 * @see     Map
 * @see     TreeMap
 * @see     Hashtable
 * @since   1.2
 */</comment>

<class><specifier>public</specifier> class <name><name>HashMap</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name>
    <super><extends>extends <name><name>AbstractMap</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></extends>
    <implements>implements <name><name>Map</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name>, <name>Cloneable</name>, <name>Serializable</name></implements></super>
<block>{

    <comment type="javadoc">/**
     * The default initial capacity - MUST be a power of two.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_INITIAL_CAPACITY</name> =<init> <expr>16</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two &lt;= 1&lt;&lt;30.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MAXIMUM_CAPACITY</name> =<init> <expr>1 &lt;&lt; 30</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The load factor used when none specified in constructor.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>float</name></type> <name>DEFAULT_LOAD_FACTOR</name> =<init> <expr>0.75f</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The table, resized as necessary. Length MUST Always be a power of two.
     */</comment>
    <decl_stmt><decl><type><name>transient</name> <name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name><index>[]</index></type> <name>table</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The number of key-value mappings contained in this map.
     */</comment>
    <decl_stmt><decl><type><name>transient</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The next size value at which to resize (capacity * load factor).
     * @serial
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>threshold</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The load factor for the hash table.
     *
     * @serial
     */</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>loadFactor</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The number of times this HashMap has been structurally modified
     * Structural modifications are those that change the number of mappings in
     * the HashMap or otherwise modify its internal structure (e.g.,
     * rehash).  This field is used to make iterators on Collection-views of
     * the HashMap fail-fast.  (See ConcurrentModificationException).
     */</comment>
    <decl_stmt><decl><type><name>transient</name> <name>int</name></type> <name>modCount</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The default threshold of map capacity above which alternative hashing is
     * used for String keys. Alternative hashing reduces the incidence of
     * collisions due to weak hash code calculation for String keys.
     * &lt;p/&gt;
     * This value may be overridden by defining the system property
     * {@code jdk.map.althashing.threshold}. A property value of {@code 1}
     * forces alternative hashing to be used at all times whereas
     * {@code -1} value ensures that alternative hashing is never used.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>ALTERNATIVE_HASHING_THRESHOLD_DEFAULT</name> =<init> <expr><name><name>Integer</name>.<name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * holds values which can't be initialized until after VM is booted.
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>Holder</name> <block>{

            <comment type="line">// Unsafe mechanics</comment>
        <comment type="javadoc">/**
         * Unsafe utilities
         */</comment>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name><name>sun</name>.<name>misc</name>.<name>Unsafe</name></name></type> <name>UNSAFE</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Offset of "final" hashSeed field we must set in readObject() method.
         */</comment>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>HASHSEED_OFFSET</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Table capacity above which to switch to use alternative hashing.
         */</comment>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>ALTERNATIVE_HASHING_THRESHOLD</name></decl>;</decl_stmt>

        static <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>altThreshold</name> =<init> <expr><call><name><name>java</name>.<name>security</name>.<name>AccessController</name>.<name>doPrivileged</name></name><argument_list>(
                <argument><expr>new <call><name><name>sun</name>.<name>security</name>.<name>action</name>.<name>GetPropertyAction</name></name><argument_list>(
                    <argument><expr>"jdk.map.althashing.threshold"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>threshold</name></decl>;</decl_stmt>
            <try>try <block>{
                <expr_stmt><expr><name>threshold</name> = (<name>null</name> != <name>altThreshold</name>)
                        ? <call><name><name>Integer</name>.<name>parseInt</name></name><argument_list>(<argument><expr><name>altThreshold</name></expr></argument>)</argument_list></call>
                        : <name>ALTERNATIVE_HASHING_THRESHOLD_DEFAULT</name></expr>;</expr_stmt>

                <comment type="line">// disable alternative hashing if -1</comment>
                <if>if <condition>(<expr><name>threshold</name> == -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>threshold</name> = <name><name>Integer</name>.<name>MAX_VALUE</name></name></expr>;</expr_stmt>
                }</block></then></if>

                <if>if <condition>(<expr><name>threshold</name> &lt; 0</expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"value must be positive integer."</expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
            }</block> <catch>catch(<param><decl><type><name>IllegalArgumentException</name></type> <name>failed</name></decl></param>) <block>{
                <throw>throw <expr>new <call><name>Error</name><argument_list>(<argument><expr>"Illegal value for 'jdk.map.althashing.threshold'"</expr></argument>, <argument><expr><name>failed</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
            <expr_stmt><expr><name>ALTERNATIVE_HASHING_THRESHOLD</name> = <name>threshold</name></expr>;</expr_stmt>

            <try>try <block>{
                <expr_stmt><expr><name>UNSAFE</name> = <call><name><name>sun</name>.<name>misc</name>.<name>Unsafe</name>.<name>getUnsafe</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>HASHSEED_OFFSET</name> = <call><name><name>UNSAFE</name>.<name>objectFieldOffset</name></name><argument_list>(
                    <argument><expr><name><name>HashMap</name>.<name><name/></name></name>class.<call><name>getDeclaredField</name><argument_list>(<argument><expr>"hashSeed"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl>NoSuchFieldException | SecurityException e</decl></param>) <block>{
                <throw>throw <expr>new <call><name>Error</name><argument_list>(<argument><expr>"Failed to record hashSeed offset"</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block>
    }</block></class>

    <comment type="javadoc">/**
     * If {@code true} then perform alternative hashing of String keys to reduce
     * the incidence of collisions due to weak hash code calculation.
     */</comment>
    <decl_stmt><decl><type><name>transient</name> <name>boolean</name></type> <name>useAltHashing</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * A randomizing value associated with this instance that is applied to
     * hash code of keys to make hash collisions harder to find.
     */</comment>
    <decl_stmt><decl><type><name>transient</name> <specifier>final</specifier> <name>int</name></type> <name>hashSeed</name> =<init> <expr><call><name><name>sun</name>.<name>misc</name>.<name>Hashing</name>.<name>randomHashSeed</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
     * capacity and load factor.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */</comment>
    <constructor><specifier>public</specifier> <name>HashMap</name><parameter_list>(<param><decl><type><name>int</name></type> <name>initialCapacity</name></decl></param>, <param><decl><type><name>float</name></type> <name>loadFactor</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>initialCapacity</name> &lt; 0</expr>)</condition><then>
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Illegal initial capacity: " +
                                               <name>initialCapacity</name></expr></argument>)</argument_list></call></expr>;</throw></then></if>
        <if>if <condition>(<expr><name>initialCapacity</name> &gt; <name>MAXIMUM_CAPACITY</name></expr>)</condition><then>
            <expr_stmt><expr><name>initialCapacity</name> = <name>MAXIMUM_CAPACITY</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>loadFactor</name> &lt;= 0 || <call><name><name>Float</name>.<name>isNaN</name></name><argument_list>(<argument><expr><name>loadFactor</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Illegal load factor: " +
                                               <name>loadFactor</name></expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <comment type="line">// Find a power of 2 &gt;= initialCapacity</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>capacity</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>capacity</name> &lt; <name>initialCapacity</name></expr>)</condition>
            <expr_stmt><expr><name>capacity</name> &lt;&lt;= 1</expr>;</expr_stmt></while>

        <expr_stmt><expr><name><name>this</name>.<name>loadFactor</name></name> = <name>loadFactor</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>threshold</name> = (<name>int</name>)<call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>capacity</name> * <name>loadFactor</name></expr></argument>, <argument><expr><name>MAXIMUM_CAPACITY</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>table</name> = new <name><name>Entry</name><index>[<expr><name>capacity</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>useAltHashing</name> = <call><name><name>sun</name>.<name>misc</name>.<name>VM</name>.<name>isBooted</name></name><argument_list>()</argument_list></call> &amp;&amp;
                (<name>capacity</name> &gt;= <name><name>Holder</name>.<name>ALTERNATIVE_HASHING_THRESHOLD</name></name>)</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param  initialCapacity the initial capacity.
     * @throws IllegalArgumentException if the initial capacity is negative.
     */</comment>
    <constructor><specifier>public</specifier> <name>HashMap</name><parameter_list>(<param><decl><type><name>int</name></type> <name>initialCapacity</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>initialCapacity</name></expr></argument>, <argument><expr><name>DEFAULT_LOAD_FACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity
     * (16) and the default load factor (0.75).
     */</comment>
    <constructor><specifier>public</specifier> <name>HashMap</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>DEFAULT_INITIAL_CAPACITY</name></expr></argument>, <argument><expr><name>DEFAULT_LOAD_FACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the
     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.
     *
     * @param   m the map whose mappings are to be placed in this map
     * @throws  NullPointerException if the specified map is null
     */</comment>
    <constructor><specifier>public</specifier> <name>HashMap</name><parameter_list>(<param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>?</name> <extends>extends <name>K</name></extends></argument>, <argument><name>?</name> <extends>extends <name>V</name></extends></argument>&gt;</argument_list></name></type> <name>m</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><call><name><name>m</name>.<name>size</name></name><argument_list>()</argument_list></call> / <name>DEFAULT_LOAD_FACTOR</name></expr></argument>)</argument_list></call> + 1</expr></argument>,
                      <argument><expr><name>DEFAULT_INITIAL_CAPACITY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_LOAD_FACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putAllForCreate</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="line">// internal utilities</comment>

    <comment type="javadoc">/**
     * Initialization hook for subclasses. This method is called
     * in all constructors and pseudo-constructors (clone, readObject)
     * after HashMap has been initialized but before any entries have
     * been inserted.  (In the absence of this method, readObject would
     * require explicit knowledge of subclasses.)
     */</comment>
    <function><type><name>void</name></type> <name>init</name><parameter_list>()</parameter_list> <block>{
    }</block></function>

    <comment type="javadoc">/**
     * Retrieve object hash code and applies a supplemental hash function to the
     * result hash, which defends against poor quality hash functions.  This is
     * critical because HashMap uses power-of-two length hash tables, that
     * otherwise encounter collisions for hashCodes that do not differ
     * in lower bits. Note: Null keys always map to hash 0, thus index 0.
     */</comment>
    <function><type><specifier>final</specifier> <name>int</name></type> <name>hash</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>k</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>h</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>useAltHashing</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>k</name> <name>instanceof</name> <name>String</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name><name>sun</name>.<name>misc</name>.<name>Hashing</name>.<name>stringHash32</name></name><argument_list>(<argument><expr>(<name>String</name>) <name>k</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>h</name> = <name>hashSeed</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>h</name> ^= <call><name><name>k</name>.<name>hashCode</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// This function ensures that hashCodes that differ only by</comment>
        <comment type="line">// constant multiples at each bit position have a bounded</comment>
        <comment type="line">// number of collisions (approximately 8 at default load factor).</comment>
        <expr_stmt><expr><name>h</name> ^= (<name>h</name> &gt;&gt;&gt; 20) ^ (<name>h</name> &gt;&gt;&gt; 12)</expr>;</expr_stmt>
        <return>return <expr><name>h</name> ^ (<name>h</name> &gt;&gt;&gt; 7) ^ (<name>h</name> &gt;&gt;&gt; 4)</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns index for hash code h.
     */</comment>
    <function><type><specifier>static</specifier> <name>int</name></type> <name>indexFor</name><parameter_list>(<param><decl><type><name>int</name></type> <name>h</name></decl></param>, <param><decl><type><name>int</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>h</name> &amp; (<name>length</name>-1)</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the number of key-value mappings in this map.
     *
     * @return the number of key-value mappings in this map
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>size</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>size</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isEmpty</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>size</name> == 0</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &lt;p&gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code (key==null ? k==null :
     * key.equals(k))}, then this method returns {@code v}; otherwise
     * it returns {@code null}.  (There can be at most one such mapping.)
     *
     * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
     * indicate that the map contains no mapping for the key; it's also
     * possible that the map explicitly maps the key to {@code null}.
     * The {@link #containsKey containsKey} operation may be used to
     * distinguish these two cases.
     *
     * @see #put(Object, Object)
     */</comment>
    <function><type><specifier>public</specifier> <name>V</name></type> <name>get</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>key</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>key</name> == <name>null</name></expr>)</condition><then>
            <return>return <expr><call><name>getForNullKey</name><argument_list>()</argument_list></call></expr>;</return></then></if>
        <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>entry</name> =<init> <expr><call><name>getEntry</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <return>return <expr><name>null</name> == <name>entry</name> ? <name>null</name> : <call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Offloaded version of get() to look up null keys.  Null keys map
     * to index 0.  This null case is split out into separate methods
     * for the sake of performance in the two most commonly used
     * operations (get and put), but incorporated with conditionals in
     * others.
     */</comment>
    <function><type><specifier>private</specifier> <name>V</name></type> <name>getForNullKey</name><parameter_list>()</parameter_list> <block>{
        <for>for (<init><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><name><name>table</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</init> <condition><expr><name>e</name> != <name>null</name></expr>;</condition> <incr><expr><name>e</name> = <name><name>e</name>.<name>next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>e</name>.<name>key</name></name> == <name>null</name></expr>)</condition><then>
                <return>return <expr><name><name>e</name>.<name>value</name></name></expr>;</return></then></if>
        }</block></for>
        <return>return <expr><name>null</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the
     * specified key.
     *
     * @param   key   The key whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified
     * key.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>containsKey</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>key</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>getEntry</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> != <name>null</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the entry associated with the specified key in the
     * HashMap.  Returns null if the HashMap contains no mapping
     * for the key.
     */</comment>
    <function><type><specifier>final</specifier> <name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>getEntry</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>key</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>hash</name> =<init> <expr>(<name>key</name> == <name>null</name>) ? 0 : <call><name>hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><name><name>table</name><index>[<expr><call><name>indexFor</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>table</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</init>
             <condition><expr><name>e</name> != <name>null</name></expr>;</condition>
             <incr><expr><name>e</name> = <name><name>e</name>.<name>next</name></name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>Object</name></type> <name>k</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>e</name>.<name>hash</name></name> == <name>hash</name> &amp;&amp;
                ((<name>k</name> = <name><name>e</name>.<name>key</name></name>) == <name>key</name> || (<name>key</name> != <name>null</name> &amp;&amp; <call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call>))</expr>)</condition><then>
                <return>return <expr><name>e</name></expr>;</return></then></if>
        }</block></for>
        <return>return <expr><name>null</name></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old
     * value is replaced.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */</comment>
    <function><type><specifier>public</specifier> <name>V</name></type> <name>put</name><parameter_list>(<param><decl><type><name>K</name></type> <name>key</name></decl></param>, <param><decl><type><name>V</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>key</name> == <name>null</name></expr>)</condition><then>
            <return>return <expr><call><name>putForNullKey</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>hash</name> =<init> <expr><call><name>hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><call><name>indexFor</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>table</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</init> <condition><expr><name>e</name> != <name>null</name></expr>;</condition> <incr><expr><name>e</name> = <name><name>e</name>.<name>next</name></name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>Object</name></type> <name>k</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>e</name>.<name>hash</name></name> == <name>hash</name> &amp;&amp; ((<name>k</name> = <name><name>e</name>.<name>key</name></name>) == <name>key</name> || <call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>V</name></type> <name>oldValue</name> =<init> <expr><name><name>e</name>.<name>value</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>e</name>.<name>value</name></name> = <name>value</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>e</name>.<name>recordAccess</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>oldValue</name></expr>;</return>
            }</block></then></if>
        }</block></for>

        <expr_stmt><expr><name>modCount</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addEntry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>null</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Offloaded version of put for null keys
     */</comment>
    <function><type><specifier>private</specifier> <name>V</name></type> <name>putForNullKey</name><parameter_list>(<param><decl><type><name>V</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><name><name>table</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</init> <condition><expr><name>e</name> != <name>null</name></expr>;</condition> <incr><expr><name>e</name> = <name><name>e</name>.<name>next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>e</name>.<name>key</name></name> == <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>V</name></type> <name>oldValue</name> =<init> <expr><name><name>e</name>.<name>value</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>e</name>.<name>value</name></name> = <name>value</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>e</name>.<name>recordAccess</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>oldValue</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name>modCount</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addEntry</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>null</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>null</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * This method is used instead of put by constructors and
     * pseudoconstructors (clone, readObject).  It does not resize the table,
     * check for comodification, etc.  It calls createEntry rather than
     * addEntry.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>putForCreate</name><parameter_list>(<param><decl><type><name>K</name></type> <name>key</name></decl></param>, <param><decl><type><name>V</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>hash</name> =<init> <expr><name>null</name> == <name>key</name> ? 0 : <call><name>hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><call><name>indexFor</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>table</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Look for preexisting entry for key.  This will never happen for
         * clone or deserialize.  It will only happen for construction if the
         * input Map is a sorted map whose ordering is inconsistent w/ equals.
         */</comment>
        <for>for (<init><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</init> <condition><expr><name>e</name> != <name>null</name></expr>;</condition> <incr><expr><name>e</name> = <name><name>e</name>.<name>next</name></name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>Object</name></type> <name>k</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>e</name>.<name>hash</name></name> == <name>hash</name> &amp;&amp;
                ((<name>k</name> = <name><name>e</name>.<name>key</name></name>) == <name>key</name> || (<name>key</name> != <name>null</name> &amp;&amp; <call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call>))</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>e</name>.<name>value</name></name> = <name>value</name></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>
        }</block></for>

        <expr_stmt><expr><call><name>createEntry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>putAllForCreate</name><parameter_list>(<param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>?</name> <extends>extends <name>K</name></extends></argument>, <argument><name>?</name> <extends>extends <name>V</name></extends></argument>&gt;</argument_list></name></type> <name>m</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>?</name> <extends>extends <name>K</name></extends></argument>, <argument><name>?</name> <extends>extends <name>V</name></extends></argument>&gt;</argument_list></name></name></type> <name>e</name> :<range> <expr><call><name><name>m</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name>putForCreate</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <comment type="javadoc">/**
     * Rehashes the contents of this map into a new array with a
     * larger capacity.  This method is called automatically when the
     * number of keys in this map reaches its threshold.
     *
     * If current capacity is MAXIMUM_CAPACITY, this method does not
     * resize the map, but sets threshold to Integer.MAX_VALUE.
     * This has the effect of preventing future calls.
     *
     * @param newCapacity the new capacity, MUST be a power of two;
     *        must be greater than current capacity unless current
     *        capacity is MAXIMUM_CAPACITY (in which case value
     *        is irrelevant).
     */</comment>
    <function><type><name>void</name></type> <name>resize</name><parameter_list>(<param><decl><type><name>int</name></type> <name>newCapacity</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Entry</name><index>[]</index></type> <name>oldTable</name> =<init> <expr><name>table</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>oldCapacity</name> =<init> <expr><name><name>oldTable</name>.<name>length</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>oldCapacity</name> == <name>MAXIMUM_CAPACITY</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>threshold</name> = <name><name>Integer</name>.<name>MAX_VALUE</name></name></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>Entry</name><index>[]</index></type> <name>newTable</name> =<init> <expr>new <name><name>Entry</name><index>[<expr><name>newCapacity</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>oldAltHashing</name> =<init> <expr><name>useAltHashing</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>useAltHashing</name> |= <call><name><name>sun</name>.<name>misc</name>.<name>VM</name>.<name>isBooted</name></name><argument_list>()</argument_list></call> &amp;&amp;
                (<name>newCapacity</name> &gt;= <name><name>Holder</name>.<name>ALTERNATIVE_HASHING_THRESHOLD</name></name>)</expr>;</expr_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>rehash</name> =<init> <expr><name>oldAltHashing</name> ^ <name>useAltHashing</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>transfer</name><argument_list>(<argument><expr><name>newTable</name></expr></argument>, <argument><expr><name>rehash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>table</name> = <name>newTable</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>threshold</name> = (<name>int</name>)<call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>newCapacity</name> * <name>loadFactor</name></expr></argument>, <argument><expr><name>MAXIMUM_CAPACITY</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Transfers all entries from current table to newTable.
     */</comment>
    <function><type><name>void</name></type> <name>transfer</name><parameter_list>(<param><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>newTable</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>rehash</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>newCapacity</name> =<init> <expr><name><name>newTable</name>.<name>length</name></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> :<range> <expr><name>table</name></expr></range></decl></init>) <block>{
            <while>while<condition>(<expr><name>null</name> != <name>e</name></expr>)</condition> <block>{
                <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>next</name> =<init> <expr><name><name>e</name>.<name>next</name></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>rehash</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>e</name>.<name>hash</name></name> = <name>null</name> == <name><name>e</name>.<name>key</name></name> ? 0 : <call><name>hash</name><argument_list>(<argument><expr><name><name>e</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><call><name>indexFor</name><argument_list>(<argument><expr><name><name>e</name>.<name>hash</name></name></expr></argument>, <argument><expr><name>newCapacity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>e</name>.<name>next</name></name> = <name><name>newTable</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newTable</name><index>[<expr><name>i</name></expr>]</index></name> = <name>e</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>e</name> = <name>next</name></expr>;</expr_stmt>
            }</block></while>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Copies all of the mappings from the specified map to this map.
     * These mappings will replace any mappings that this map had for
     * any of the keys currently in the specified map.
     *
     * @param m mappings to be stored in this map
     * @throws NullPointerException if the specified map is null
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>putAll</name><parameter_list>(<param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>?</name> <extends>extends <name>K</name></extends></argument>, <argument><name>?</name> <extends>extends <name>V</name></extends></argument>&gt;</argument_list></name></type> <name>m</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>numKeysToBeAdded</name> =<init> <expr><call><name><name>m</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>numKeysToBeAdded</name> == 0</expr>)</condition><then>
            <return>return;</return></then></if>

        <comment type="block">/*
         * Expand the map if the map if the number of mappings to be added
         * is greater than or equal to threshold.  This is conservative; the
         * obvious condition is (m.size() + size) &gt;= threshold, but this
         * condition could result in a map with twice the appropriate capacity,
         * if the keys to be added overlap with the keys already in this map.
         * By using the conservative calculation, we subject ourself
         * to at most one extra resize.
         */</comment>
        <if>if <condition>(<expr><name>numKeysToBeAdded</name> &gt; <name>threshold</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>targetCapacity</name> =<init> <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>numKeysToBeAdded</name> / <name>loadFactor</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>targetCapacity</name> &gt; <name>MAXIMUM_CAPACITY</name></expr>)</condition><then>
                <expr_stmt><expr><name>targetCapacity</name> = <name>MAXIMUM_CAPACITY</name></expr>;</expr_stmt></then></if>
            <decl_stmt><decl><type><name>int</name></type> <name>newCapacity</name> =<init> <expr><name><name>table</name>.<name>length</name></name></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>newCapacity</name> &lt; <name>targetCapacity</name></expr>)</condition>
                <expr_stmt><expr><name>newCapacity</name> &lt;&lt;= 1</expr>;</expr_stmt></while>
            <if>if <condition>(<expr><name>newCapacity</name> &gt; <name><name>table</name>.<name>length</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name>resize</name><argument_list>(<argument><expr><name>newCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>

        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>?</name> <extends>extends <name>K</name></extends></argument>, <argument><name>?</name> <extends>extends <name>V</name></extends></argument>&gt;</argument_list></name></name></type> <name>e</name> :<range> <expr><call><name><name>m</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name>put</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <comment type="javadoc">/**
     * Removes the mapping for the specified key from this map if present.
     *
     * @param  key key whose mapping is to be removed from the map
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */</comment>
    <function><type><specifier>public</specifier> <name>V</name></type> <name>remove</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>key</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><call><name>removeEntryForKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr>(<name>e</name> == <name>null</name> ? <name>null</name> : <name><name>e</name>.<name>value</name></name>)</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Removes and returns the entry associated with the specified key
     * in the HashMap.  Returns null if the HashMap contains no mapping
     * for this key.
     */</comment>
    <function><type><specifier>final</specifier> <name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>removeEntryForKey</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>key</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>hash</name> =<init> <expr>(<name>key</name> == <name>null</name>) ? 0 : <call><name>hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><call><name>indexFor</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>table</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>prev</name> =<init> <expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><name>prev</name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>e</name> != <name>null</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>next</name> =<init> <expr><name><name>e</name>.<name>next</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Object</name></type> <name>k</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>e</name>.<name>hash</name></name> == <name>hash</name> &amp;&amp;
                ((<name>k</name> = <name><name>e</name>.<name>key</name></name>) == <name>key</name> || (<name>key</name> != <name>null</name> &amp;&amp; <call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call>))</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>modCount</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>prev</name> == <name>e</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name> = <name>next</name></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><name><name>prev</name>.<name>next</name></name> = <name>next</name></expr>;</expr_stmt></else></if>
                <expr_stmt><expr><call><name><name>e</name>.<name>recordRemoval</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>e</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>prev</name> = <name>e</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>e</name> = <name>next</name></expr>;</expr_stmt>
        }</block></while>

        <return>return <expr><name>e</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Special version of remove for EntrySet using {@code Map.Entry.equals()}
     * for matching.
     */</comment>
    <function><type><specifier>final</specifier> <name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>removeMapping</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>o</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr>!(<name>o</name> <name>instanceof</name> <name><name>Map</name>.<name>Entry</name></name>)</expr>)</condition><then>
            <return>return <expr><name>null</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> =<init> <expr>(<name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name>) <name>o</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Object</name></type> <name>key</name> =<init> <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>hash</name> =<init> <expr>(<name>key</name> == <name>null</name>) ? 0 : <call><name>hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><call><name>indexFor</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>table</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>prev</name> =<init> <expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><name>prev</name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>e</name> != <name>null</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>next</name> =<init> <expr><name><name>e</name>.<name>next</name></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>e</name>.<name>hash</name></name> == <name>hash</name> &amp;&amp; <call><name><name>e</name>.<name>equals</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>modCount</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>prev</name> == <name>e</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name> = <name>next</name></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><name><name>prev</name>.<name>next</name></name> = <name>next</name></expr>;</expr_stmt></else></if>
                <expr_stmt><expr><call><name><name>e</name>.<name>recordRemoval</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>e</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>prev</name> = <name>e</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>e</name> = <name>next</name></expr>;</expr_stmt>
        }</block></while>

        <return>return <expr><name>e</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Removes all of the mappings from this map.
     * The map will be empty after this call returns.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>modCount</name>++</expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Entry</name><index>[]</index></type> <name>tab</name> =<init> <expr><name>table</name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>tab</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><name><name>tab</name><index>[<expr><name>i</name></expr>]</index></name> = <name>null</name></expr>;</expr_stmt></for>
        <expr_stmt><expr><name>size</name> = 0</expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
     * specified value.
     *
     * @param value value whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
     *         specified value
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>containsValue</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>value</name> == <name>null</name></expr>)</condition><then>
            <return>return <expr><call><name>containsNullValue</name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <decl_stmt><decl><type><name>Entry</name><index>[]</index></type> <name>tab</name> =<init> <expr><name>table</name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>tab</name>.<name>length</name></name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <for>for (<init><decl><type><name>Entry</name></type> <name>e</name> =<init> <expr><name><name>tab</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl> ;</init> <condition><expr><name>e</name> != <name>null</name></expr> ;</condition> <incr><expr><name>e</name> = <name><name>e</name>.<name>next</name></name></expr></incr>)
                <if>if <condition>(<expr><call><name><name>value</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>e</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr>true</expr>;</return></then></if></for></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Special-case code for containsValue with null argument
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>containsNullValue</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>Entry</name><index>[]</index></type> <name>tab</name> =<init> <expr><name>table</name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>tab</name>.<name>length</name></name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <for>for (<init><decl><type><name>Entry</name></type> <name>e</name> =<init> <expr><name><name>tab</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl> ;</init> <condition><expr><name>e</name> != <name>null</name></expr> ;</condition> <incr><expr><name>e</name> = <name><name>e</name>.<name>next</name></name></expr></incr>)
                <if>if <condition>(<expr><name><name>e</name>.<name>value</name></name> == <name>null</name></expr>)</condition><then>
                    <return>return <expr>true</expr>;</return></then></if></for></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and
     * values themselves are not cloned.
     *
     * @return a shallow copy of this map
     */</comment>
    <function><type><specifier>public</specifier> <name>Object</name></type> <name>clone</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>HashMap</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <expr_stmt><expr><name>result</name> = (<name><name>HashMap</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name>)<call><name><name>super</name>.<name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>CloneNotSupportedException</name></type> <name>e</name></decl></param>) <block>{
            <comment type="line">// assert false;</comment>
        }</block></catch></try>
        <expr_stmt><expr><name><name>result</name>.<name>table</name></name> = new <name><name>Entry</name><index>[<expr><name><name>table</name>.<name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name>.<name>entrySet</name></name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name>.<name>modCount</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name>.<name>size</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>result</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>result</name>.<name>putAllForCreate</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <class><specifier>static</specifier> class <name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name> <super><implements>implements <name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></implements></super> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>K</name></type> <name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>V</name></type> <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>next</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>hash</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Creates new entry.
         */</comment>
        <constructor><name>Entry</name><parameter_list>(<param><decl><type><name>int</name></type> <name>h</name></decl></param>, <param><decl><type><name>K</name></type> <name>k</name></decl></param>, <param><decl><type><name>V</name></type> <name>v</name></decl></param>, <param><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>n</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name>value</name> = <name>v</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>next</name> = <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>key</name> = <name>k</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>hash</name> = <name>h</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>K</name></type> <name>getKey</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>key</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>V</name></type> <name>getValue</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>value</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>V</name></type> <name>setValue</name><parameter_list>(<param><decl><type><name>V</name></type> <name>newValue</name></decl></param>)</parameter_list> <block>{
            <decl_stmt><decl><type><name>V</name></type> <name>oldValue</name> =<init> <expr><name>value</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>value</name> = <name>newValue</name></expr>;</expr_stmt>
            <return>return <expr><name>oldValue</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>o</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr>!(<name>o</name> <name>instanceof</name> <name><name>Map</name>.<name>Entry</name></name>)</expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
            <decl_stmt><decl><type><name><name>Map</name>.<name>Entry</name></name></type> <name>e</name> =<init> <expr>(<name><name>Map</name>.<name>Entry</name></name>)<name>o</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Object</name></type> <name>k1</name> =<init> <expr><call><name>getKey</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Object</name></type> <name>k2</name> =<init> <expr><call><name><name>e</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>k1</name> == <name>k2</name> || (<name>k1</name> != <name>null</name> &amp;&amp; <call><name><name>k1</name>.<name>equals</name></name><argument_list>(<argument><expr><name>k2</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Object</name></type> <name>v1</name> =<init> <expr><call><name>getValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Object</name></type> <name>v2</name> =<init> <expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>v1</name> == <name>v2</name> || (<name>v1</name> != <name>null</name> &amp;&amp; <call><name><name>v1</name>.<name>equals</name></name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                    <return>return <expr>true</expr>;</return></then></if>
            }</block></then></if>
            <return>return <expr>false</expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>hashCode</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>(<name>key</name>==<name>null</name>   ? 0 : <call><name><name>key</name>.<name>hashCode</name></name><argument_list>()</argument_list></call>) ^
                   (<name>value</name>==<name>null</name> ? 0 : <call><name><name>value</name>.<name>hashCode</name></name><argument_list>()</argument_list></call>)</expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name>getKey</name><argument_list>()</argument_list></call> + "=" + <call><name>getValue</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * This method is invoked whenever the value in an entry is
         * overwritten by an invocation of put(k,v) for a key k that's already
         * in the HashMap.
         */</comment>
        <function><type><name>void</name></type> <name>recordAccess</name><parameter_list>(<param><decl><type><name><name>HashMap</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>m</name></decl></param>)</parameter_list> <block>{
        }</block></function>

        <comment type="javadoc">/**
         * This method is invoked whenever the entry is
         * removed from the table.
         */</comment>
        <function><type><name>void</name></type> <name>recordRemoval</name><parameter_list>(<param><decl><type><name><name>HashMap</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>m</name></decl></param>)</parameter_list> <block>{
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Adds a new entry with the specified key, value and hash code to
     * the specified bucket.  It is the responsibility of this
     * method to resize the table if appropriate.
     *
     * Subclass overrides this to alter the behavior of put method.
     */</comment>
    <function><type><name>void</name></type> <name>addEntry</name><parameter_list>(<param><decl><type><name>int</name></type> <name>hash</name></decl></param>, <param><decl><type><name>K</name></type> <name>key</name></decl></param>, <param><decl><type><name>V</name></type> <name>value</name></decl></param>, <param><decl><type><name>int</name></type> <name>bucketIndex</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr>(<name>size</name> &gt;= <name>threshold</name>) &amp;&amp; (<name>null</name> != <name><name>table</name><index>[<expr><name>bucketIndex</name></expr>]</index></name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>resize</name><argument_list>(<argument><expr>2 * <name><name>table</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hash</name> = (<name>null</name> != <name>key</name>) ? <call><name>hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>bucketIndex</name> = <call><name>indexFor</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>table</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>createEntry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>bucketIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Like addEntry except that this version is used when creating entries
     * as part of Map construction or "pseudo-construction" (cloning,
     * deserialization).  This version needn't worry about resizing the table.
     *
     * Subclass overrides this to alter the behavior of HashMap(Map),
     * clone, and readObject.
     */</comment>
    <function><type><name>void</name></type> <name>createEntry</name><parameter_list>(<param><decl><type><name>int</name></type> <name>hash</name></decl></param>, <param><decl><type><name>K</name></type> <name>key</name></decl></param>, <param><decl><type><name>V</name></type> <name>value</name></decl></param>, <param><decl><type><name>int</name></type> <name>bucketIndex</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><name><name>table</name><index>[<expr><name>bucketIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>table</name><index>[<expr><name>bucketIndex</name></expr>]</index></name> = new <call><name><name>Entry</name><argument_list>&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name>++</expr>;</expr_stmt>
    }</block></function>

    <class><specifier>private</specifier> <specifier>abstract</specifier> class <name><name>HashIterator</name><argument_list>&lt;<argument><name>E</name></argument>&gt;</argument_list></name> <super><implements>implements <name><name>Iterator</name><argument_list>&lt;<argument><name>E</name></argument>&gt;</argument_list></name></implements></super> <block>{
        <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>next</name></decl>;</decl_stmt>        <comment type="line">// next entry to return</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>expectedModCount</name></decl>;</decl_stmt>   <comment type="line">// For fast-fail</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>              <comment type="line">// current slot</comment>
        <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>current</name></decl>;</decl_stmt>     <comment type="line">// current entry</comment>

        <constructor><name>HashIterator</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><name>expectedModCount</name> = <name>modCount</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then> <block>{ <comment type="line">// advance to first entry</comment>
                <decl_stmt><decl><type><name>Entry</name><index>[]</index></type> <name>t</name> =<init> <expr><name>table</name></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>index</name> &lt; <name><name>t</name>.<name>length</name></name> &amp;&amp; (<name>next</name> = <name><name>t</name><index>[<expr><name>index</name>++</expr>]</index></name>) == <name>null</name></expr>)</condition>
                    <empty_stmt>;</empty_stmt></while>
            }</block></then></if>
        }</block></constructor>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>hasNext</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>next</name> != <name>null</name></expr>;</return>
        }</block></function>

        <function><type><specifier>final</specifier> <name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>nextEntry</name><parameter_list>()</parameter_list> <block>{
            <if>if <condition>(<expr><name>modCount</name> != <name>expectedModCount</name></expr>)</condition><then>
                <throw>throw <expr>new <call><name>ConcurrentModificationException</name><argument_list>()</argument_list></call></expr>;</throw></then></if>
            <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><name>next</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>e</name> == <name>null</name></expr>)</condition><then>
                <throw>throw <expr>new <call><name>NoSuchElementException</name><argument_list>()</argument_list></call></expr>;</throw></then></if>

            <if>if <condition>(<expr>(<name>next</name> = <name><name>e</name>.<name>next</name></name>) == <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Entry</name><index>[]</index></type> <name>t</name> =<init> <expr><name>table</name></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>index</name> &lt; <name><name>t</name>.<name>length</name></name> &amp;&amp; (<name>next</name> = <name><name>t</name><index>[<expr><name>index</name>++</expr>]</index></name>) == <name>null</name></expr>)</condition>
                    <empty_stmt>;</empty_stmt></while>
            }</block></then></if>
            <expr_stmt><expr><name>current</name> = <name>e</name></expr>;</expr_stmt>
            <return>return <expr><name>e</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>remove</name><parameter_list>()</parameter_list> <block>{
            <if>if <condition>(<expr><name>current</name> == <name>null</name></expr>)</condition><then>
                <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>()</argument_list></call></expr>;</throw></then></if>
            <if>if <condition>(<expr><name>modCount</name> != <name>expectedModCount</name></expr>)</condition><then>
                <throw>throw <expr>new <call><name>ConcurrentModificationException</name><argument_list>()</argument_list></call></expr>;</throw></then></if>
            <decl_stmt><decl><type><name>Object</name></type> <name>k</name> =<init> <expr><name><name>current</name>.<name>key</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>current</name> = <name>null</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>HashMap</name>.<name>this</name>.<name>removeEntryForKey</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>expectedModCount</name> = <name>modCount</name></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <class><specifier>private</specifier> <specifier>final</specifier> class <name>ValueIterator</name> <super><extends>extends <name><name>HashIterator</name><argument_list>&lt;<argument><name>V</name></argument>&gt;</argument_list></name></extends></super> <block>{
        <function><type><specifier>public</specifier> <name>V</name></type> <name>next</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name>nextEntry</name><argument_list>()</argument_list></call>.<name>value</name></expr>;</return>
        }</block></function>
    }</block></class>

    <class><specifier>private</specifier> <specifier>final</specifier> class <name>KeyIterator</name> <super><extends>extends <name><name>HashIterator</name><argument_list>&lt;<argument><name>K</name></argument>&gt;</argument_list></name></extends></super> <block>{
        <function><type><specifier>public</specifier> <name>K</name></type> <name>next</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name>nextEntry</name><argument_list>()</argument_list></call>.<call><name>getKey</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <class><specifier>private</specifier> <specifier>final</specifier> class <name>EntryIterator</name> <super><extends>extends <name><name>HashIterator</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></extends></super> <block>{
        <function><type><specifier>public</specifier> <name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></type> <name>next</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name>nextEntry</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="line">// Subclass overrides these to alter behavior of views' iterator() method</comment>
    <function><type><name><name>Iterator</name><argument_list>&lt;<argument><name>K</name></argument>&gt;</argument_list></name></type> <name>newKeyIterator</name><parameter_list>()</parameter_list>   <block>{
        <return>return <expr>new <call><name>KeyIterator</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>
    <function><type><name><name>Iterator</name><argument_list>&lt;<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>newValueIterator</name><parameter_list>()</parameter_list>   <block>{
        <return>return <expr>new <call><name>ValueIterator</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>
    <function><type><name><name>Iterator</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>newEntryIterator</name><parameter_list>()</parameter_list>   <block>{
        <return>return <expr>new <call><name>EntryIterator</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="line">// Views</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <name>transient</name> <name><name>Set</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>entrySet</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Returns a {@link Set} view of the keys contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of
     * the iteration are undefined.  The set supports element removal,
     * which removes the corresponding mapping from the map, via the
     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;
     * operations.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>K</name></argument>&gt;</argument_list></name></type> <name>keySet</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>K</name></argument>&gt;</argument_list></name></type> <name>ks</name> =<init> <expr><name>keySet</name></expr></init></decl>;</decl_stmt>
        <return>return <expr>(<name>ks</name> != <name>null</name> ? <name>ks</name> : (<name>keySet</name> = new <call><name>KeySet</name><argument_list>()</argument_list></call>))</expr>;</return>
    }</block></function>

    <class><specifier>private</specifier> <specifier>final</specifier> class <name>KeySet</name> <super><extends>extends <name><name>AbstractSet</name><argument_list>&lt;<argument><name>K</name></argument>&gt;</argument_list></name></extends></super> <block>{
        <function><type><specifier>public</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name>K</name></argument>&gt;</argument_list></name></type> <name>iterator</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name>newKeyIterator</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>int</name></type> <name>size</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>size</name></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>contains</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>o</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>containsKey</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>remove</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>o</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>HashMap</name>.<name>this</name>.<name>removeEntryForKey</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> != <name>null</name></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>HashMap</name>.<name>this</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.  If the map is
     * modified while an iteration over the collection is in progress
     * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation),
     * the results of the iteration are undefined.  The collection
     * supports element removal, which removes the corresponding
     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not
     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>values</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>vs</name> =<init> <expr><name>values</name></expr></init></decl>;</decl_stmt>
        <return>return <expr>(<name>vs</name> != <name>null</name> ? <name>vs</name> : (<name>values</name> = new <call><name>Values</name><argument_list>()</argument_list></call>))</expr>;</return>
    }</block></function>

    <class><specifier>private</specifier> <specifier>final</specifier> class <name>Values</name> <super><extends>extends <name><name>AbstractCollection</name><argument_list>&lt;<argument><name>V</name></argument>&gt;</argument_list></name></extends></super> <block>{
        <function><type><specifier>public</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>iterator</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name>newValueIterator</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>int</name></type> <name>size</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>size</name></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>contains</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>o</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>containsValue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>HashMap</name>.<name>this</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the
     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the
     * iterator) the results of the iteration are undefined.  The set
     * supports element removal, which removes the corresponding
     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and
     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the
     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * @return a set view of the mappings contained in this map
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>entrySet</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>entrySet0</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>entrySet0</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>es</name> =<init> <expr><name>entrySet</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>es</name> != <name>null</name> ? <name>es</name> : (<name>entrySet</name> = new <call><name>EntrySet</name><argument_list>()</argument_list></call>)</expr>;</return>
    }</block></function>

    <class><specifier>private</specifier> <specifier>final</specifier> class <name>EntrySet</name> <super><extends>extends <name><name>AbstractSet</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></extends></super> <block>{
        <function><type><specifier>public</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>iterator</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name>newEntryIterator</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>contains</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>o</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr>!(<name>o</name> <name>instanceof</name> <name><name>Map</name>.<name>Entry</name></name>)</expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
            <decl_stmt><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></type> <name>e</name> =<init> <expr>(<name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name>) <name>o</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></type> <name>candidate</name> =<init> <expr><call><name>getEntry</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><name>candidate</name> != <name>null</name> &amp;&amp; <call><name><name>candidate</name>.<name>equals</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>remove</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>o</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>removeMapping</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> != <name>null</name></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>int</name></type> <name>size</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>size</name></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>HashMap</name>.<name>this</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,
     * serialize it).
     *
     * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the
     *             bucket array) is emitted (int), followed by the
     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value
     *             mappings), followed by the key (Object) and value (Object)
     *             for each key-value mapping.  The key-value mappings are
     *             emitted in no particular order.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>writeObject</name><parameter_list>(<param><decl><type><name><name>java</name>.<name>io</name>.<name>ObjectOutputStream</name></name></type> <name>s</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>i</name> =<init>
            <expr>(<name>size</name> &gt; 0) ? <call><name>entrySet0</name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call> : <name>null</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Write out the threshold, loadfactor, and any hidden stuff</comment>
        <expr_stmt><expr><call><name><name>s</name>.<name>defaultWriteObject</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Write out number of buckets</comment>
        <expr_stmt><expr><call><name><name>s</name>.<name>writeInt</name></name><argument_list>(<argument><expr><name><name>table</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Write out size (number of Mappings)</comment>
        <expr_stmt><expr><call><name><name>s</name>.<name>writeInt</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Write out keys and values (alternating)</comment>
        <if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then> <block>{
            <for>for(<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>K</name></argument>,<argument><name>V</name></argument>&gt;</argument_list></name></name></type> <name>e</name> :<range> <expr><call><name>entrySet0</name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                <expr_stmt><expr><call><name><name>s</name>.<name>writeObject</name></name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>s</name>.<name>writeObject</name></name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> =<init> <expr>362498820763181265L</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Reconstitute the {@code HashMap} instance from a stream (i.e.,
     * deserialize it).
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>readObject</name><parameter_list>(<param><decl><type><name><name>java</name>.<name>io</name>.<name>ObjectInputStream</name></name></type> <name>s</name></decl></param>)</parameter_list>
         <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ClassNotFoundException</name></expr></argument></throws>
    <block>{
        <comment type="line">// Read in the threshold (ignored), loadfactor, and any hidden stuff</comment>
        <expr_stmt><expr><call><name><name>s</name>.<name>defaultReadObject</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>loadFactor</name> &lt;= 0 || <call><name><name>Float</name>.<name>isNaN</name></name><argument_list>(<argument><expr><name>loadFactor</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>InvalidObjectException</name><argument_list>(<argument><expr>"Illegal load factor: " +
                                               <name>loadFactor</name></expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <comment type="line">// set hashSeed (can only happen after VM boot)</comment>
        <expr_stmt><expr><call><name><name>Holder</name>.<name>UNSAFE</name>.<name>putIntVolatile</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>Holder</name>.<name>HASHSEED_OFFSET</name></name></expr></argument>,
                <argument><expr><call><name><name>sun</name>.<name>misc</name>.<name>Hashing</name>.<name>randomHashSeed</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Read in number of buckets and allocate the bucket array;</comment>
        <expr_stmt><expr><call><name><name>s</name>.<name>readInt</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// ignored</comment>

        <comment type="line">// Read number of mappings</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>mappings</name> =<init> <expr><call><name><name>s</name>.<name>readInt</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>mappings</name> &lt; 0</expr>)</condition><then>
            <throw>throw <expr>new <call><name>InvalidObjectException</name><argument_list>(<argument><expr>"Illegal mappings count: " +
                                               <name>mappings</name></expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name>initialCapacity</name> =<init> <expr>(<name>int</name>) <call><name><name>Math</name>.<name>min</name></name><argument_list>(
                <comment type="line">// capacity chosen by number of mappings</comment>
                <comment type="line">// and desired load (if &gt;= 0.25)</comment>
                <argument><expr><name>mappings</name> * <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr>1 / <name>loadFactor</name></expr></argument>, <argument><expr>4.0f</expr></argument>)</argument_list></call></expr></argument>,
                <comment type="line">// we have limits...</comment>
                <argument><expr><name><name>HashMap</name>.<name>MAXIMUM_CAPACITY</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>capacity</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
        <comment type="line">// find smallest power of two which holds all mappings</comment>
        <while>while <condition>(<expr><name>capacity</name> &lt; <name>initialCapacity</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>capacity</name> &lt;&lt;= 1</expr>;</expr_stmt>
        }</block></while>

        <expr_stmt><expr><name>table</name> = new <name><name>Entry</name><index>[<expr><name>capacity</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>threshold</name> = (<name>int</name>) <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>capacity</name> * <name>loadFactor</name></expr></argument>, <argument><expr><name>MAXIMUM_CAPACITY</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>useAltHashing</name> = <call><name><name>sun</name>.<name>misc</name>.<name>VM</name>.<name>isBooted</name></name><argument_list>()</argument_list></call> &amp;&amp;
                (<name>capacity</name> &gt;= <name><name>Holder</name>.<name>ALTERNATIVE_HASHING_THRESHOLD</name></name>)</expr>;</expr_stmt>

        <expr_stmt><expr><call><name>init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">// Give subclass a chance to do its thing.</comment>

        <comment type="line">// Read the keys and values, and put the mappings in the HashMap</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>i</name>&lt;<name>mappings</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>K</name></type> <name>key</name> =<init> <expr>(<name>K</name>) <call><name><name>s</name>.<name>readObject</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>V</name></type> <name>value</name> =<init> <expr>(<name>V</name>) <call><name><name>s</name>.<name>readObject</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>putForCreate</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="line">// These methods are used when serializing HashSets</comment>
    <function><type><name>int</name></type>   <name>capacity</name><parameter_list>()</parameter_list>     <block>{ <return>return <expr><name><name>table</name>.<name>length</name></name></expr>;</return> }</block></function>
    <function><type><name>float</name></type> <name>loadFactor</name><parameter_list>()</parameter_list>   <block>{ <return>return <expr><name>loadFactor</name></expr>;</return>   }</block></function>
}</block></class>
</unit>
