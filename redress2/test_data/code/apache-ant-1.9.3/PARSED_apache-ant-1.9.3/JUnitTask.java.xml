<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\taskdefs\optional\junit\JUnitTask.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>optional</name>.<name>junit</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>BufferedReader</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>BufferedWriter</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileOutputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileReader</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileWriter</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>OutputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>PrintStream</name></name>;</import>
<import>import <name><name>java</name>.<name>lang</name>.<name>reflect</name>.<name>Constructor</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>URL</name></name>;</import>
<import>import <name><name>java</name>.<name>security</name>.<name>AccessController</name></name>;</import>
<import>import <name><name>java</name>.<name>security</name>.<name>PrivilegedAction</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Collection</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Enumeration</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashMap</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Hashtable</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Iterator</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Properties</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>AntClassLoader</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Task</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>Execute</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>ExecuteWatchdog</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>LogOutputStream</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>PumpStreamHandler</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Assertions</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Commandline</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>CommandlineJava</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>EnumeratedAttribute</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Environment</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Path</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Permissions</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>PropertySet</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>LoaderUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>SplitClassLoader</name></name>;</import>

<comment type="javadoc">/**
 * Runs JUnit tests.
 *
 * &lt;p&gt; JUnit is a framework to create unit tests. It has been initially
 * created by Erich Gamma and Kent Beck.  JUnit can be found at &lt;a
 * href="http://www.junit.org"&gt;http://www.junit.org&lt;/a&gt;.
 *
 * &lt;p&gt; &lt;code&gt;JUnitTask&lt;/code&gt; can run a single specific
 * &lt;code&gt;JUnitTest&lt;/code&gt; using the &lt;code&gt;test&lt;/code&gt; element.&lt;/p&gt;
 * For example, the following target &lt;code&gt;&lt;pre&gt;
 *   &amp;lt;target name="test-int-chars" depends="jar-test"&amp;gt;
 *       &amp;lt;echo message="testing international characters"/&amp;gt;
 *       &amp;lt;junit printsummary="no" haltonfailure="yes" fork="false"&amp;gt;
 *           &amp;lt;classpath refid="classpath"/&amp;gt;
 *           &amp;lt;formatter type="plain" usefile="false" /&amp;gt;
 *           &amp;lt;test name="org.apache.ecs.InternationalCharTest" /&amp;gt;
 *       &amp;lt;/junit&amp;gt;
 *   &amp;lt;/target&amp;gt;
 * &lt;/pre&gt;&lt;/code&gt;
 * &lt;p&gt;runs a single junit test
 * (&lt;code&gt;org.apache.ecs.InternationalCharTest&lt;/code&gt;) in the current
 * VM using the path with id &lt;code&gt;classpath&lt;/code&gt; as classpath and
 * presents the results formatted using the standard
 * &lt;code&gt;plain&lt;/code&gt; formatter on the command line.&lt;/p&gt;
 *
 * &lt;p&gt; This task can also run batches of tests.  The
 * &lt;code&gt;batchtest&lt;/code&gt; element creates a &lt;code&gt;BatchTest&lt;/code&gt;
 * based on a fileset.  This allows, for example, all classes found in
 * directory to be run as testcases.&lt;/p&gt;
 *
 * &lt;p&gt;For example,&lt;/p&gt;&lt;code&gt;&lt;pre&gt;
 * &amp;lt;target name="run-tests" depends="dump-info,compile-tests" if="junit.present"&amp;gt;
 *   &amp;lt;junit printsummary="no" haltonfailure="yes" fork="${junit.fork}"&amp;gt;
 *     &amp;lt;jvmarg value="-classic"/&amp;gt;
 *     &amp;lt;classpath refid="tests-classpath"/&amp;gt;
 *     &amp;lt;sysproperty key="build.tests" value="${build.tests}"/&amp;gt;
 *     &amp;lt;formatter type="brief" usefile="false" /&amp;gt;
 *     &amp;lt;batchtest&amp;gt;
 *       &amp;lt;fileset dir="${tests.dir}"&amp;gt;
 *         &amp;lt;include name="**&amp;#047;*Test*" /&amp;gt;
 *       &amp;lt;/fileset&amp;gt;
 *     &amp;lt;/batchtest&amp;gt;
 *   &amp;lt;/junit&amp;gt;
 * &amp;lt;/target&amp;gt;
 * &lt;/pre&gt;&lt;/code&gt;
 * &lt;p&gt;this target finds any classes with a &lt;code&gt;test&lt;/code&gt; directory
 * anywhere in their path (under the top &lt;code&gt;${tests.dir}&lt;/code&gt;, of
 * course) and creates &lt;code&gt;JUnitTest&lt;/code&gt;'s for each one.&lt;/p&gt;
 *
 * &lt;p&gt; Of course, &lt;code&gt;&amp;lt;junit&amp;gt;&lt;/code&gt; and
 * &lt;code&gt;&amp;lt;batch&amp;gt;&lt;/code&gt; elements can be combined for more
 * complex tests. For an example, see the ant &lt;code&gt;build.xml&lt;/code&gt;
 * target &lt;code&gt;run-tests&lt;/code&gt; (the second example is an edited
 * version).&lt;/p&gt;
 *
 * &lt;p&gt; To spawn a new Java VM to prevent interferences between
 * different testcases, you need to enable &lt;code&gt;fork&lt;/code&gt;.  A
 * number of attributes and elements allow you to set up how this JVM
 * runs.
 *
 *
 * @since Ant 1.2
 *
 * @see JUnitTest
 * @see BatchTest
 */</comment>
<class><specifier>public</specifier> class <name>JUnitTask</name> <super><extends>extends <name>Task</name></extends></super> <block>{

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>LINE_SEP</name>
        =<init> <expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"line.separator"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>CLASSPATH</name> =<init> <expr>"CLASSPATH"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>CommandlineJava</name></type> <name>commandline</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Vector</name></type> <name>tests</name> =<init> <expr>new <call><name>Vector</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Vector</name></type> <name>batchTests</name> =<init> <expr>new <call><name>Vector</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Vector</name></type> <name>formatters</name> =<init> <expr>new <call><name>Vector</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>dir</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>Integer</name></type> <name>timeout</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>summary</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>reloading</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>summaryValue</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>JUnitTaskMirror</name>.<name>JUnitTestRunnerMirror</name></name></type> <name>runner</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>newEnvironment</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Environment</name></type> <name>env</name> =<init> <expr>new <call><name>Environment</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>includeAntRuntime</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Path</name></type> <name>antRuntimeClasses</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Do we send output to System.out/.err in addition to the formatters?</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>showOutput</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="line">// Do we send output to the formatters ?</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>outputToFormatters</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>logFailedTests</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>tmpDir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>AntClassLoader</name></type> <name>classLoader</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Permissions</name></type> <name>perm</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>ForkMode</name></type> <name>forkMode</name> =<init> <expr>new <call><name>ForkMode</name><argument_list>(<argument><expr>"perTest"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>splitJUnit</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>enableTestListenerEvents</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>JUnitTaskMirror</name></type> <name>delegate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>ClassLoader</name></type> <name>mirrorLoader</name></decl>;</decl_stmt>

    <comment type="javadoc">/** A boolean on whether to get the forked path for ant classes */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>forkedPathChecked</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="line">//   Attributes for basetest</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>haltOnError</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>haltOnFail</name>  =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>filterTrace</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>fork</name>        =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type>  <name>failureProperty</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type>  <name>errorProperty</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>STRING_BUFFER_SIZE</name> =<init> <expr>128</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/**
     * @since Ant 1.7
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>TESTLISTENER_PREFIX</name> =<init>
        <expr>"junit.framework.TestListener: "</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Name of magic property that enables test listener events.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ENABLE_TESTLISTENER_EVENTS</name> =<init>
        <expr>"ant.junit.enabletestlistenerevents"</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>FileUtils</name></type> <name>FILE_UTILS</name> =<init> <expr><call><name><name>FileUtils</name>.<name>getFileUtils</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * If true, force ant to re-classload all classes for each JUnit TestCase
     *
     * @param value force class reloading for each test case
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setReloading</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>reloading</name> = <name>value</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, smartly filter the stack frames of
     * JUnit errors and failures before reporting them.
     *
     * &lt;p&gt;This property is applied on all BatchTest (batchtest) and
     * JUnitTest (test) however it can possibly be overridden by their
     * own properties.&lt;/p&gt;
     * @param value &lt;tt&gt;false&lt;/tt&gt; if it should not filter, otherwise
     * &lt;tt&gt;true&lt;tt&gt;
     *
     * @since Ant 1.5
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFiltertrace</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>filterTrace</name></name> = <name>value</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, stop the build process when there is an error in a test.
     * This property is applied on all BatchTest (batchtest) and JUnitTest
     * (test) however it can possibly be overridden by their own
     * properties.
     * @param value &lt;tt&gt;true&lt;/tt&gt; if it should halt, otherwise
     * &lt;tt&gt;false&lt;/tt&gt;
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setHaltonerror</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>haltOnError</name></name> = <name>value</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Property to set to "true" if there is a error in a test.
     *
     * &lt;p&gt;This property is applied on all BatchTest (batchtest) and
     * JUnitTest (test), however, it can possibly be overridden by
     * their own properties.&lt;/p&gt;
     * @param propertyName the name of the property to set in the
     * event of an error.
     *
     * @since Ant 1.4
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setErrorProperty</name><parameter_list>(<param><decl><type><name>String</name></type> <name>propertyName</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>errorProperty</name></name> = <name>propertyName</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, stop the build process if a test fails
     * (errors are considered failures as well).
     * This property is applied on all BatchTest (batchtest) and
     * JUnitTest (test) however it can possibly be overridden by their
     * own properties.
     * @param value &lt;tt&gt;true&lt;/tt&gt; if it should halt, otherwise
     * &lt;tt&gt;false&lt;/tt&gt;
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setHaltonfailure</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>haltOnFail</name></name> = <name>value</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Property to set to "true" if there is a failure in a test.
     *
     * &lt;p&gt;This property is applied on all BatchTest (batchtest) and
     * JUnitTest (test), however, it can possibly be overridden by
     * their own properties.&lt;/p&gt;
     * @param propertyName the name of the property to set in the
     * event of an failure.
     *
     * @since Ant 1.4
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFailureProperty</name><parameter_list>(<param><decl><type><name>String</name></type> <name>propertyName</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>failureProperty</name></name> = <name>propertyName</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, JVM should be forked for each test.
     *
     * &lt;p&gt;It avoids interference between testcases and possibly avoids
     * hanging the build.  this property is applied on all BatchTest
     * (batchtest) and JUnitTest (test) however it can possibly be
     * overridden by their own properties.&lt;/p&gt;
     * @param value &lt;tt&gt;true&lt;/tt&gt; if a JVM should be forked, otherwise
     * &lt;tt&gt;false&lt;/tt&gt;
     * @see #setTimeout
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFork</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>fork</name></name> = <name>value</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the behavior when {@link #setFork fork} fork has been enabled.
     *
     * &lt;p&gt;Possible values are "once", "perTest" and "perBatch".  If
     * set to "once", only a single Java VM will be forked for all
     * tests, with "perTest" (the default) each test will run in a
     * fresh Java VM and "perBatch" will run all tests from the same
     * &amp;lt;batchtest&amp;gt; in the same Java VM.&lt;/p&gt;
     *
     * &lt;p&gt;This attribute will be ignored if tests run in the same VM
     * as Ant.&lt;/p&gt;
     *
     * &lt;p&gt;Only tests with the same configuration of haltonerror,
     * haltonfailure, errorproperty, failureproperty and filtertrace
     * can share a forked Java VM, so even if you set the value to
     * "once", Ant may need to fork multiple VMs.&lt;/p&gt;
     * @param mode the mode to use.
     * @since Ant 1.6.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setForkMode</name><parameter_list>(<param><decl><type><name>ForkMode</name></type> <name>mode</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>forkMode</name></name> = <name>mode</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, print one-line statistics for each test, or "withOutAndErr"
     * to also show standard output and error.
     *
     * Can take the values on, off, and withOutAndErr.
     * @param value &lt;tt&gt;true&lt;/tt&gt; to print a summary,
     * &lt;tt&gt;withOutAndErr&lt;/tt&gt; to include the test&amp;apos;s output as
     * well, &lt;tt&gt;false&lt;/tt&gt; otherwise.
     * @see SummaryJUnitResultFormatter
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setPrintsummary</name><parameter_list>(<param><decl><type><name>SummaryAttribute</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>summaryValue</name> = <call><name><name>value</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>summary</name> = <call><name><name>value</name>.<name>asBoolean</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Print summary enumeration values.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>SummaryAttribute</name> <super><extends>extends <name>EnumeratedAttribute</name></extends></super> <block>{
        <comment type="javadoc">/**
         * list the possible values
         * @return  array of allowed values
         */</comment>
        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getValues</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>new <name><name>String</name><index>[]</index></name> <block>{<expr>"true"</expr>, <expr>"yes"</expr>, <expr>"false"</expr>, <expr>"no"</expr>,
                                 <expr>"on"</expr>, <expr>"off"</expr>, <expr>"withOutAndErr"</expr>}</block></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * gives the boolean equivalent of the authorized values
         * @return boolean equivalent of the value
         */</comment>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>asBoolean</name><parameter_list>()</parameter_list> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>v</name> =<init> <expr><call><name>getValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr>"true".<call><name>equals</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>
                || "on".<call><name>equals</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>
                || "yes".<call><name>equals</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>
                || "withOutAndErr".<call><name>equals</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Set the timeout value (in milliseconds).
     *
     * &lt;p&gt;If the test is running for more than this value, the test
     * will be canceled. (works only when in 'fork' mode).&lt;/p&gt;
     * @param value the maximum time (in milliseconds) allowed before
     * declaring the test as 'timed-out'
     * @see #setFork(boolean)
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTimeout</name><parameter_list>(<param><decl><type><name>Integer</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>timeout</name> = <name>value</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the maximum memory to be used by all forked JVMs.
     * @param   max     the value as defined by &lt;tt&gt;-mx&lt;/tt&gt; or &lt;tt&gt;-Xmx&lt;/tt&gt;
     *                  in the java command line options.
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaxmemory</name><parameter_list>(<param><decl><type><name>String</name></type> <name>max</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>setMaxmemory</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * The command used to invoke the Java Virtual Machine,
     * default is 'java'. The command is resolved by
     * java.lang.Runtime.exec(). Ignored if fork is disabled.
     *
     * @param   value   the new VM to use instead of &lt;tt&gt;java&lt;/tt&gt;
     * @see #setFork(boolean)
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setJvm</name><parameter_list>(<param><decl><type><name>String</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>setVm</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a JVM argument; ignored if not forking.
     *
     * @return create a new JVM argument so that any argument can be
     * passed to the JVM.
     * @see #setFork(boolean)
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Commandline</name>.<name>Argument</name></name></type> <name>createJvmarg</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>createVmArgument</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * The directory to invoke the VM in. Ignored if no JVM is forked.
     * @param   dir     the directory to invoke the JVM from.
     * @see #setFork(boolean)
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDir</name><parameter_list>(<param><decl><type><name>File</name></type> <name>dir</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>dir</name></name> = <name>dir</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a system property that tests can access.
     * This might be useful to transfer Ant properties to the
     * testcases when JVM forking is not enabled.
     *
     * @since Ant 1.3
     * @deprecated since ant 1.6
     * @param sysp environment variable to add
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addSysproperty</name><parameter_list>(<param><decl><type><name><name>Environment</name>.<name>Variable</name></name></type> <name>sysp</name></decl></param>)</parameter_list> <block>{

        <expr_stmt><expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>addSysproperty</name><argument_list>(<argument><expr><name>sysp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a system property that tests can access.
     * This might be useful to transfer Ant properties to the
     * testcases when JVM forking is not enabled.
     * @param sysp new environment variable to add
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addConfiguredSysproperty</name><parameter_list>(<param><decl><type><name><name>Environment</name>.<name>Variable</name></name></type> <name>sysp</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// get a build exception if there is a missing key or value</comment>
        <comment type="line">// see bugzilla report 21684</comment>
        <decl_stmt><decl><type><name>String</name></type> <name>testString</name> =<init> <expr><call><name><name>sysp</name>.<name>getContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>log</name><argument_list>(<argument><expr>"sysproperty added : " + <name>testString</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_DEBUG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>addSysproperty</name><argument_list>(<argument><expr><name>sysp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a set of properties that will be used as system properties
     * that tests can access.
     *
     * This might be useful to transfer Ant properties to the
     * testcases when JVM forking is not enabled.
     *
     * @param sysp set of properties to be added
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addSyspropertyset</name><parameter_list>(<param><decl><type><name>PropertySet</name></type> <name>sysp</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>addSyspropertyset</name><argument_list>(<argument><expr><name>sysp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds path to classpath used for tests.
     *
     * @return reference to the classpath in the embedded java command line
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>Path</name></type> <name>createClasspath</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>createClasspath</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>createPath</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a path to the bootclasspath.
     * @return reference to the bootclasspath in the embedded java command line
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>Path</name></type> <name>createBootclasspath</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>createBootclasspath</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>createPath</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Adds an environment variable; used when forking.
     *
     * &lt;p&gt;Will be ignored if we are not forking a new VM.&lt;/p&gt;
     * @param var environment variable to be added
     * @since Ant 1.5
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addEnv</name><parameter_list>(<param><decl><type><name><name>Environment</name>.<name>Variable</name></name></type> <name>var</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>env</name>.<name>addVariable</name></name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, use a new environment when forked.
     *
     * &lt;p&gt;Will be ignored if we are not forking a new VM.&lt;/p&gt;
     *
     * @param newenv boolean indicating if setting a new environment is wished
     * @since Ant 1.5
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setNewenvironment</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>newenv</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>newEnvironment</name> = <name>newenv</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Preset the attributes of the test
     * before configuration in the build
     * script.
     * This allows attributes in the &lt;junit&gt; task
     * be be defaults for the tests, but allows
     * individual tests to override the defaults.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>preConfigure</name><parameter_list>(<param><decl><type><name>BaseTest</name></type> <name>test</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>test</name>.<name>setFiltertrace</name></name><argument_list>(<argument><expr><name>filterTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>test</name>.<name>setHaltonerror</name></name><argument_list>(<argument><expr><name>haltOnError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>errorProperty</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>test</name>.<name>setErrorProperty</name></name><argument_list>(<argument><expr><name>errorProperty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>test</name>.<name>setHaltonfailure</name></name><argument_list>(<argument><expr><name>haltOnFail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>failureProperty</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>test</name>.<name>setFailureProperty</name></name><argument_list>(<argument><expr><name>failureProperty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>test</name>.<name>setFork</name></name><argument_list>(<argument><expr><name>fork</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add a new single testcase.
     * @param   test    a new single testcase
     * @see JUnitTest
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addTest</name><parameter_list>(<param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>tests</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>preConfigure</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a set of tests based on pattern matching.
     *
     * @return  a new instance of a batch test.
     * @see BatchTest
     *
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>BatchTest</name></type> <name>createBatchTest</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>BatchTest</name></type> <name>test</name> =<init> <expr>new <call><name>BatchTest</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>batchTests</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>preConfigure</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>test</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Add a new formatter to all tests of this task.
     *
     * @param fe formatter element
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addFormatter</name><parameter_list>(<param><decl><type><name>FormatterElement</name></type> <name>fe</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>formatters</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>fe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, include ant.jar, optional.jar and junit.jar in the forked VM.
     *
     * @param b include ant run time yes or no
     * @since Ant 1.5
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setIncludeantruntime</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>includeAntRuntime</name> = <name>b</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, send any output generated by tests to Ant's logging system
     * as well as to the formatters.
     * By default only the formatters receive the output.
     *
     * &lt;p&gt;Output will always be passed to the formatters and not by
     * shown by default.  This option should for example be set for
     * tests that are interactive and prompt the user to do
     * something.&lt;/p&gt;
     *
     * @param showOutput if true, send output to Ant's logging system too
     * @since Ant 1.5
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setShowOutput</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>showOutput</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>showOutput</name></name> = <name>showOutput</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, send any output generated by tests to the formatters.
     *
     * @param outputToFormatters if true, send output to formatters (Default
     *                           is true).
     * @since Ant 1.7.0
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setOutputToFormatters</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>outputToFormatters</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>outputToFormatters</name></name> = <name>outputToFormatters</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, write a single "FAILED" line for failed tests to Ant's
     * log system.
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setLogFailedTests</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>logFailedTests</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>logFailedTests</name></name> = <name>logFailedTests</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Assertions to enable in this program (if fork=true)
     * @since Ant 1.6
     * @param asserts assertion set
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addAssertions</name><parameter_list>(<param><decl><type><name>Assertions</name></type> <name>asserts</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>getAssertions</name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Only one assertion declaration is allowed"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>setAssertions</name><argument_list>(<argument><expr><name>asserts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the permissions for the application run inside the same JVM.
     * @since Ant 1.6
     * @return .
     */</comment>
    <function><type><specifier>public</specifier> <name>Permissions</name></type> <name>createPermissions</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>perm</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>perm</name> = new <call><name>Permissions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>perm</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * If set, system properties will be copied to the cloned VM - as
     * well as the bootclasspath unless you have explicitly specified
     * a bootclasspath.
     *
     * &lt;p&gt;Doesn't have any effect unless fork is true.&lt;/p&gt;
     * @param cloneVm a &lt;code&gt;boolean&lt;/code&gt; value.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCloneVm</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>cloneVm</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>setCloneVm</name><argument_list>(<argument><expr><name>cloneVm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a new JUnitRunner and enables fork of a new Java VM.
     *
     * @throws Exception under ??? circumstances
     * @since Ant 1.2
     */</comment>
    <constructor><specifier>public</specifier> <name>JUnitTask</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
    }</block></constructor>

    <comment type="javadoc">/**
     * Where Ant should place temporary files.
     *
     * @param tmpDir location where temporary files should go to
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTempdir</name><parameter_list>(<param><decl><type><name>File</name></type> <name>tmpDir</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>tmpDir</name> != <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name><name>tmpDir</name>.<name>exists</name></name><argument_list>()</argument_list></call> || !<call><name><name>tmpDir</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><call><name><name>tmpDir</name>.<name>toString</name></name><argument_list>()</argument_list></call>
                                         + " is not a valid temp directory"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>tmpDir</name></name> = <name>tmpDir</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether test listener events shall be generated.
     *
     * &lt;p&gt;Defaults to false.&lt;/p&gt;
     * 
     * &lt;p&gt;This value will be overridden by the magic property
     * ant.junit.enabletestlistenerevents if it has been set.&lt;/p&gt;
     *
     * @since Ant 1.8.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setEnableTestListenerEvents</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>enableTestListenerEvents</name> = <name>b</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether test listener events shall be generated.
     * @since Ant 1.8.2
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getEnableTestListenerEvents</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>e</name> =<init> <expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr><name>ENABLE_TESTLISTENER_EVENTS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>e</name> != <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>enableTestListenerEvents</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Adds the jars or directories containing Ant, this task and
     * JUnit to the classpath - this should make the forked JVM work
     * without having to specify them directly.
     *
     * @since Ant 1.4
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>antRuntimeClasses</name> = new <call><name>Path</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>splitJUnit</name> = !<call><name>addClasspathResource</name><argument_list>(<argument><expr>"/junit/framework/TestCase.class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addClasspathEntry</name><argument_list>(<argument><expr>"/org/apache/tools/ant/launch/AntMain.class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addClasspathEntry</name><argument_list>(<argument><expr>"/org/apache/tools/ant/Task.class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addClasspathEntry</name><argument_list>(<argument><expr>"/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addClasspathEntry</name><argument_list>(<argument><expr>"/org/apache/tools/ant/taskdefs/optional/junit/JUnit4TestMethodAdapter.class"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>JUnitTaskMirror</name></type> <name>createMirror</name><parameter_list>(<param><decl><type><name>JUnitTask</name></type> <name>task</name></decl></param>, <param><decl><type><name>ClassLoader</name></type> <name>loader</name></decl></param>)</parameter_list> <block>{
        <try>try <block>{
            <expr_stmt><expr><call><name><name>loader</name>.<name>loadClass</name></name><argument_list>(<argument><expr>"junit.framework.Test"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// sanity check</comment>
        }</block> <catch>catch (<param><decl><type><name>ClassNotFoundException</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                    <argument><expr>"The &lt;classpath&gt; for &lt;junit&gt; must include junit.jar "
                    + "if not in Ant's own classpath"</expr></argument>,
                    <argument><expr><name>e</name></expr></argument>, <argument><expr><call><name><name>task</name>.<name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <try>try <block>{
            <decl_stmt><decl><type><name>Class</name></type> <name>c</name> =<init> <expr><call><name><name>loader</name>.<name>loadClass</name></name><argument_list>(<argument><expr><name><name>JUnitTaskMirror</name>.<name><name/></name></name>class.<call><name>getName</name><argument_list>()</argument_list></call> + "Impl"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>c</name>.<name>getClassLoader</name></name><argument_list>()</argument_list></call> != <name>loader</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Overdelegating loader"</expr></argument>, <argument><expr><call><name><name>task</name>.<name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <decl_stmt><decl><type><name>Constructor</name></type> <name>cons</name> =<init> <expr><call><name><name>c</name>.<name>getConstructor</name></name><argument_list>(<argument><expr>new <name><name>Class</name><index>[]</index></name> <block>{<expr><name><name>JUnitTask</name>.<name><name/></name></name>class</expr>}</block></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr>(<name>JUnitTaskMirror</name>) <call><name><name>cons</name>.<name>newInstance</name></name><argument_list>(<argument><expr>new <name><name>Object</name><index>[]</index></name> <block>{<expr><name>task</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</return>
        }</block> <catch>catch (<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name><name>task</name>.<name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <comment type="javadoc">/**
     * Sets up the delegate that will actually run the tests.
     *
     * &lt;p&gt;Will be invoked implicitly once the delegate is needed.&lt;/p&gt;
     *
     * @since Ant 1.7.1
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>setupJUnitDelegate</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>ClassLoader</name></type> <name>myLoader</name> =<init> <expr><name><name>JUnitTask</name>.<name><name/></name></name>class.<call><name>getClassLoader</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>splitJUnit</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Path</name></type> <name>path</name> =<init> <expr>new <call><name>Path</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>path</name>.<name>add</name></name><argument_list>(<argument><expr><name>antRuntimeClasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Path</name></type> <name>extra</name> =<init> <expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>getClasspath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>extra</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>path</name>.<name>add</name></name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>mirrorLoader</name> = (<name>ClassLoader</name>) <call><name><name>AccessController</name>.<name>doPrivileged</name></name><argument_list>(<argument><expr>new <class><super><name>PrivilegedAction</name></super><argument_list>()</argument_list> <block>{
                <function><type><specifier>public</specifier> <name>Object</name></type> <name>run</name><parameter_list>()</parameter_list> <block>{
                    <return>return <expr>new <call><name>SplitClassLoader</name><argument_list>(<argument><expr><name>myLoader</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>,
                                     <argument><expr>new <name><name>String</name><index>[]</index></name> <block>{
                                         <expr>"BriefJUnitResultFormatter"</expr>,
                                         <expr>"JUnit4TestMethodAdapter"</expr>,
                                         <expr>"JUnitResultFormatter"</expr>,
                                         <expr>"JUnitTaskMirrorImpl"</expr>,
                                         <expr>"JUnitTestRunner"</expr>,
                                         <expr>"JUnitVersionHelper"</expr>,
                                         <expr>"OutErrSummaryJUnitResultFormatter"</expr>,
                                         <expr>"PlainJUnitResultFormatter"</expr>,
                                         <expr>"SummaryJUnitResultFormatter"</expr>,
                                         <expr>"TearDownOnVmCrash"</expr>,
                                         <expr>"XMLJUnitResultFormatter"</expr>,
                                         <expr>"IgnoredTestListener"</expr>,
                                         <expr>"IgnoredTestResult"</expr>,
                                         <expr>"CustomJUnit4TestAdapterCache"</expr>,
                                         <expr>"TestListenerWrapper"</expr>
                                     }</block></expr></argument>)</argument_list></call></expr>;</return>
                }</block></function>
            }</block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>mirrorLoader</name> = <name>myLoader</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>delegate</name> = <call><name>createMirror</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mirrorLoader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Runs the testcase.
     *
     * @throws BuildException in case of test failures or errors
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>checkMethodLists</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setupJUnitDelegate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>List</name></type> <name>testLists</name> =<init> <expr>new <call><name>ArrayList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>boolean</name></type> <name>forkPerTest</name> =<init> <expr><call><name><name>forkMode</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name><name>ForkMode</name>.<name>PER_TEST</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>forkPerTest</name> || <call><name><name>forkMode</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name><name>ForkMode</name>.<name>ONCE</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>testLists</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name>executeOrQueue</name><argument_list>(<argument><expr><call><name>getIndividualTests</name><argument_list>()</argument_list></call></expr></argument>,
                                            <argument><expr><name>forkPerTest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{ <comment type="block">/* forkMode.getValue().equals(ForkMode.PER_BATCH) */</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name> =<init> <expr><call><name><name>batchTests</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>BatchTest</name></type> <name>batchtest</name> =<init> <expr>(<name>BatchTest</name>) <call><name><name>batchTests</name>.<name>elementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>testLists</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name>executeOrQueue</name><argument_list>(<argument><expr><call><name><name>batchtest</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name><name>testLists</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name>executeOrQueue</name><argument_list>(<argument><expr><call><name><name>tests</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>forkPerTest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <try>try <block>{
            <decl_stmt><decl><type><name>Iterator</name></type> <name>iter</name> =<init> <expr><call><name><name>testLists</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>List</name></type> <name>l</name> =<init> <expr>(<name>List</name>) <call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>l</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>execute</name><argument_list>(<argument><expr>(<name>JUnitTest</name>) <call><name><name>l</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>execute</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></while>
        }</block> <finally>finally <block>{
            <expr_stmt><expr><call><name>cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * Run the tests.
     * @param arg one JUnitTest
     * @throws BuildException in case of test failures or errors
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>execute</name><parameter_list>(<param><decl><type><name>JUnitTest</name></type> <name>arg</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>validateTestName</name><argument_list>(<argument><expr><call><name><name>arg</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>JUnitTest</name></type> <name>test</name> =<init> <expr>(<name>JUnitTest</name>) <call><name><name>arg</name>.<name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// set the default values if not specified</comment>
        <comment type="line">//@todo should be moved to the test class instead.</comment>
        <if>if <condition>(<expr><call><name><name>test</name>.<name>getTodir</name></name><argument_list>()</argument_list></call> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>test</name>.<name>setTodir</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>resolveFile</name><argument_list>(<argument><expr>"."</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>test</name>.<name>getOutfile</name></name><argument_list>()</argument_list></call> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>test</name>.<name>setOutfile</name></name><argument_list>(<argument><expr>"TEST-" + <call><name><name>test</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// execute the test and get the return code</comment>
        <decl_stmt><decl><type><name>TestResultHolder</name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>test</name>.<name>getFork</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <call><name>executeInVM</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>ExecuteWatchdog</name></type> <name>watchdog</name> =<init> <expr><call><name>createWatchdog</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>result</name> = <call><name>executeAsForked</name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name>watchdog</name></expr></argument>, <argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// null watchdog means no timeout, you'd better not check with null</comment>
        }</block></else></if>
        <expr_stmt><expr><call><name>actOnTestResult</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr>"Test " + <call><name><name>test</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Throws a &lt;code&gt;BuildException&lt;/code&gt; if the given test name is invalid.
     * Validity is defined as not &lt;code&gt;null&lt;/code&gt;, not empty, and not the
     * string &amp;quot;null&amp;quot;.
     * @param testName the test name to be validated
     * @throws BuildException if &lt;code&gt;testName&lt;/code&gt; is not a valid test name
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>validateTestName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>testName</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>testName</name> == <name>null</name> || <call><name><name>testName</name>.<name>length</name></name><argument_list>()</argument_list></call> == 0
            || <call><name><name>testName</name>.<name>equals</name></name><argument_list>(<argument><expr>"null"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"test name must be specified"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Execute a list of tests in a single forked Java VM.
     * @param testList the list of tests to execute.
     * @throws BuildException on error.
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>execute</name><parameter_list>(<param><decl><type><name>List</name></type> <name>testList</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>JUnitTest</name></type> <name>test</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <comment type="line">// Create a temporary file to pass the test cases to run to</comment>
        <comment type="line">// the runner (one test case per line)</comment>
        <decl_stmt><decl><type><name>File</name></type> <name>casesFile</name> =<init> <expr><call><name>createTempPropertiesFile</name><argument_list>(<argument><expr>"junittestcases"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BufferedWriter</name></type> <name>writer</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <expr_stmt><expr><name>writer</name> = new <call><name>BufferedWriter</name><argument_list>(<argument><expr>new <call><name>FileWriter</name><argument_list>(<argument><expr><name>casesFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Creating casesfile '" + <call><name><name>casesFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call>
                + "' with content: "</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>PrintStream</name></type> <name>logWriter</name> =<init>
                <expr>new <call><name>PrintStream</name><argument_list>(<argument><expr>new <call><name>LogOutputStream</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Iterator</name></type> <name>iter</name> =<init> <expr><call><name><name>testList</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><name>test</name> = (<name>JUnitTest</name>) <call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printDual</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><name>logWriter</name></expr></argument>, <argument><expr><call><name><name>test</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>test</name>.<name>getMethods</name></name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>printDual</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><name>logWriter</name></expr></argument>, <argument><expr>":" + <call><name><name>test</name>.<name>getMethodsString</name></name><argument_list>()</argument_list></call>.<call><name>replace</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr>'+'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><call><name><name>test</name>.<name>getTodir</name></name><argument_list>()</argument_list></call> == <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>printDual</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><name>logWriter</name></expr></argument>,
                              <argument><expr>"," + <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>resolveFile</name><argument_list>(<argument><expr>"."</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>printDual</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><name>logWriter</name></expr></argument>, <argument><expr>"," + <call><name><name>test</name>.<name>getTodir</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

                <if>if <condition>(<expr><call><name><name>test</name>.<name>getOutfile</name></name><argument_list>()</argument_list></call> == <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>printlnDual</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><name>logWriter</name></expr></argument>,
                                <argument><expr>"," + "TEST-" + <call><name><name>test</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>printlnDual</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><name>logWriter</name></expr></argument>, <argument><expr>"," + <call><name><name>test</name>.<name>getOutfile</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></while>
            <expr_stmt><expr><call><name><name>writer</name>.<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>writer</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>writer</name> = <name>null</name></expr>;</expr_stmt>

            <comment type="line">// execute the test and get the return code</comment>
            <decl_stmt><decl><type><name>ExecuteWatchdog</name></type> <name>watchdog</name> =<init> <expr><call><name>createWatchdog</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TestResultHolder</name></type> <name>result</name> =<init>
                <expr><call><name>executeAsForked</name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name>watchdog</name></expr></argument>, <argument><expr><name>casesFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>actOnTestResult</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr>"Tests"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>) <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <finally>finally <block>{
            <expr_stmt><expr><call><name><name>FileUtils</name>.<name>close</name></name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <try>try <block>{
                <expr_stmt><expr><call><name><name>FILE_UTILS</name>.<name>tryHardToDelete</name></name><argument_list>(<argument><expr><name>casesFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>) <block>{
                <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch></try>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * Execute a testcase by forking a new JVM. The command will block
     * until it finishes. To know if the process was destroyed or not
     * or whether the forked Java VM exited abnormally, use the
     * attributes of the returned holder object.
     * @param  test       the testcase to execute.
     * @param  watchdog   the watchdog in charge of cancelling the test if it
     * exceeds a certain amount of time. Can be &lt;tt&gt;null&lt;/tt&gt;, in this case
     * the test could probably hang forever.
     * @param casesFile list of test cases to execute. Can be &lt;tt&gt;null&lt;/tt&gt;,
     * in this case only one test is executed.
     * @return the test results from the JVM itself.
     * @throws BuildException in case of error creating a temporary property file,
     * or if the junit process can not be forked
     */</comment>
    <function><type><specifier>private</specifier> <name>TestResultHolder</name></type> <name>executeAsForked</name><parameter_list>(<param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>,
                                             <param><decl><type><name>ExecuteWatchdog</name></type> <name>watchdog</name></decl></param>,
                                             <param><decl><type><name>File</name></type> <name>casesFile</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{

        <if>if <condition>(<expr><name>perm</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Permissions ignored when running in forked mode!"</expr></argument>,
                <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>CommandlineJava</name></type> <name>cmd</name></decl>;</decl_stmt>
        <try>try <block>{
            <expr_stmt><expr><name>cmd</name> = <call>(<name>CommandlineJava</name>) <argument_list>(<argument><expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>clone</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>CloneNotSupportedException</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"This shouldn't happen"</expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <if>if <condition>(<expr><name>casesFile</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><call><name><name>test</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>test</name>.<name>getMethods</name></name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>METHOD_NAMES</name></name> + <call><name><name>test</name>.<name>getMethodsString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Running multiple tests in the same VM"</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>TESTSFILE</name></name> + <name>casesFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>SKIP_NON_TESTS</name></name> + <call><name><name>String</name>.<name>valueOf</name></name><argument_list>(<argument><expr><call><name><name>test</name>.<name>isSkipNonTests</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>FILTERTRACE</name></name> + <call><name><name>test</name>.<name>getFiltertrace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>HALT_ON_ERROR</name></name> + <call><name><name>test</name>.<name>getHaltonerror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>HALT_ON_FAILURE</name></name>
                                      + <call><name><name>test</name>.<name>getHaltonfailure</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>checkIncludeAntRuntime</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>checkIncludeSummary</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>SHOWOUTPUT</name></name>
                                      + <call><name><name>String</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>showOutput</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>OUTPUT_TO_FORMATTERS</name></name>
                                      + <call><name><name>String</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>outputToFormatters</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>LOG_FAILED_TESTS</name></name>
                                      + <call><name><name>String</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>logFailedTests</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// #31885</comment>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>LOGTESTLISTENEREVENTS</name></name>
                                      + <call><name><name>String</name>.<name>valueOf</name></name><argument_list>(<argument><expr><call><name>getEnableTestListenerEvents</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>formatterArg</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>(<argument><expr><name>STRING_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>FormatterElement</name><index>[]</index></type> <name>feArray</name> =<init> <expr><call><name>mergeFormatters</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>feArray</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>FormatterElement</name></type> <name>fe</name> =<init> <expr><name><name>feArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>fe</name>.<name>shouldUse</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>formatterArg</name>.<name>append</name></name><argument_list>(<argument><expr><name><name>Constants</name>.<name>FORMATTER</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>formatterArg</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>fe</name>.<name>getClassname</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>File</name></type> <name>outFile</name> =<init> <expr><call><name>getOutput</name><argument_list>(<argument><expr><name>fe</name></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>outFile</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>formatterArg</name>.<name>append</name></name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>formatterArg</name>.<name>append</name></name><argument_list>(<argument><expr><name>outFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><call><name><name>formatterArg</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>formatterArg</name> = new <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <decl_stmt><decl><type><name>File</name></type> <name>vmWatcher</name> =<init> <expr><call><name>createTempPropertiesFile</name><argument_list>(<argument><expr>"junitvmwatcher"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>CRASHFILE</name></name>
                                      + <call><name><name>vmWatcher</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>File</name></type> <name>propsFile</name> =<init> <expr><call><name>createTempPropertiesFile</name><argument_list>(<argument><expr>"junit"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>PROPSFILE</name></name>
                                      + <call><name><name>propsFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Hashtable</name></type> <name>p</name> =<init> <expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperties</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Properties</name></type> <name>props</name> =<init> <expr>new <call><name>Properties</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>Enumeration</name></type> <name>e</name> =<init> <expr><call><name><name>p</name>.<name>keys</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>) <block>{
            <decl_stmt><decl><type><name>Object</name></type> <name>key</name> =<init> <expr><call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>props</name>.<name>put</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><call><name><name>p</name>.<name>get</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <try>try <block>{
            <decl_stmt><decl><type><name>FileOutputStream</name></type> <name>outstream</name> =<init> <expr>new <call><name>FileOutputStream</name><argument_list>(<argument><expr><name>propsFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>props</name>.<name>store</name></name><argument_list>(<argument><expr><name>outstream</name></expr></argument>, <argument><expr>"Ant JUnitTask generated properties file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>outstream</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name><name>java</name>.<name>io</name>.<name>IOException</name></name></type> <name>e</name></decl></param>) <block>{
            <expr_stmt><expr><call><name><name>FILE_UTILS</name>.<name>tryHardToDelete</name></name><argument_list>(<argument><expr><name>propsFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Error creating temporary properties "
                                     + "file."</expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <decl_stmt><decl><type><name>Execute</name></type> <name>execute</name> =<init> <expr>new <call><name>Execute</name><argument_list>(
            <argument><expr>new <call><name>JUnitLogStreamHandler</name><argument_list>(
                <argument><expr><name>this</name></expr></argument>,
                <argument><expr><name><name>Project</name>.<name>MSG_INFO</name></name></expr></argument>,
                <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>watchdog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>execute</name>.<name>setCommandline</name></name><argument_list>(<argument><expr><call><name><name>cmd</name>.<name>getCommandline</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>execute</name>.<name>setAntRun</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>dir</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>execute</name>.<name>setWorkingDirectory</name></name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>environment</name> =<init> <expr><call><name><name>env</name>.<name>getVariables</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>environment</name> != <name>null</name></expr>)</condition><then> <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>environment</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Setting environment variable: " + <name><name>environment</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                    <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>execute</name>.<name>setNewenvironment</name></name><argument_list>(<argument><expr><name>newEnvironment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>execute</name>.<name>setEnvironment</name></name><argument_list>(<argument><expr><name>environment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><call><name><name>cmd</name>.<name>describeCommand</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>checkForkedPath</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>TestResultHolder</name></type> <name>result</name> =<init> <expr>new <call><name>TestResultHolder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <expr_stmt><expr><name><name>result</name>.<name>exitCode</name></name> = <call><name><name>execute</name>.<name>execute</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Process fork failed."</expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <finally>finally <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>vmCrashString</name> =<init> <expr>"unknown"</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BufferedReader</name></type> <name>br</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <if>if <condition>(<expr><call><name><name>vmWatcher</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>br</name> = new <call><name>BufferedReader</name><argument_list>(<argument><expr>new <call><name>FileReader</name><argument_list>(<argument><expr><name>vmWatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>vmCrashString</name> = <call><name><name>br</name>.<name>readLine</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>vmCrashString</name> = "Monitor file ("
                            + <call><name><name>vmWatcher</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call>
                            + ") missing, location not writable,"
                            + " testcase not started or mixing ant versions?"</expr>;</expr_stmt>
                }</block></else></if>
            }</block> <catch>catch (<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>) <block>{
                <expr_stmt><expr><call><name><name>e</name>.<name>printStackTrace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// ignored.</comment>
            }</block></catch> <finally>finally <block>{
                <expr_stmt><expr><call><name><name>FileUtils</name>.<name>close</name></name><argument_list>(<argument><expr><name>br</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>vmWatcher</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>FILE_UTILS</name>.<name>tryHardToDelete</name></name><argument_list>(<argument><expr><name>vmWatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></finally></try>

            <decl_stmt><decl><type><name>boolean</name></type> <name>crash</name> =<init> <expr>(<name>watchdog</name> != <name>null</name> &amp;&amp; <call><name><name>watchdog</name>.<name>killedProcess</name></name><argument_list>()</argument_list></call>)
                || !<call><name><name>Constants</name>.<name>TERMINATED_SUCCESSFULLY</name>.<name>equals</name></name><argument_list>(<argument><expr><name>vmCrashString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>casesFile</name> != <name>null</name> &amp;&amp; <name>crash</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>test</name> = <call><name>createDummyTestForBatchTest</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>watchdog</name> != <name>null</name> &amp;&amp; <call><name><name>watchdog</name>.<name>killedProcess</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>result</name>.<name>timedOut</name></name> = true</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>logTimeout</name><argument_list>(<argument><expr><name>feArray</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>vmCrashString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>crash</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>result</name>.<name>crashed</name></name> = true</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>logVmCrash</name><argument_list>(<argument><expr><name>feArray</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>vmCrashString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if>

            <if>if <condition>(<expr>!<call><name><name>FILE_UTILS</name>.<name>tryHardToDelete</name></name><argument_list>(<argument><expr><name>propsFile</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Could not delete temporary "
                                         + "properties file '"
                                         + <call><name><name>propsFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call> + "'."</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></finally></try>

        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Adding ant runtime.
     * @param cmd command to run
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>checkIncludeAntRuntime</name><parameter_list>(<param><decl><type><name>CommandlineJava</name></type> <name>cmd</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>includeAntRuntime</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>Map</name></type><comment type="block">/*&lt;String, String&gt;*/</comment> <name>env</name> =<init> <expr><call><name><name>Execute</name>.<name>getEnvironmentVariables</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>cp</name> =<init> <expr>(<name>String</name>) <call><name><name>env</name>.<name>get</name></name><argument_list>(<argument><expr><name>CLASSPATH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>cp</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>cmd</name>.<name>createClasspath</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>createPath</name><argument_list>()</argument_list></call>
                    .<call><name>append</name><argument_list>(<argument><expr>new <call><name>Path</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Implicitly adding " + <name>antRuntimeClasses</name> + " to CLASSPATH"</expr></argument>,
                <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createClasspath</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>createPath</name><argument_list>()</argument_list></call>
                .<call><name>append</name><argument_list>(<argument><expr><name>antRuntimeClasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>


    <comment type="javadoc">/**
     * check for the parameter being "withoutanderr" in a locale-independent way.
     * @param summaryOption the summary option -can be null
     * @return true if the run should be withoutput and error
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>equalsWithOutAndErr</name><parameter_list>(<param><decl><type><name>String</name></type> <name>summaryOption</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>"withoutanderr".<call><name>equalsIgnoreCase</name><argument_list>(<argument><expr><name>summaryOption</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>checkIncludeSummary</name><parameter_list>(<param><decl><type><name>CommandlineJava</name></type> <name>cmd</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>summary</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>prefix</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>equalsWithOutAndErr</name><argument_list>(<argument><expr><name>summaryValue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>prefix</name> = "OutErr"</expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>
                .<call><name>setValue</name><argument_list>(<argument><expr><name><name>Constants</name>.<name>FORMATTER</name></name>
                          + "org.apache.tools.ant.taskdefs.optional.junit."
                          + <name>prefix</name> + "SummaryJUnitResultFormatter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Check the path for multiple different versions of
     * ant.
     * @param cmd command to execute
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>checkForkedPath</name><parameter_list>(<param><decl><type><name>CommandlineJava</name></type> <name>cmd</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>forkedPathChecked</name></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name>forkedPathChecked</name> = true</expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>cmd</name>.<name>haveClasspath</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>AntClassLoader</name></type> <name>loader</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <expr_stmt><expr><name>loader</name> =
                <call><name><name>AntClassLoader</name>.<name>newAntClassLoader</name></name><argument_list>(<argument><expr><name>null</name></expr></argument>, <argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>,
                                                 <argument><expr><call><name><name>cmd</name>.<name>createClasspath</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>projectResourceName</name> =<init>
                <expr><call><name><name>LoaderUtils</name>.<name>classNameToResource</name></name><argument_list>(<argument><expr><name><name>Project</name>.<name><name/></name></name>class.<call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>URL</name></type> <name>previous</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <for>for (<init><decl><type><name>Enumeration</name></type> <name>e</name> =<init> <expr><call><name><name>loader</name>.<name>getResources</name></name><argument_list>(<argument><expr><name>projectResourceName</name></expr></argument>)</argument_list></call></expr></init></decl>;</init>
                     <condition><expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>) <block>{
                    <decl_stmt><decl><type><name>URL</name></type> <name>current</name> =<init> <expr>(<name>URL</name>) <call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>previous</name> != <name>null</name> &amp;&amp; !<call><name>urlEquals</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"WARNING: multiple versions of ant detected "
                            + "in path for junit "
                            + <name>LINE_SEP</name> + "         " + <name>previous</name>
                            + <name>LINE_SEP</name> + "     and " + <name>current</name></expr></argument>,
                            <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return;</return>
                    }</block></then></if>
                    <expr_stmt><expr><name>previous</name> = <name>current</name></expr>;</expr_stmt>
                }</block></for>
            }</block> <catch>catch (<param><decl><type><name>Exception</name></type> <name>ex</name></decl></param>) <block>{
                <comment type="line">// Ignore exception</comment>
            }</block></catch></try>
        }</block> <finally>finally <block>{
            <if>if <condition>(<expr><name>loader</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>loader</name>.<name>cleanup</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * Compares URLs for equality but takes case-sensitivity into
     * account when comparing file URLs and ignores the jar specific
     * part of the URL if present.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>urlEquals</name><parameter_list>(<param><decl><type><name>URL</name></type> <name>u1</name></decl></param>, <param><decl><type><name>URL</name></type> <name>u2</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>url1</name> =<init> <expr><call><name>maybeStripJarAndClass</name><argument_list>(<argument><expr><name>u1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>url2</name> =<init> <expr><call><name>maybeStripJarAndClass</name><argument_list>(<argument><expr><name>u2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>url1</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"file:"</expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>url2</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"file:"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>new <call><name>File</name><argument_list>(<argument><expr><call><name><name>FILE_UTILS</name>.<name>fromURI</name></name><argument_list>(<argument><expr><name>url1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                .<call><name>equals</name><argument_list>(<argument><expr>new <call><name>File</name><argument_list>(<argument><expr><call><name><name>FILE_UTILS</name>.<name>fromURI</name></name><argument_list>(<argument><expr><name>url2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>url1</name>.<name>equals</name></name><argument_list>(<argument><expr><name>url2</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>maybeStripJarAndClass</name><parameter_list>(<param><decl><type><name>URL</name></type> <name>u</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>s</name> =<init> <expr><call><name><name>u</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>s</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"jar:"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>pling</name> =<init> <expr><call><name><name>s</name>.<name>indexOf</name></name><argument_list>(<argument><expr>'!'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>s</name> = <call><name><name>s</name>.<name>substring</name></name><argument_list>(<argument><expr>4</expr></argument>, <argument><expr><name>pling</name> == -1 ? <call><name><name>s</name>.<name>length</name></name><argument_list>()</argument_list></call> : <name>pling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>s</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Create a temporary file to pass the properties to a new process.
     * Will auto-delete on (graceful) exit.
     * The file will be in the project basedir unless tmpDir declares
     * something else.
     * @param prefix
     * @return created file
     */</comment>
    <function><type><specifier>private</specifier> <name>File</name></type> <name>createTempPropertiesFile</name><parameter_list>(<param><decl><type><name>String</name></type> <name>prefix</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>File</name></type> <name>propsFile</name> =<init>
            <expr><call><name><name>FILE_UTILS</name>.<name>createTempFile</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr>".properties"</expr></argument>,
                <argument><expr><name>tmpDir</name> != <name>null</name> ? <name>tmpDir</name> : <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getBaseDir</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>propsFile</name></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Pass output sent to System.out to the TestRunner so it can
     * collect it for the formatters.
     *
     * @param output output coming from System.out
     * @since Ant 1.5
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>handleOutput</name><parameter_list>(<param><decl><type><name>String</name></type> <name>output</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>output</name>.<name>startsWith</name></name><argument_list>(<argument><expr><name>TESTLISTENER_PREFIX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>runner</name> != <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>outputToFormatters</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>runner</name>.<name>handleOutput</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>showOutput</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>super</name>.<name>handleOutput</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>super</name>.<name>handleOutput</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Handle an input request by this task.
     * @see Task#handleInput(byte[], int, int)
     * This implementation delegates to a runner if it
     * present.
     * @param buffer the buffer into which data is to be read.
     * @param offset the offset into the buffer at which data is stored.
     * @param length the amount of data to read.
     *
     * @return the number of bytes read.
     * @exception IOException if the data cannot be read.
     *
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>protected</specifier> <name>int</name></type> <name>handleInput</name><parameter_list>(<param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><name>int</name></type> <name>length</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>runner</name> != <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>runner</name>.<name>handleInput</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <return>return <expr><call><name><name>super</name>.<name>handleInput</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>


    <comment type="javadoc">/**
     * Pass output sent to System.out to the TestRunner so it can
     * collect ot for the formatters.
     *
     * @param output output coming from System.out
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>handleFlush</name><parameter_list>(<param><decl><type><name>String</name></type> <name>output</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>runner</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>runner</name>.<name>handleFlush</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>showOutput</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>super</name>.<name>handleFlush</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>super</name>.<name>handleFlush</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Pass output sent to System.err to the TestRunner so it can
     * collect it for the formatters.
     *
     * @param output output coming from System.err
     * @since Ant 1.5
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>handleErrorOutput</name><parameter_list>(<param><decl><type><name>String</name></type> <name>output</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>runner</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>runner</name>.<name>handleErrorOutput</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>showOutput</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>super</name>.<name>handleErrorOutput</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>super</name>.<name>handleErrorOutput</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>


    <comment type="javadoc">/**
     * Pass output sent to System.err to the TestRunner so it can
     * collect it for the formatters.
     *
     * @param output coming from System.err
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>handleErrorFlush</name><parameter_list>(<param><decl><type><name>String</name></type> <name>output</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>runner</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>runner</name>.<name>handleErrorFlush</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>showOutput</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>super</name>.<name>handleErrorFlush</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>super</name>.<name>handleErrorFlush</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="line">// in VM is not very nice since it could probably hang the</comment>
    <comment type="line">// whole build. IMHO this method should be avoided and it would be best</comment>
    <comment type="line">// to remove it in future versions. TBD. (SBa)</comment>

    <comment type="javadoc">/**
     * Execute inside VM.
     * @param arg one JUnitTest
     * @throws BuildException under unspecified circumstances
     * @return the results
     */</comment>
    <function><type><specifier>private</specifier> <name>TestResultHolder</name></type> <name>executeInVM</name><parameter_list>(<param><decl><type><name>JUnitTest</name></type> <name>arg</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>delegate</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>setupJUnitDelegate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>JUnitTest</name></type> <name>test</name> =<init> <expr>(<name>JUnitTest</name>) <call><name><name>arg</name>.<name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>test</name>.<name>setProperties</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperties</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>dir</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"dir attribute ignored if running in the same VM"</expr></argument>,
                <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>newEnvironment</name> || <name>null</name> != <call><name><name>env</name>.<name>getVariables</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Changes to environment variables are ignored if running in "
                + "the same VM."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>getBootclasspath</name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"bootclasspath is ignored if running in the same VM."</expr></argument>,
                <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name><name>CommandlineJava</name>.<name>SysProperties</name></name></type> <name>sysProperties</name> =<init>
                <expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>getSystemProperties</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>sysProperties</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>sysProperties</name>.<name>setSystem</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <try>try <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Using System properties " + <call><name><name>System</name>.<name>getProperties</name></name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>splitJUnit</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>classLoader</name> = (<name>AntClassLoader</name>) <call><name><name>delegate</name>.<name>getClass</name></name><argument_list>()</argument_list></call>.<call><name>getClassLoader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>createClassLoader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <if>if <condition>(<expr><name>classLoader</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>classLoader</name>.<name>setThreadContextLoader</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>runner</name> = <call><name><name>delegate</name>.<name>newJUnitTestRunner</name></name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><call><name><name>test</name>.<name>getMethods</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>test</name>.<name>getHaltonerror</name></name><argument_list>()</argument_list></call></expr></argument>,
                                         <argument><expr><call><name><name>test</name>.<name>getFiltertrace</name></name><argument_list>()</argument_list></call></expr></argument>,
                                         <argument><expr><call><name><name>test</name>.<name>getHaltonfailure</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>false</expr></argument>,
                                         <argument><expr><call><name>getEnableTestListenerEvents</name><argument_list>()</argument_list></call></expr></argument>,
                                         <argument><expr><name>classLoader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>summary</name></expr>)</condition><then> <block>{

                <decl_stmt><decl><type><name><name>JUnitTaskMirror</name>.<name>SummaryJUnitResultFormatterMirror</name></name></type> <name>f</name> =<init>
                    <expr><call><name><name>delegate</name>.<name>newSummaryJUnitResultFormatter</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>f</name>.<name>setWithOutAndErr</name></name><argument_list>(<argument><expr><call><name>equalsWithOutAndErr</name><argument_list>(<argument><expr><name>summaryValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>f</name>.<name>setOutput</name></name><argument_list>(<argument><expr><call><name>getDefaultOutput</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>runner</name>.<name>addFormatter</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name><name>runner</name>.<name>setPermissions</name></name><argument_list>(<argument><expr><name>perm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><specifier>final</specifier> <name>FormatterElement</name><index>[]</index></type> <name>feArray</name> =<init> <expr><call><name>mergeFormatters</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>feArray</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>FormatterElement</name></type> <name>fe</name> =<init> <expr><name><name>feArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>fe</name>.<name>shouldUse</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>File</name></type> <name>outFile</name> =<init> <expr><call><name>getOutput</name><argument_list>(<argument><expr><name>fe</name></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>outFile</name> != <name>null</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>fe</name>.<name>setOutfile</name></name><argument_list>(<argument><expr><name>outFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>fe</name>.<name>setOutput</name></name><argument_list>(<argument><expr><call><name>getDefaultOutput</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <expr_stmt><expr><call><name><name>runner</name>.<name>addFormatter</name></name><argument_list>(<argument><expr><call><name><name>fe</name>.<name>createFormatter</name></name><argument_list>(<argument><expr><name>classLoader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

            <expr_stmt><expr><call><name><name>runner</name>.<name>run</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>TestResultHolder</name></type> <name>result</name> =<init> <expr>new <call><name>TestResultHolder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name>.<name>exitCode</name></name> = <call><name><name>runner</name>.<name>getRetCode</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>result</name></expr>;</return>
        }</block> <finally>finally <block>{
            <if>if <condition>(<expr><name>sysProperties</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>sysProperties</name>.<name>restoreSystem</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>classLoader</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>classLoader</name>.<name>resetThreadContextLoader</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * @return &lt;tt&gt;null&lt;/tt&gt; if there is a timeout value, otherwise the
     * watchdog instance.
     *
     * @throws BuildException under unspecified circumstances
     * @since Ant 1.2
     */</comment>
    <function><type><specifier>protected</specifier> <name>ExecuteWatchdog</name></type> <name>createWatchdog</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>timeout</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr><name>null</name></expr>;</return>
        }</block></then></if>
        <return>return <expr>new <call><name>ExecuteWatchdog</name><argument_list>(<argument><expr>(<name>long</name>) <call><name><name>timeout</name>.<name>intValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Get the default output for a formatter.
     *
     * @return default output stream for a formatter
     * @since Ant 1.3
     */</comment>
    <function><type><specifier>protected</specifier> <name>OutputStream</name></type> <name>getDefaultOutput</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr>new <call><name>LogOutputStream</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_INFO</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Merge all individual tests from the batchtest with all individual tests
     * and return an enumeration over all &lt;tt&gt;JUnitTest&lt;/tt&gt;.
     *
     * @return enumeration over individual tests
     * @since Ant 1.3
     */</comment>
    <function><type><specifier>protected</specifier> <name>Enumeration</name></type> <name>getIndividualTests</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name> =<init> <expr><call><name><name>batchTests</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Enumeration</name><index>[]</index></type> <name>enums</name> =<init> <expr>new <name><name>Enumeration</name><index>[ <expr><name>count</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>BatchTest</name></type> <name>batchtest</name> =<init> <expr>(<name>BatchTest</name>) <call><name><name>batchTests</name>.<name>elementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>enums</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name><name>batchtest</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name><name>enums</name><index>[<expr><name><name>enums</name>.<name>length</name></name> - 1</expr>]</index></name> = <call><name><name>tests</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>Enumerations</name>.<name>fromCompound</name></name><argument_list>(<argument><expr><name>enums</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Verifies all &lt;code&gt;test&lt;/code&gt; elements having the &lt;code&gt;methods&lt;/code&gt;
     * attribute specified and having the &lt;code&gt;if&lt;/code&gt;-condition resolved
     * to true, that the value of the &lt;code&gt;methods&lt;/code&gt; attribute is valid.
     * @exception BuildException if some of the tests matching the described
     *                           conditions has invalid value of the
     *                           &lt;code&gt;methods&lt;/code&gt; attribute
     * @since 1.8.2
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>checkMethodLists</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><call><name><name>tests</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>Enumeration</name></type> <name>testsEnum</name> =<init> <expr><call><name><name>tests</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>testsEnum</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>JUnitTest</name></type> <name>test</name> =<init> <expr>(<name>JUnitTest</name>) <call><name><name>testsEnum</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>test</name>.<name>hasMethodsSpecified</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>test</name>.<name>shouldRun</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>test</name>.<name>resolveMethods</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>
    }</block></function>

    <comment type="javadoc">/**
     * return an enumeration listing each test, then each batchtest
     * @return enumeration
     * @since Ant 1.3
     */</comment>
    <function><type><specifier>protected</specifier> <name>Enumeration</name></type> <name>allTests</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>Enumeration</name><index>[]</index></type> <name>enums</name> =<init> <expr><block>{<expr><call><name><name>tests</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr>, <expr><call><name><name>batchTests</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr>}</block></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>Enumerations</name>.<name>fromCompound</name></name><argument_list>(<argument><expr><name>enums</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * @param test junit test
     * @return array of FormatterElement
     * @since Ant 1.3
     */</comment>
    <function><type><specifier>private</specifier> <name>FormatterElement</name><index>[]</index></type> <name>mergeFormatters</name><parameter_list>(<param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Vector</name></type> <name>feVector</name> =<init> <expr>(<name>Vector</name>) <call><name><name>formatters</name>.<name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>test</name>.<name>addFormattersTo</name></name><argument_list>(<argument><expr><name>feVector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>FormatterElement</name><index>[]</index></type> <name>feArray</name> =<init> <expr>new <name><name>FormatterElement</name><index>[<expr><call><name><name>feVector</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>feVector</name>.<name>copyInto</name></name><argument_list>(<argument><expr><name>feArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>feArray</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * If the formatter sends output to a file, return that file.
     * null otherwise.
     * @param fe  formatter element
     * @param test one JUnit test
     * @return file reference
     * @since Ant 1.3
     */</comment>
    <function><type><specifier>protected</specifier> <name>File</name></type> <name>getOutput</name><parameter_list>(<param><decl><type><name>FormatterElement</name></type> <name>fe</name></decl></param>, <param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>fe</name>.<name>getUseFile</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>base</name> =<init> <expr><call><name><name>test</name>.<name>getOutfile</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>base</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>base</name> = <name><name>JUnitTaskMirror</name>.<name>JUnitTestRunnerMirror</name>.<name>IGNORED_FILE_NAME</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <decl_stmt><decl><type><name>String</name></type> <name>filename</name> =<init> <expr><name>base</name> + <call><name><name>fe</name>.<name>getExtension</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>File</name></type> <name>destFile</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><call><name><name>test</name>.<name>getTodir</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>absFilename</name> =<init> <expr><call><name><name>destFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>resolveFile</name><argument_list>(<argument><expr><name>absFilename</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>null</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Search for the given resource and add the directory or archive
     * that contains it to the classpath.
     *
     * &lt;p&gt;Doesn't work for archives in JDK 1.1 as the URL returned by
     * getResource doesn't contain the name of the archive.&lt;/p&gt;
     *
     * @param resource resource that one wants to lookup
     * @since Ant 1.4
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>addClasspathEntry</name><parameter_list>(<param><decl><type><name>String</name></type> <name>resource</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>addClasspathResource</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Implementation of addClasspathEntry.
     *
     * @param resource resource that one wants to lookup
     * @return true if something was in fact added
     * @since Ant 1.7.1
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>addClasspathResource</name><parameter_list>(<param><decl><type><name>String</name></type> <name>resource</name></decl></param>)</parameter_list> <block>{
        <comment type="block">/*
         * pre Ant 1.6 this method used to call getClass().getResource
         * while Ant 1.6 will call ClassLoader.getResource().
         *
         * The difference is that Class.getResource expects a leading
         * slash for "absolute" resources and will strip it before
         * delegating to ClassLoader.getResource - so we now have to
         * emulate Class's behavior.
         */</comment>
        <if>if <condition>(<expr><call><name><name>resource</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"/"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>resource</name> = <call><name><name>resource</name>.<name>substring</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>resource</name> = "org/apache/tools/ant/taskdefs/optional/junit/"
                + <name>resource</name></expr>;</expr_stmt>
        }</block></else></if>

        <decl_stmt><decl><type><name>File</name></type> <name>f</name> =<init> <expr><call><name><name>LoaderUtils</name>.<name>getResourceSource</name></name><argument_list>(<argument><expr><name><name>JUnitTask</name>.<name><name/></name></name>class.<call><name>getClassLoader</name><argument_list>()</argument_list></call></expr></argument>,
                                               <argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>f</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Found " + <call><name><name>f</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_DEBUG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>antRuntimeClasses</name>.<name>createPath</name></name><argument_list>()</argument_list></call>.<call><name>setLocation</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>true</expr>;</return>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Couldn\'t find " + <name>resource</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_DEBUG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>false</expr>;</return>
        }</block></else></if>
    }</block></function>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>TIMEOUT_MESSAGE</name> =<init> 
        <expr>"Timeout occurred. Please note the time in the report does"
        + " not reflect the time until the timeout."</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Take care that some output is produced in report files if the
     * watchdog kills the test.
     *
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>logTimeout</name><parameter_list>(<param><decl><type><name><name>FormatterElement</name><index>[]</index></name></type> <name>feArray</name></decl></param>, <param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>,
                            <param><decl><type><name>String</name></type> <name>testCase</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>logVmExit</name><argument_list>(<argument><expr><name>feArray</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>TIMEOUT_MESSAGE</name></expr></argument>, <argument><expr><name>testCase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Take care that some output is produced in report files if the
     * forked machine exited before the test suite finished but the
     * reason is not a timeout.
     *
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>logVmCrash</name><parameter_list>(<param><decl><type><name><name>FormatterElement</name><index>[]</index></name></type> <name>feArray</name></decl></param>, <param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>, <param><decl><type><name>String</name></type> <name>testCase</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>logVmExit</name><argument_list>(
            <argument><expr><name>feArray</name></expr></argument>, <argument><expr><name>test</name></expr></argument>,
            <argument><expr>"Forked Java VM exited abnormally. Please note the time in the report"
            + " does not reflect the time until the VM exit."</expr></argument>,
            <argument><expr><name>testCase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Take care that some output is produced in report files if the
     * forked machine terminated before the test suite finished
     *
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>logVmExit</name><parameter_list>(<param><decl><type><name><name>FormatterElement</name><index>[]</index></name></type> <name>feArray</name></decl></param>, <param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>,
                           <param><decl><type><name>String</name></type> <name>message</name></decl></param>, <param><decl><type><name>String</name></type> <name>testCase</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>delegate</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>setupJUnitDelegate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <try>try <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Using System properties " + <call><name><name>System</name>.<name>getProperties</name></name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>splitJUnit</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>classLoader</name> = (<name>AntClassLoader</name>) <call><name><name>delegate</name>.<name>getClass</name></name><argument_list>()</argument_list></call>.<call><name>getClassLoader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>createClassLoader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <if>if <condition>(<expr><name>classLoader</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>classLoader</name>.<name>setThreadContextLoader</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name><name>test</name>.<name>setCounts</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>test</name>.<name>setProperties</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperties</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>feArray</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>FormatterElement</name></type> <name>fe</name> =<init> <expr><name><name>feArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>fe</name>.<name>shouldUse</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name><name>JUnitTaskMirror</name>.<name>JUnitResultFormatterMirror</name></name></type> <name>formatter</name> =<init>
                        <expr><call><name><name>fe</name>.<name>createFormatter</name></name><argument_list>(<argument><expr><name>classLoader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>formatter</name> != <name>null</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>OutputStream</name></type> <name>out</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>File</name></type> <name>outFile</name> =<init> <expr><call><name>getOutput</name><argument_list>(<argument><expr><name>fe</name></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>outFile</name> != <name>null</name></expr>)</condition><then> <block>{
                            <try>try <block>{
                                <expr_stmt><expr><name>out</name> = new <call><name>FileOutputStream</name><argument_list>(<argument><expr><name>outFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>) <block>{
                                <comment type="line">// ignore</comment>
                            }</block></catch></try>
                        }</block></then></if>
                        <if>if <condition>(<expr><name>out</name> == <name>null</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>out</name> = <call><name>getDefaultOutput</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                        <expr_stmt><expr><call><name><name>delegate</name>.<name>addVmExit</name></name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name>formatter</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>message</name></expr></argument>,
                                           <argument><expr><name>testCase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>summary</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name><name>JUnitTaskMirror</name>.<name>SummaryJUnitResultFormatterMirror</name></name></type> <name>f</name> =<init>
                    <expr><call><name><name>delegate</name>.<name>newSummaryJUnitResultFormatter</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>f</name>.<name>setWithOutAndErr</name></name><argument_list>(<argument><expr><call><name>equalsWithOutAndErr</name><argument_list>(<argument><expr><name>summaryValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>delegate</name>.<name>addVmExit</name></name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>getDefaultOutput</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>testCase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block> <finally>finally <block>{
            <if>if <condition>(<expr><name>classLoader</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>classLoader</name>.<name>resetThreadContextLoader</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * Creates and configures an AntClassLoader instance from the
     * nested classpath element.
     *
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>createClassLoader</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>Path</name></type> <name>userClasspath</name> =<init> <expr><call><name>getCommandline</name><argument_list>()</argument_list></call>.<call><name>getClasspath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>userClasspath</name> != <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>reloading</name> || <name>classLoader</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>deleteClassLoader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>Path</name></type> <name>classpath</name> =<init> <expr>(<name>Path</name>) <call><name><name>userClasspath</name>.<name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>includeAntRuntime</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Implicitly adding " + <name>antRuntimeClasses</name>
                        + " to CLASSPATH"</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>classpath</name>.<name>append</name></name><argument_list>(<argument><expr><name>antRuntimeClasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>classLoader</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>createClassLoader</name><argument_list>(<argument><expr><name>classpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>getClass</name><argument_list>()</argument_list></call>.<call><name>getClassLoader</name><argument_list>()</argument_list></call> != <name>null</name>
                    &amp;&amp; <call><name>getClass</name><argument_list>()</argument_list></call>.<call><name>getClassLoader</name><argument_list>()</argument_list></call> != <name><name>Project</name>.<name><name/></name></name>class.<call><name>getClassLoader</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>classLoader</name>.<name>setParent</name></name><argument_list>(<argument><expr><call><name>getClass</name><argument_list>()</argument_list></call>.<call><name>getClassLoader</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>classLoader</name>.<name>setParentFirst</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>classLoader</name>.<name>addJavaLibraries</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Using CLASSPATH " + <call><name><name>classLoader</name>.<name>getClasspath</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// make sure the test will be accepted as a TestCase</comment>
                <expr_stmt><expr><call><name><name>classLoader</name>.<name>addSystemPackageRoot</name></name><argument_list>(<argument><expr>"junit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// make sure the test annotation are accepted</comment>
                <expr_stmt><expr><call><name><name>classLoader</name>.<name>addSystemPackageRoot</name></name><argument_list>(<argument><expr>"org.junit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// will cause trouble in JDK 1.1 if omitted</comment>
                <expr_stmt><expr><call><name><name>classLoader</name>.<name>addSystemPackageRoot</name></name><argument_list>(<argument><expr>"org.apache.tools.ant"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Removes resources.
     *
     * &lt;p&gt;Is invoked in {@link #execute execute}.  Subclasses that
     * don't invoke execute should invoke this method in a finally
     * block.&lt;/p&gt;
     *
     * @since Ant 1.7.1
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>cleanup</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>deleteClassLoader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>delegate</name> = <name>null</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Removes a classloader if needed.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>deleteClassLoader</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>classLoader</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>classLoader</name>.<name>cleanup</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>classLoader</name> = <name>null</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>mirrorLoader</name> <name>instanceof</name> <name>SplitClassLoader</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>((<name>SplitClassLoader</name>) <name>mirrorLoader</name>).<call><name>cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>mirrorLoader</name> = <name>null</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Get the command line used to run the tests.
     * @return the command line.
     * @since Ant 1.6.2
     */</comment>
    <function><type><specifier>protected</specifier> <name>CommandlineJava</name></type> <name>getCommandline</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>commandline</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>commandline</name> = new <call><name>CommandlineJava</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>commandline</name>.<name>setClassname</name></name><argument_list>(<argument><expr>"org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>commandline</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Forked test support
     * @since Ant 1.6.2
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>ForkedTestConfiguration</name> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>filterTrace</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>haltOnError</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>haltOnFailure</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>errorProperty</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>failureProperty</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * constructor for forked test configuration
         * @param filterTrace
         * @param haltOnError
         * @param haltOnFailure
         * @param errorProperty
         * @param failureProperty
         */</comment>
        <constructor><name>ForkedTestConfiguration</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>filterTrace</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>haltOnError</name></decl></param>,
                                <param><decl><type><name>boolean</name></type> <name>haltOnFailure</name></decl></param>, <param><decl><type><name>String</name></type> <name>errorProperty</name></decl></param>,
                                <param><decl><type><name>String</name></type> <name>failureProperty</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>filterTrace</name></name> = <name>filterTrace</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>haltOnError</name></name> = <name>haltOnError</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>haltOnFailure</name></name> = <name>haltOnFailure</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>errorProperty</name></name> = <name>errorProperty</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>failureProperty</name></name> = <name>failureProperty</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * configure from a test; sets member variables to attributes of the test
         * @param test
         */</comment>
        <constructor><name>ForkedTestConfiguration</name><parameter_list>(<param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><call><name><name>test</name>.<name>getFiltertrace</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>test</name>.<name>getHaltonerror</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>test</name>.<name>getHaltonfailure</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>test</name>.<name>getErrorProperty</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>test</name>.<name>getFailureProperty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * equality test checks all the member variables
         * @param other
         * @return true if everything is equal
         */</comment>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>other</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr><name>other</name> == <name>null</name>
                || <call><name><name>other</name>.<name>getClass</name></name><argument_list>()</argument_list></call> != <name><name>ForkedTestConfiguration</name>.<name><name/></name></name>class</expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
            <decl_stmt><decl><type><name>ForkedTestConfiguration</name></type> <name>o</name> =<init> <expr>(<name>ForkedTestConfiguration</name>) <name>other</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><name>filterTrace</name> == <name><name>o</name>.<name>filterTrace</name></name>
                &amp;&amp; <name>haltOnError</name> == <name><name>o</name>.<name>haltOnError</name></name>
                &amp;&amp; <name>haltOnFailure</name> == <name><name>o</name>.<name>haltOnFailure</name></name>
                &amp;&amp; ((<name>errorProperty</name> == <name>null</name> &amp;&amp; <name><name>o</name>.<name>errorProperty</name></name> == <name>null</name>)
                    ||
                    (<name>errorProperty</name> != <name>null</name>
                     &amp;&amp; <call><name><name>errorProperty</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>o</name>.<name>errorProperty</name></name></expr></argument>)</argument_list></call>))
                &amp;&amp; ((<name>failureProperty</name> == <name>null</name> &amp;&amp; <name><name>o</name>.<name>failureProperty</name></name> == <name>null</name>)
                    ||
                    (<name>failureProperty</name> != <name>null</name>
                     &amp;&amp; <call><name><name>failureProperty</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>o</name>.<name>failureProperty</name></name></expr></argument>)</argument_list></call>))</expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * hashcode is based only on the boolean members, and returns a value
         * in the range 0-7.
         * @return hash code value
         */</comment>
        <function><type><specifier>public</specifier> <name>int</name></type> <name>hashCode</name><parameter_list>()</parameter_list> <block>{
            <comment type="line">// CheckStyle:MagicNumber OFF</comment>
            <return>return <expr>(<name>filterTrace</name> ? 1 : 0)
                + (<name>haltOnError</name> ? 2 : 0)
                + (<name>haltOnFailure</name> ? 4 : 0)</expr>;</return>
            <comment type="line">// CheckStyle:MagicNumber ON</comment>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * These are the different forking options
     * @since 1.6.2
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>ForkMode</name> <super><extends>extends <name>EnumeratedAttribute</name></extends></super> <block>{

        <comment type="javadoc">/**
         * fork once only
         */</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ONCE</name> =<init> <expr>"once"</expr></init></decl>;</decl_stmt>
        <comment type="javadoc">/**
         * fork once per test class
         */</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>PER_TEST</name> =<init> <expr>"perTest"</expr></init></decl>;</decl_stmt>
        <comment type="javadoc">/**
         * fork once per batch of tests
         */</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>PER_BATCH</name> =<init> <expr>"perBatch"</expr></init></decl>;</decl_stmt>

        <comment type="javadoc">/** No arg constructor. */</comment>
        <constructor><specifier>public</specifier> <name>ForkMode</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Constructor using a value.
         * @param value the value to use - once, perTest or perBatch.
         */</comment>
        <constructor><specifier>public</specifier> <name>ForkMode</name><parameter_list>(<param><decl><type><name>String</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setValue</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/** {@inheritDoc}. */</comment>
        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getValues</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><name>ONCE</name></expr>, <expr><name>PER_TEST</name></expr>, <expr><name>PER_BATCH</name></expr>}</block></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Executes all tests that don't need to be forked (or all tests
     * if the runIndividual argument is true.  Returns a collection of
     * lists of tests that share the same VM configuration and haven't
     * been executed yet.
     * @param testList the list of tests to be executed or queued.
     * @param runIndividual if true execute each test individually.
     * @return a list of tasks to be executed.
     * @since 1.6.2
     */</comment>
    <function><type><specifier>protected</specifier> <name>Collection</name></type> <name>executeOrQueue</name><parameter_list>(<param><decl><type><name>Enumeration</name></type> <name>testList</name></decl></param>,
                                        <param><decl><type><name>boolean</name></type> <name>runIndividual</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Map</name></type> <name>testConfigurations</name> =<init> <expr>new <call><name>HashMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>testList</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>JUnitTest</name></type> <name>test</name> =<init> <expr>(<name>JUnitTest</name>) <call><name><name>testList</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>test</name>.<name>shouldRun</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>runIndividual</name> || !<call><name><name>test</name>.<name>getFork</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>execute</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <decl_stmt><decl><type><name>ForkedTestConfiguration</name></type> <name>c</name> =<init>
                        <expr>new <call><name>ForkedTestConfiguration</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>List</name></type> <name>l</name> =<init> <expr>(<name>List</name>) <call><name><name>testConfigurations</name>.<name>get</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>l</name> == <name>null</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>l</name> = new <call><name>ArrayList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>testConfigurations</name>.<name>put</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><call><name><name>l</name>.<name>add</name></name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if>
        }</block></while>
        <return>return <expr><call><name><name>testConfigurations</name>.<name>values</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Logs information about failed tests, potentially stops
     * processing (by throwing a BuildException) if a failure/error
     * occurred or sets a property.
     * @param exitValue the exitValue of the test.
     * @param wasKilled if true, the test had been killed.
     * @param test      the test in question.
     * @param name      the name of the test.
     * @since Ant 1.6.2
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>actOnTestResult</name><parameter_list>(<param><decl><type><name>int</name></type> <name>exitValue</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>wasKilled</name></decl></param>,
                                   <param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>, <param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>TestResultHolder</name></type> <name>t</name> =<init> <expr>new <call><name>TestResultHolder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>t</name>.<name>exitCode</name></name> = <name>exitValue</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>t</name>.<name>timedOut</name></name> = <name>wasKilled</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>actOnTestResult</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Logs information about failed tests, potentially stops
     * processing (by throwing a BuildException) if a failure/error
     * occurred or sets a property.
     * @param result    the result of the test.
     * @param test      the test in question.
     * @param name      the name of the test.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>actOnTestResult</name><parameter_list>(<param><decl><type><name>TestResultHolder</name></type> <name>result</name></decl></param>, <param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>,
                                   <param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// if there is an error/failure and that it should halt, stop</comment>
        <comment type="line">// everything otherwise just log a statement</comment>
        <decl_stmt><decl><type><name>boolean</name></type> <name>fatal</name> =<init> <expr><name><name>result</name>.<name>timedOut</name></name> || <name><name>result</name>.<name>crashed</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>errorOccurredHere</name> =<init>
            <expr><name><name>result</name>.<name>exitCode</name></name> == <name><name>JUnitTaskMirror</name>.<name>JUnitTestRunnerMirror</name>.<name>ERRORS</name></name> || <name>fatal</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>failureOccurredHere</name> =<init>
            <expr><name><name>result</name>.<name>exitCode</name></name> != <name><name>JUnitTaskMirror</name>.<name>JUnitTestRunnerMirror</name>.<name>SUCCESS</name></name> || <name>fatal</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>errorOccurredHere</name> || <name>failureOccurredHere</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>(<name>errorOccurredHere</name> &amp;&amp; <call><name><name>test</name>.<name>getHaltonerror</name></name><argument_list>()</argument_list></call>)
                || (<name>failureOccurredHere</name> &amp;&amp; <call><name><name>test</name>.<name>getHaltonfailure</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>name</name> + " failed"
                    + (<name><name>result</name>.<name>timedOut</name></name> ? " (timeout)" : "")
                    + (<name><name>result</name>.<name>crashed</name></name> ? " (crashed)" : "")</expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><name>logFailedTests</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>name</name> + " FAILED"
                        + (<name><name>result</name>.<name>timedOut</name></name> ? " (timeout)" : "")
                        + (<name><name>result</name>.<name>crashed</name></name> ? " (crashed)" : "")</expr></argument>,
                        <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>errorOccurredHere</name> &amp;&amp; <call><name><name>test</name>.<name>getErrorProperty</name></name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>setNewProperty</name><argument_list>(<argument><expr><call><name><name>test</name>.<name>getErrorProperty</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>failureOccurredHere</name> &amp;&amp; <call><name><name>test</name>.<name>getFailureProperty</name></name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>setNewProperty</name><argument_list>(<argument><expr><call><name><name>test</name>.<name>getFailureProperty</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * A value class that contains the result of a test.
     */</comment>
    <class><specifier>protected</specifier> <specifier>static</specifier> class <name>TestResultHolder</name> <block>{
        <comment type="line">// CheckStyle:VisibilityModifier OFF - bc</comment>
        <comment type="javadoc">/** the exit code of the test. */</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <name>int</name></type> <name>exitCode</name> =<init> <expr><name><name>JUnitTaskMirror</name>.<name>JUnitTestRunnerMirror</name>.<name>ERRORS</name></name></expr></init></decl>;</decl_stmt>
        <comment type="javadoc">/** true if the test timed out */</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <name>boolean</name></type> <name>timedOut</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <comment type="javadoc">/** true if the test crashed */</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <name>boolean</name></type> <name>crashed</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <comment type="line">// CheckStyle:VisibilityModifier ON</comment>
    }</block></class>

    <comment type="javadoc">/**
     * A stream handler for handling the junit task.
     * @since Ant 1.7
     */</comment>
    <class><specifier>protected</specifier> <specifier>static</specifier> class <name>JUnitLogOutputStream</name> <super><extends>extends <name>LogOutputStream</name></extends></super> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <name>Task</name></type> <name>task</name></decl>;</decl_stmt> <comment type="line">// local copy since LogOutputStream.task is private</comment>

        <comment type="javadoc">/**
         * Constructor.
         * @param task the task being logged.
         * @param level the log level used to log data written to this stream.
         */</comment>
        <constructor><specifier>public</specifier> <name>JUnitLogOutputStream</name><parameter_list>(<param><decl><type><name>Task</name></type> <name>task</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>task</name></name> = <name>task</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Logs a line.
         * If the line starts with junit.framework.TestListener: set the level
         * to MSG_VERBOSE.
         * @param line the line to log.
         * @param level the logging level to use.
         */</comment>
        <function><type><specifier>protected</specifier> <name>void</name></type> <name>processLine</name><parameter_list>(<param><decl><type><name>String</name></type> <name>line</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr><call><name><name>line</name>.<name>startsWith</name></name><argument_list>(<argument><expr><name>TESTLISTENER_PREFIX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>task</name>.<name>log</name></name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>super</name>.<name>processLine</name></name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * A log stream handler for junit.
     * @since Ant 1.7
     */</comment>
    <class><specifier>protected</specifier> <specifier>static</specifier> class <name>JUnitLogStreamHandler</name> <super><extends>extends <name>PumpStreamHandler</name></extends></super> <block>{
        <comment type="javadoc">/**
         * Constructor.
         * @param task the task to log.
         * @param outlevel the level to use for standard output.
         * @param errlevel the level to use for error output.
         */</comment>
        <constructor><specifier>public</specifier> <name>JUnitLogStreamHandler</name><parameter_list>(<param><decl><type><name>Task</name></type> <name>task</name></decl></param>, <param><decl><type><name>int</name></type> <name>outlevel</name></decl></param>, <param><decl><type><name>int</name></type> <name>errlevel</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr>new <call><name>JUnitLogOutputStream</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>outlevel</name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr>new <call><name>LogOutputStream</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>errlevel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>
    }</block></class>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>NAME_OF_DUMMY_TEST</name> =<init> <expr>"Batch-With-Multiple-Tests"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Creates a JUnitTest instance that shares all flags with the
     * passed in instance but has a more meaningful name.
     *
     * &lt;p&gt;If a VM running multiple tests crashes, we don't know which
     * test failed.  Prior to Ant 1.8.0 Ant would log the error with
     * the last test of the batch test, which caused some confusion
     * since the log might look as if a test had been executed last
     * that was never started.  With Ant 1.8.0 the test's name will
     * indicate that something went wrong with a test inside the batch
     * without giving it a real name.&lt;/p&gt;
     *
     * @see https://issues.apache.org/bugzilla/show_bug.cgi?id=45227
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>JUnitTest</name></type> <name>createDummyTestForBatchTest</name><parameter_list>(<param><decl><type><name>JUnitTest</name></type> <name>test</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>JUnitTest</name></type> <name>t</name> =<init> <expr>(<name>JUnitTest</name>) <call><name><name>test</name>.<name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> =<init> <expr><call><name><name>test</name>.<name>getName</name></name><argument_list>()</argument_list></call>.<call><name>lastIndexOf</name><argument_list>(<argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// make sure test looks as if it was in the same "package" as</comment>
        <comment type="line">// the last test of the batch</comment>
        <decl_stmt><decl><type><name>String</name></type> <name>pack</name> =<init> <expr><name>index</name> &gt; 0 ? <call><name><name>test</name>.<name>getName</name></name><argument_list>()</argument_list></call>.<call><name>substring</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>index</name> + 1</expr></argument>)</argument_list></call> : ""</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>t</name>.<name>setName</name></name><argument_list>(<argument><expr><name>pack</name> + <name>NAME_OF_DUMMY_TEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>t</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>printDual</name><parameter_list>(<param><decl><type><name>BufferedWriter</name></type> <name>w</name></decl></param>, <param><decl><type><name>PrintStream</name></type> <name>s</name></decl></param>, <param><decl><type><name>String</name></type> <name>text</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name><name>w</name>.<name>write</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>s</name>.<name>print</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>printlnDual</name><parameter_list>(<param><decl><type><name>BufferedWriter</name></type> <name>w</name></decl></param>, <param><decl><type><name>PrintStream</name></type> <name>s</name></decl></param>, <param><decl><type><name>String</name></type> <name>text</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name><name>w</name>.<name>write</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>w</name>.<name>newLine</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>s</name>.<name>println</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>
}</block></class>
</unit>
