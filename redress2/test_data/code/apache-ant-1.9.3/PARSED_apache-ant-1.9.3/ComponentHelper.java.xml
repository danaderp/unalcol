<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\ComponentHelper.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>InputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>PrintWriter</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>StringWriter</name></name>;</import>
<import>import <name><name>java</name>.<name>lang</name>.<name>reflect</name>.<name>InvocationTargetException</name></name>;</import>
<import>import <name><name>java</name>.<name>lang</name>.<name>reflect</name>.<name>Modifier</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Enumeration</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashMap</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashSet</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Hashtable</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Iterator</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Properties</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Set</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Stack</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>launch</name>.<name>Launcher</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>Definer</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>Typedef</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileUtils</name></name>;</import>

<comment type="javadoc">/**
 * Component creation and configuration.
 *
 * The class is based around handing component
 * definitions in an AntTypeTable.
 *
 * The old task/type methods have been kept
 * for backward compatibly.
 * Project will just delegate its calls to this class.
 *
 * A very simple hook mechanism is provided that allows users to plug
 * in custom code. It is also possible to replace the default behavior
 * ( for example in an app embedding ant )
 *
 * @since Ant1.6
 */</comment>
<class><specifier>public</specifier> class <name>ComponentHelper</name>  <block>{
    <comment type="javadoc">/** Map of component name to lists of restricted definitions */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type>          <name>restrictedDefinitions</name> =<init> <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** Map from component name to anttypedefinition */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>antTypeTable</name> =<init> <expr>new <call><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** Map of tasks generated from antTypeTable */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>taskClassDefinitions</name> =<init> <expr>new <call><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** flag to rebuild taskClassDefinitions */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>rebuildTaskClassDefinitions</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** Map of types generated from antTypeTable */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>typeClassDefinitions</name> =<init> <expr>new <call><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** flag to rebuild typeClassDefinitions */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>rebuildTypeClassDefinitions</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** Set of namespaces that have been checked for antlibs */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>HashSet</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>checkedNamespaces</name> =<init> <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Stack of antlib contexts used to resolve definitions while
     *   processing antlib
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Stack</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>antLibStack</name> =<init> <expr>new <call><name><name>Stack</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** current antlib uri */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>antLibCurrentUri</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * this does not appear to be used anywhere in the Ant codebase
     * even via its accessors
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>ComponentHelper</name></type> <name>next</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Project that owns a component helper
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Project</name></type> <name>project</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Error string when the file taskdefs/defaults.properties cannot be found
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ERROR_NO_TASK_LIST_LOAD</name> =<init> <expr>"Can't load default task list"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Error string when the typedefs/defaults.properties cannot be found
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ERROR_NO_TYPE_LIST_LOAD</name> =<init> <expr>"Can't load default type list"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * reference under which we register ourselves with a project -{@value}
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>COMPONENT_HELPER_REFERENCE</name> =<init> <expr>"ant.ComponentHelper"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * string used to control build.syspath policy {@value}
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>BUILD_SYSCLASSPATH_ONLY</name> =<init> <expr>"only"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * special name of ant's property task -{@value}. There is some
     * contrived work here to enable this early.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ANT_PROPERTY_TASK</name> =<init> <expr>"property"</expr></init></decl>;</decl_stmt>

    <comment type="line">// {tasks, types}</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>Properties</name><index>[]</index></type> <name>defaultDefinitions</name> =<init> <expr>new <name><name>Properties</name><index>[<expr>2</expr>]</index></name></expr></init></decl>;</decl_stmt>

     <comment type="javadoc">/**
     * Get the project.
     * @return the project owner of this helper.
     */</comment>
     <function><type><specifier>public</specifier> <name>Project</name></type> <name>getProject</name><parameter_list>()</parameter_list> <block>{
         <return>return <expr><name>project</name></expr>;</return>
     }</block></function>

    <comment type="javadoc">/**
     * Find a project component for a specific project, creating
     * it if it does not exist.
     * @param project the project.
     * @return the project component for a specific project.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ComponentHelper</name></type> <name>getComponentHelper</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>project</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr><name>null</name></expr>;</return>
        }</block></then></if>
        <comment type="line">// Singleton for now, it may change ( per/classloader )</comment>
        <decl_stmt><decl><type><name>ComponentHelper</name></type> <name>ph</name> =<init> <expr>(<name>ComponentHelper</name>) <call><name><name>project</name>.<name>getReference</name></name><argument_list>(<argument><expr><name>COMPONENT_HELPER_REFERENCE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>ph</name> != <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr><name>ph</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>ph</name> = new <call><name>ComponentHelper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ph</name>.<name>setProject</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>project</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>COMPONENT_HELPER_REFERENCE</name></expr></argument>, <argument><expr><name>ph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ph</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a new ComponentHelper instance.
     */</comment>
    <constructor><specifier>protected</specifier> <name>ComponentHelper</name><parameter_list>()</parameter_list> <block>{
    }</block></constructor>

    <comment type="javadoc">/**
     * Set the next chained component helper.
     *
     * @param next the next chained component helper.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setNext</name><parameter_list>(<param><decl><type><name>ComponentHelper</name></type> <name>next</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>next</name></name> = <name>next</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Get the next chained component helper.
     *
     * @return the next chained component helper.
     */</comment>
    <function><type><specifier>public</specifier> <name>ComponentHelper</name></type> <name>getNext</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>next</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the project for this component helper.
     *
     * @param project the project for this helper.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setProject</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>project</name></name> = <name>project</name></expr>;</expr_stmt>
<comment type="line">//        antTypeTable = new Hashtable&lt;String, AntTypeDefinition&gt;(project);</comment>
    }</block></function>

    <comment type="javadoc">/**
     * @return A copy of the CheckedNamespace.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>synchronized</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getCheckedNamespace</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><annotation>@<name>SuppressWarnings</name><argument_list>("unchecked")</argument_list></annotation>
        <specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>result</name> =<init> <expr>(<name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name>) <call><name><name>checkedNamespaces</name>.<name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * @return A deep copy of the restrictredDefinition
     */</comment>
    <function><type><specifier>private</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getRestrictedDefinition</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>result</name> =<init> <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <synchronized>synchronized (<expr><name>restrictedDefinitions</name></expr>) <block>{
            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> :<range> <expr><call><name><name>restrictedDefinitions</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>entryVal</name> =<init> <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <synchronized>synchronized (<expr><name>entryVal</name></expr>) <block>{
                    <comment type="line">//copy the entryVal</comment>
                    <expr_stmt><expr><name>entryVal</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name> <argument_list>(<argument><expr><name>entryVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></synchronized>
                <expr_stmt><expr><call><name><name>result</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>entryVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></synchronized>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Used with creating child projects. Each child
     * project inherits the component definitions
     * from its parent.
     * @param helper the component helper of the parent project.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>initSubProject</name><parameter_list>(<param><decl><type><name>ComponentHelper</name></type> <name>helper</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// add the types of the parent project</comment>
        <decl_stmt><decl><type><annotation>@<name>SuppressWarnings</name><argument_list>("unchecked")</argument_list></annotation>
        <specifier>final</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>typeTable</name> =<init> <expr>(<name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name>) <call><name><name>helper</name>.<name>antTypeTable</name>.<name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <synchronized>synchronized (<expr><name>antTypeTable</name></expr>) <block>{
            <for>for (<init><decl><type><name>AntTypeDefinition</name></type> <name>def</name> :<range> <expr><call><name><name>typeTable</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                <expr_stmt><expr><call><name><name>antTypeTable</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>def</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></synchronized>
        <comment type="line">// add the parsed namespaces of the parent project</comment>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>inheritedCheckedNamespace</name> =<init> <expr><call><name><name>helper</name>.<name>getCheckedNamespace</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <synchronized>synchronized (<expr><name>this</name></expr>) <block>{
            <expr_stmt><expr><call><name><name>checkedNamespaces</name>.<name>addAll</name></name><argument_list>(<argument><expr><name>inheritedCheckedNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></synchronized>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>inheritedRestrictedDef</name> =<init> <expr><call><name><name>helper</name>.<name>getRestrictedDefinition</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <synchronized>synchronized (<expr><name>restrictedDefinitions</name></expr>) <block>{
            <expr_stmt><expr><call><name><name>restrictedDefinitions</name>.<name>putAll</name></name><argument_list>(<argument><expr><name>inheritedRestrictedDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></synchronized>
    }</block></function>

    <comment type="javadoc">/**
     * Factory method to create the components.
     *
     * This should be called by UnknownElement.
     *
     * @param ue The Unknown Element creating this component.
     * @param ns Namespace URI. Also available as ue.getNamespace().
     * @param componentType The component type,
     *                       Also available as ue.getComponentName().
     * @return the created component.
     * @throws BuildException if an error occurs.
     */</comment>
    <function><type><specifier>public</specifier> <name>Object</name></type> <name>createComponent</name><parameter_list>(<param><decl><type><name>UnknownElement</name></type> <name>ue</name></decl></param>, <param><decl><type><name>String</name></type> <name>ns</name></decl></param>, <param><decl><type><name>String</name></type> <name>componentType</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>Object</name></type> <name>component</name> =<init> <expr><call><name>createComponent</name><argument_list>(<argument><expr><name>componentType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>component</name> <name>instanceof</name> <name>Task</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>Task</name></type> <name>task</name> =<init> <expr>(<name>Task</name>) <name>component</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setLocation</name></name><argument_list>(<argument><expr><call><name><name>ue</name>.<name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setTaskType</name></name><argument_list>(<argument><expr><name>componentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setTaskName</name></name><argument_list>(<argument><expr><call><name><name>ue</name>.<name>getTaskName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setOwningTarget</name></name><argument_list>(<argument><expr><call><name><name>ue</name>.<name>getOwningTarget</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>component</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Create an object for a component.
     *
     * @param componentName the name of the component, if
     *                      the component is in a namespace, the
     *                      name is prefixed with the namespace uri and ":".
     * @return the class if found or null if not.
     */</comment>
    <function><type><specifier>public</specifier> <name>Object</name></type> <name>createComponent</name><parameter_list>(<param><decl><type><name>String</name></type> <name>componentName</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>AntTypeDefinition</name></type> <name>def</name> =<init> <expr><call><name>getDefinition</name><argument_list>(<argument><expr><name>componentName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>def</name> == <name>null</name> ? <name>null</name> : <call><name><name>def</name>.<name>create</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Return the class of the component name.
     *
     * @param componentName the name of the component, if
     *                      the component is in a namespace, the
     *                      name is prefixed with the namespace uri and ":".
     * @return the class if found or null if not.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>getComponentClass</name><parameter_list>(<param><decl><type><name>String</name></type> <name>componentName</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>AntTypeDefinition</name></type> <name>def</name> =<init> <expr><call><name>getDefinition</name><argument_list>(<argument><expr><name>componentName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>def</name> == <name>null</name> ? <name>null</name> : <call><name><name>def</name>.<name>getExposedClass</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Return the antTypeDefinition for a componentName.
     * @param componentName the name of the component.
     * @return the ant definition or null if not present.
     */</comment>
    <function><type><specifier>public</specifier> <name>AntTypeDefinition</name></type> <name>getDefinition</name><parameter_list>(<param><decl><type><name>String</name></type> <name>componentName</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>checkNamespace</name><argument_list>(<argument><expr><name>componentName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>antTypeTable</name>.<name>get</name></name><argument_list>(<argument><expr><name>componentName</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * This method is initialization code implementing the original ant component
     * loading from /org/apache/tools/ant/taskdefs/default.properties
     * and /org/apache/tools/ant/types/default.properties.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>initDefaultDefinitions</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>initTasks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initTypes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>new <call><name>DefaultDefinitions</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>.<call><name>execute</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a new task definition to the project.
     * Attempting to override an existing definition with an
     * equivalent one (i.e. with the same classname) results in
     * a verbose log message. Attempting to override an existing definition
     * with a different one results in a warning log message.
     *
     * @param taskName The name of the task to add.
     *                 Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param taskClass The full name of the class implementing the task.
     *                  Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception BuildException if the class is unsuitable for being an Ant
     *                           task. An error level message is logged before
     *                           this exception is thrown.
     *
     * @see #checkTaskClass(Class)
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addTaskDefinition</name><parameter_list>(<param><decl><type><name>String</name></type> <name>taskName</name></decl></param>, <param><decl><type><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>taskClass</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>checkTaskClass</name><argument_list>(<argument><expr><name>taskClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>AntTypeDefinition</name></type> <name>def</name> =<init> <expr>new <call><name>AntTypeDefinition</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>def</name>.<name>setName</name></name><argument_list>(<argument><expr><name>taskName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>def</name>.<name>setClassLoader</name></name><argument_list>(<argument><expr><call><name><name>taskClass</name>.<name>getClassLoader</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>def</name>.<name>setClass</name></name><argument_list>(<argument><expr><name>taskClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>def</name>.<name>setAdapterClass</name></name><argument_list>(<argument><expr><name><name>TaskAdapter</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>def</name>.<name>setClassName</name></name><argument_list>(<argument><expr><call><name><name>taskClass</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>def</name>.<name>setAdaptToClass</name></name><argument_list>(<argument><expr><name><name>Task</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>updateDataTypeDefinition</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Checks whether or not a class is suitable for serving as Ant task.
     * Ant task implementation classes must be public, concrete, and have
     * a no-arg constructor.
     *
     * @param taskClass The class to be checked.
     *                  Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception BuildException if the class is unsuitable for being an Ant
     *                           task. An error level message is logged before
     *                           this exception is thrown.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>checkTaskClass</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>taskClass</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr>!<call><name><name>Modifier</name>.<name>isPublic</name></name><argument_list>(<argument><expr><call><name><name>taskClass</name>.<name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name> =<init> <expr><name>taskClass</name> + " is not public"</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>Modifier</name>.<name>isAbstract</name></name><argument_list>(<argument><expr><call><name><name>taskClass</name>.<name>getModifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name> =<init> <expr><name>taskClass</name> + " is abstract"</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <try>try <block>{
            <expr_stmt><expr><call><name><name>taskClass</name>.<name>getConstructor</name></name><argument_list>(<argument><expr>(<name><name>Class</name><index>[]</index></name>) <name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// don't have to check for public, since</comment>
            <comment type="line">// getConstructor finds public constructors only.</comment>
        }</block> <catch>catch (<param><decl><type><name>NoSuchMethodException</name></type> <name>e</name></decl></param>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>message</name> =<init> <expr>"No public no-arg constructor in " + <name>taskClass</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <if>if <condition>(<expr>!<name><name>Task</name>.<name><name/></name></name>class.<call><name>isAssignableFrom</name><argument_list>(<argument><expr><name>taskClass</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>TaskAdapter</name>.<name>checkTaskClass</name></name><argument_list>(<argument><expr><name>taskClass</name></expr></argument>, <argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the current task definition hashtable. The returned hashtable is
     * "live" and so should not be modified.  Also, the returned table may be
     * modified asynchronously.
     *
     * @return a map of from task name to implementing class
     *         (String to Class).
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getTaskDefinitions</name><parameter_list>()</parameter_list> <block>{
        <synchronized>synchronized (<expr><name>taskClassDefinitions</name></expr>) <block>{
            <synchronized>synchronized (<expr><name>antTypeTable</name></expr>) <block>{
                <if>if <condition>(<expr><name>rebuildTaskClassDefinitions</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>taskClassDefinitions</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></name></type> <name>e</name> :<range> <expr><call><name><name>antTypeTable</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name> =<init> <expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>getExposedClass</name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>clazz</name> == <name>null</name></expr>)</condition><then> <block>{
                            <continue>continue;</continue>
                        }</block></then></if>
                        <if>if <condition>(<expr><name><name>Task</name>.<name><name/></name></name>class.<call><name>isAssignableFrom</name><argument_list>(<argument><expr><name>clazz</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>taskClassDefinitions</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>getTypeClass</name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></for>
                    <expr_stmt><expr><name>rebuildTaskClassDefinitions</name> = false</expr>;</expr_stmt>
                }</block></then></if>
            }</block></synchronized>
        }</block></synchronized>
        <return>return <expr><name>taskClassDefinitions</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the current type definition hashtable. The returned hashtable is
     * "live" and so should not be modified.
     *
     * @return a map of from type name to implementing class
     *         (String to Class).
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getDataTypeDefinitions</name><parameter_list>()</parameter_list> <block>{
        <synchronized>synchronized (<expr><name>typeClassDefinitions</name></expr>) <block>{
            <synchronized>synchronized (<expr><name>antTypeTable</name></expr>) <block>{
                <if>if <condition>(<expr><name>rebuildTypeClassDefinitions</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>typeClassDefinitions</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></name></type> <name>e</name> :<range> <expr><call><name><name>antTypeTable</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name> =<init> <expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>getExposedClass</name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>clazz</name> == <name>null</name></expr>)</condition><then> <block>{
                            <continue>continue;</continue>
                        }</block></then></if>
                        <if>if <condition>(<expr>!<name><name>Task</name>.<name><name/></name></name>class.<call><name>isAssignableFrom</name><argument_list>(<argument><expr><name>clazz</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>typeClassDefinitions</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>getTypeClass</name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></for>
                    <expr_stmt><expr><name>rebuildTypeClassDefinitions</name> = false</expr>;</expr_stmt>
                }</block></then></if>
            }</block></synchronized>
        }</block></synchronized>
        <return>return <expr><name>typeClassDefinitions</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * This returns a list of restricted definitions for a name.
     * The returned List is "live" and so should not be modified.
     * Also, the returned list may be modified asynchronously.
     * Any access must be guarded with a lock on the list itself.
     *
     * @param componentName the name to use.
     * @return the list of restricted definitions for a particular name.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>getRestrictedDefinitions</name><parameter_list>(<param><decl><type><name>String</name></type> <name>componentName</name></decl></param>)</parameter_list> <block>{
        <synchronized>synchronized (<expr><name>restrictedDefinitions</name></expr>) <block>{
            <return>return <expr><call><name><name>restrictedDefinitions</name>.<name>get</name></name><argument_list>(<argument><expr><name>componentName</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></synchronized>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a new datatype definition.
     * Attempting to override an existing definition with an
     * equivalent one (i.e. with the same classname) results in
     * a verbose log message. Attempting to override an existing definition
     * with a different one results in a warning log message, but the
     * definition is changed.
     *
     * @param typeName The name of the datatype.
     *                 Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param typeClass The full name of the class implementing the datatype.
     *                  Must not be &lt;code&gt;null&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addDataTypeDefinition</name><parameter_list>(<param><decl><type><name>String</name></type> <name>typeName</name></decl></param>, <param><decl><type><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>typeClass</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>AntTypeDefinition</name></type> <name>def</name> =<init> <expr>new <call><name>AntTypeDefinition</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>def</name>.<name>setName</name></name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>def</name>.<name>setClass</name></name><argument_list>(<argument><expr><name>typeClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>updateDataTypeDefinition</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr>" +User datatype: " + <name>typeName</name> + "     " + <call><name><name>typeClass</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><name><name>Project</name>.<name>MSG_DEBUG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Describe &lt;code&gt;addDataTypeDefinition&lt;/code&gt; method here.
     *
     * @param def an &lt;code&gt;AntTypeDefinition&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addDataTypeDefinition</name><parameter_list>(<param><decl><type><name>AntTypeDefinition</name></type> <name>def</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr>!<call><name><name>def</name>.<name>isRestrict</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
           <expr_stmt><expr><call><name>updateDataTypeDefinition</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>updateRestrictedDefinition</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the current datatype definition hashtable. The returned
     * hashtable is "live" and so should not be modified.
     *
     * @return a map of from datatype name to datatype definition
     *         (String to {@link AntTypeDefinition}).
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>getAntTypeTable</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>antTypeTable</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a new instance of a task.
     *
     *  Called from Project.createTask(), which can be called by tasks.
     *
     * @param taskType The name of the task to create an instance of.
     *                 Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an instance of the specified task, or &lt;code&gt;null&lt;/code&gt; if
     *         the task name is not recognised.
     *
     * @exception BuildException if the task name is recognised but task
     *                           creation fails.
     */</comment>
    <function><type><specifier>public</specifier> <name>Task</name></type> <name>createTask</name><parameter_list>(<param><decl><type><name>String</name></type> <name>taskType</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>Task</name></type> <name>task</name> =<init> <expr><call><name>createNewTask</name><argument_list>(<argument><expr><name>taskType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>task</name> == <name>null</name> &amp;&amp; <call><name><name>taskType</name>.<name>equals</name></name><argument_list>(<argument><expr><name>ANT_PROPERTY_TASK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// quick fix for Ant.java use of property before</comment>
            <comment type="line">// initializing the project</comment>
            <expr_stmt><expr><call><name>addTaskDefinition</name><argument_list>(<argument><expr><name>ANT_PROPERTY_TASK</name></expr></argument>, <argument><expr><name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>Property</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>task</name> = <call><name>createNewTask</name><argument_list>(<argument><expr><name>taskType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>task</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a new instance of a task.
     * @since ant1.6
     * @param taskType The name of the task to create an instance of.
     *                 Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an instance of the specified task, or &lt;code&gt;null&lt;/code&gt; if
     *         the task name is not recognised.
     *
     * @exception BuildException if the task name is recognised but task
     *                           creation fails.
     */</comment>
    <function><type><specifier>private</specifier> <name>Task</name></type> <name>createNewTask</name><parameter_list>(<param><decl><type><name>String</name></type> <name>taskType</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>c</name> =<init> <expr><call><name>getComponentClass</name><argument_list>(<argument><expr><name>taskType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>c</name> == <name>null</name> || !(<name><name>Task</name>.<name><name/></name></name>class.<call><name>isAssignableFrom</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <return>return <expr><name>null</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>Object</name></type> <name>obj</name> =<init> <expr><call><name>createComponent</name><argument_list>(<argument><expr><name>taskType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>obj</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr><name>null</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!(<name>obj</name> <name>instanceof</name> <name>Task</name>)</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Expected a Task from '" + <name>taskType</name>
                    + "' but got an instance of " + <call><name><name>obj</name>.<name>getClass</name></name><argument_list>()</argument_list></call>.<call><name>getName</name><argument_list>()</argument_list></call> + " instead"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>Task</name></type> <name>task</name> =<init> <expr>(<name>Task</name>) <name>obj</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>task</name>.<name>setTaskType</name></name><argument_list>(<argument><expr><name>taskType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// set default value, can be changed by the user</comment>
        <expr_stmt><expr><call><name><name>task</name>.<name>setTaskName</name></name><argument_list>(<argument><expr><name>taskType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr>"   +Task: " + <name>taskType</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_DEBUG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>task</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a new instance of a data type.
     *
     * @param typeName The name of the data type to create an instance of.
     *                 Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an instance of the specified data type, or &lt;code&gt;null&lt;/code&gt; if
     *         the data type name is not recognised.
     *
     * @exception BuildException if the data type name is recognised but
     *                           instance creation fails.
     */</comment>
    <function><type><specifier>public</specifier> <name>Object</name></type> <name>createDataType</name><parameter_list>(<param><decl><type><name>String</name></type> <name>typeName</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <return>return <expr><call><name>createComponent</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns a description of the type of the given element.
     * &lt;p&gt;
     * This is useful for logging purposes.
     *
     * @param element The element to describe.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return a description of the element type.
     *
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getElementName</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>element</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>getElementName</name><argument_list>(<argument><expr><name>element</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns a description of the type of the given element.
     * &lt;p&gt;
     * This is useful for logging purposes.
     *
     * @param o     The element to describe.
     *              Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param brief whether to use a brief description.
     * @return a description of the element type.
     *
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getElementName</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>o</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>brief</name></decl></param>)</parameter_list> <block>{
        <comment type="line">//  PR: I do not know what to do if the object class</comment>
        <comment type="line">//      has multiple defines</comment>
        <comment type="line">//      but this is for logging only...</comment>
        <decl_stmt><decl><type><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>elementClass</name> =<init> <expr><call><name><name>o</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>elementClassname</name> =<init> <expr><call><name><name>elementClass</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <synchronized>synchronized (<expr><name>antTypeTable</name></expr>) <block>{
            <for>for (<init><decl><type><name>AntTypeDefinition</name></type> <name>def</name> :<range> <expr><call><name><name>antTypeTable</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                <if>if <condition>(<expr><call><name><name>elementClassname</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>def</name>.<name>getClassName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                        &amp;&amp; (<name>elementClass</name> == <call><name><name>def</name>.<name>getExposedClass</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><call><name><name>def</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <return>return <expr><name>brief</name> ? <name>name</name> : "The &lt;" + <name>name</name> + "&gt; type"</expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></synchronized>
        <return>return <expr><call><name>getUnmappedElementName</name><argument_list>(<argument><expr><call><name><name>o</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>brief</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Convenient way to get some element name even when you may not have a
     * Project context.
     * @param p       The optional Project instance.
     * @param o       The element to describe.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param brief   whether to use a brief description.
     * @return a description of the element type.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getElementName</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>p</name></decl></param>, <param><decl><type><name>Object</name></type> <name>o</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>brief</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>p</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>p</name> = <call><name><name>Project</name>.<name>getProject</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>p</name> == <name>null</name> ? <call><name>getUnmappedElementName</name><argument_list>(<argument><expr><call><name><name>o</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>brief</name></expr></argument>)</argument_list></call> : <call><name>getComponentHelper</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>
                .<call><name>getElementName</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>brief</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>getUnmappedElementName</name><parameter_list>(<param><decl><type><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>c</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>brief</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>brief</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><call><name><name>c</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>name</name>.<name>substring</name></name><argument_list>(<argument><expr><call><name><name>name</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr>'.'</expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>c</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Check if definition is a valid definition--it may be a
     * definition of an optional task that does not exist.
     * @param def the definition to test.
     * @return true if exposed type of definition is present.
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>validDefinition</name><parameter_list>(<param><decl><type><name>AntTypeDefinition</name></type> <name>def</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>!(<call><name><name>def</name>.<name>getTypeClass</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call> == <name>null</name> || <call><name><name>def</name>.<name>getExposedClass</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call> == <name>null</name>)</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Check if two definitions are the same.
     * @param def  the new definition.
     * @param old the old definition.
     * @return true if the two definitions are the same.
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>sameDefinition</name><parameter_list>(<param><decl><type><name>AntTypeDefinition</name></type> <name>def</name></decl></param>, <param><decl><type><name>AntTypeDefinition</name></type> <name>old</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>defValid</name> =<init> <expr><call><name>validDefinition</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>sameValidity</name> =<init> <expr>(<name>defValid</name> == <call><name>validDefinition</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
        <comment type="line">//must have same validity; then if they are valid they must also be the same:</comment>
        <return>return <expr><name>sameValidity</name> &amp;&amp; (!<name>defValid</name> || <call><name><name>def</name>.<name>sameDefinition</name></name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>project</name></expr></argument>)</argument_list></call>)</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
      * update the restricted definition table with a new or
      * modified definition.
      */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>updateRestrictedDefinition</name><parameter_list>(<param><decl><type><name>AntTypeDefinition</name></type> <name>def</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><call><name><name>def</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>list</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <synchronized>synchronized (<expr><name>restrictedDefinitions</name></expr>) <block>{
            <expr_stmt><expr><name>list</name> = <call><name><name>restrictedDefinitions</name>.<name>get</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>list</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>list</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>restrictedDefinitions</name>.<name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></synchronized>
        <comment type="line">// Check if the classname is already present and remove it</comment>
        <comment type="line">// if it is</comment>
        <synchronized>synchronized (<expr><name>list</name></expr>) <block>{
            <for>for (<init><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>i</name> =<init> <expr><call><name><name>list</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>i</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>) <block>{
                <decl_stmt><decl><type><name>AntTypeDefinition</name></type> <name>current</name> =<init> <expr><call><name><name>i</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>current</name>.<name>getClassName</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><call><name><name>def</name>.<name>getClassName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>i</name>.<name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr><call><name><name>list</name>.<name>add</name></name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></synchronized>
    }</block></function>

    <comment type="javadoc">/**
     * Update the component definition table with a new or
     * modified definition.
     * @param def the definition to update or insert.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>updateDataTypeDefinition</name><parameter_list>(<param><decl><type><name>AntTypeDefinition</name></type> <name>def</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><call><name><name>def</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <synchronized>synchronized (<expr><name>antTypeTable</name></expr>) <block>{
            <expr_stmt><expr><name>rebuildTaskClassDefinitions</name> = true</expr>;</expr_stmt>
            <expr_stmt><expr><name>rebuildTypeClassDefinitions</name> = true</expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>AntTypeDefinition</name></type> <name>old</name> =<init> <expr><call><name><name>antTypeTable</name>.<name>get</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>old</name> != <name>null</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>sameDefinition</name><argument_list>(<argument><expr><name>def</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return;</return>
                }</block></then></if>
                <decl_stmt><decl><type><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>oldClass</name> =<init> <expr><call><name><name>old</name>.<name>getExposedClass</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>boolean</name></type> <name>isTask</name> =<init> <expr><name>oldClass</name> != <name>null</name> &amp;&amp; <name><name>Task</name>.<name><name/></name></name>class.<call><name>isAssignableFrom</name><argument_list>(<argument><expr><name>oldClass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr>"Trying to override old definition of "
                        + (<name>isTask</name> ? "task " : "datatype ") + <name>name</name></expr></argument>, <argument><expr>(<call><name><name>def</name>.<name>similarDefinition</name></name><argument_list>(<argument><expr><name>old</name></expr></argument>,
                        <argument><expr><name>project</name></expr></argument>)</argument_list></call>) ? <name><name>Project</name>.<name>MSG_VERBOSE</name></name> : <name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr>" +Datatype " + <name>name</name> + " " + <call><name><name>def</name>.<name>getClassName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_DEBUG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>antTypeTable</name>.<name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></synchronized>
    }</block></function>

    <comment type="javadoc">/**
     * Called at the start of processing an antlib.
     * @param uri the uri that is associated with this antlib.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>enterAntLib</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>antLibCurrentUri</name> = <name>uri</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>antLibStack</name>.<name>push</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * @return the current antlib uri.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getCurrentAntlibUri</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>antLibCurrentUri</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Called at the end of processing an antlib.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>exitAntLib</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>antLibStack</name>.<name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>antLibCurrentUri</name> = (<call><name><name>antLibStack</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0) ? <name>null</name> : (<name>String</name>) <call><name><name>antLibStack</name>.<name>peek</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Load ant's tasks.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>initTasks</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>ClassLoader</name></type> <name>classLoader</name> =<init> <expr><call><name>getClassLoader</name><argument_list>(<argument><expr><name>null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Properties</name></type> <name>props</name> =<init> <expr><call><name>getDefaultDefinitions</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Enumeration</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><call><name><name>props</name>.<name>propertyNames</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr>(<name>String</name>) <call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>className</name> =<init> <expr><call><name><name>props</name>.<name>getProperty</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AntTypeDefinition</name></type> <name>def</name> =<init> <expr>new <call><name>AntTypeDefinition</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>def</name>.<name>setName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>def</name>.<name>setClassName</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>def</name>.<name>setClassLoader</name></name><argument_list>(<argument><expr><name>classLoader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>def</name>.<name>setAdaptToClass</name></name><argument_list>(<argument><expr><name><name>Task</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>def</name>.<name>setAdapterClass</name></name><argument_list>(<argument><expr><name><name>TaskAdapter</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>antTypeTable</name>.<name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ClassLoader</name></type> <name>getClassLoader</name><parameter_list>(<param><decl><type><name>ClassLoader</name></type> <name>classLoader</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>buildSysclasspath</name> =<init> <expr><call><name><name>project</name>.<name>getProperty</name></name><argument_list>(<argument><expr><name><name>MagicNames</name>.<name>BUILD_SYSCLASSPATH</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>project</name>.<name>getCoreLoader</name></name><argument_list>()</argument_list></call> != <name>null</name>
            &amp;&amp; !(<call><name><name>BUILD_SYSCLASSPATH_ONLY</name>.<name>equals</name></name><argument_list>(<argument><expr><name>buildSysclasspath</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>classLoader</name> = <call><name><name>project</name>.<name>getCoreLoader</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>classLoader</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Load default task or type definitions - just the names,
     *  no class loading.
     * Caches results between calls to reduce overhead.
     * @param type true for typedefs, false for taskdefs
     * @return a mapping from definition names to class names
     * @throws BuildException if there was some problem loading
     *                        or parsing the definitions list
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <specifier>synchronized</specifier> <name>Properties</name></type> <name>getDefaultDefinitions</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>type</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>idx</name> =<init> <expr><name>type</name> ? 1 : 0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>defaultDefinitions</name><index>[<expr><name>idx</name></expr>]</index></name> == <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>resource</name> =<init> <expr><name>type</name> ? <name><name>MagicNames</name>.<name>TYPEDEFS_PROPERTIES_RESOURCE</name></name>
                    : <name><name>MagicNames</name>.<name>TASKDEF_PROPERTIES_RESOURCE</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>errorString</name> =<init> <expr><name>type</name> ? <name>ERROR_NO_TYPE_LIST_LOAD</name> : <name>ERROR_NO_TASK_LIST_LOAD</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>InputStream</name></type> <name>in</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <expr_stmt><expr><name>in</name> = <name><name>ComponentHelper</name>.<name><name/></name></name>class.<call><name>getResourceAsStream</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>in</name> == <name>null</name></expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>errorString</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <decl_stmt><decl><type><name>Properties</name></type> <name>p</name> =<init> <expr>new <call><name>Properties</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>p</name>.<name>load</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>defaultDefinitions</name><index>[<expr><name>idx</name></expr>]</index></name> = <name>p</name></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>) <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>errorString</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch> <finally>finally <block>{
                <expr_stmt><expr><call><name><name>FileUtils</name>.<name>close</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></finally></try>
        }</block></then></if>
        <return>return <expr><name><name>defaultDefinitions</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Load ant's datatypes.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>initTypes</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>ClassLoader</name></type> <name>classLoader</name> =<init> <expr><call><name>getClassLoader</name><argument_list>(<argument><expr><name>null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Properties</name></type> <name>props</name> =<init> <expr><call><name>getDefaultDefinitions</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Enumeration</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><call><name><name>props</name>.<name>propertyNames</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr>(<name>String</name>) <call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>className</name> =<init> <expr><call><name><name>props</name>.<name>getProperty</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AntTypeDefinition</name></type> <name>def</name> =<init> <expr>new <call><name>AntTypeDefinition</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>def</name>.<name>setName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>def</name>.<name>setClassName</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>def</name>.<name>setClassLoader</name></name><argument_list>(<argument><expr><name>classLoader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>antTypeTable</name>.<name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="javadoc">/**
     * Called for each component name, check if the
     * associated URI has been examined for antlibs.
     * @param componentName the name of the component, which should include a URI
     *                      prefix if it is in a namespace
     */</comment>
    <function><type><specifier>private</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>checkNamespace</name><parameter_list>(<param><decl><type><name>String</name></type> <name>componentName</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>uri</name> =<init> <expr><call><name><name>ProjectHelper</name>.<name>extractUriFromComponentName</name></name><argument_list>(<argument><expr><name>componentName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>"".<call><name>equals</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>uri</name> = <name><name>ProjectHelper</name>.<name>ANT_CORE_URI</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>!<call><name><name>uri</name>.<name>startsWith</name></name><argument_list>(<argument><expr><name><name>ProjectHelper</name>.<name>ANTLIB_URI</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return;</return> <comment type="line">// namespace that does not contain antlib</comment>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>checkedNamespaces</name>.<name>contains</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return;</return> <comment type="line">// Already processed</comment>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>checkedNamespaces</name>.<name>add</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>antTypeTable</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
            <comment type="line">// Project instance doesn't know the tasks and types</comment>
            <comment type="line">// defined in defaults.properties, likely created by the</comment>
            <comment type="line">// user - without those definitions it cannot parse antlib</comment>
            <comment type="line">// files as taskdef, typedef and friends are unknown</comment>
            <expr_stmt><expr><call><name>initDefaultDefinitions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><name>Typedef</name></type> <name>definer</name> =<init> <expr>new <call><name>Typedef</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>definer</name>.<name>setProject</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>definer</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>definer</name>.<name>setURI</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//there to stop error messages being "null"</comment>
        <expr_stmt><expr><call><name><name>definer</name>.<name>setTaskName</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//if this is left out, bad things happen. like all build files break</comment>
        <comment type="line">//on the first element encountered.</comment>
        <expr_stmt><expr><call><name><name>definer</name>.<name>setResource</name></name><argument_list>(<argument><expr><call><name><name>Definer</name>.<name>makeResourceFromURI</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// a fishing expedition :- ignore errors if antlib not present</comment>
        <expr_stmt><expr><call><name><name>definer</name>.<name>setOnError</name></name><argument_list>(<argument><expr>new <call><name><name>Typedef</name>.<name>OnError</name></name><argument_list>(<argument><expr><name><name>Typedef</name>.<name>OnError</name>.<name>POLICY_IGNORE</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>definer</name>.<name>execute</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Handler called to do decent diagnosis on instantiation failure.
     * @param componentName component name.
     * @param type component type, used in error messages
     * @return a string containing as much diagnostics info as possible.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>diagnoseCreationFailure</name><parameter_list>(<param><decl><type><name>String</name></type> <name>componentName</name></decl></param>, <param><decl><type><name>String</name></type> <name>type</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>StringWriter</name></type> <name>errorText</name> =<init> <expr>new <call><name>StringWriter</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PrintWriter</name></type> <name>out</name> =<init> <expr>new <call><name>PrintWriter</name><argument_list>(<argument><expr><name>errorText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Problem: failed to create " + <name>type</name> + " " + <name>componentName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//class of problem</comment>
        <decl_stmt><decl><type><name>boolean</name></type> <name>lowlevel</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>jars</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>definitions</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>antTask</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>home</name> =<init> <expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr><name><name>Launcher</name>.<name>USER_HOMEDIR</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>File</name></type> <name>libDir</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>home</name></expr></argument>, <argument><expr><name><name>Launcher</name>.<name>USER_LIBDIR</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>antHomeLib</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>probablyIDE</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>anthome</name> =<init> <expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr><name><name>MagicNames</name>.<name>ANT_HOME</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>anthome</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>File</name></type> <name>antHomeLibDir</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>anthome</name></expr></argument>, <argument><expr>"lib"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>antHomeLib</name> = <call><name><name>antHomeLibDir</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="line">//running under an IDE that doesn't set ANT_HOME</comment>
            <expr_stmt><expr><name>probablyIDE</name> = true</expr>;</expr_stmt>
            <expr_stmt><expr><name>antHomeLib</name> = "ANT_HOME" + <name><name>File</name>.<name>separatorChar</name></name> + "lib"</expr>;</expr_stmt>
        }</block></else></if>
        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>dirListingText</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>tab</name> =<init> <expr>"        -"</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>dirListingText</name>.<name>append</name></name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>dirListingText</name>.<name>append</name></name><argument_list>(<argument><expr><name>antHomeLib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>dirListingText</name>.<name>append</name></name><argument_list>(<argument><expr>'\n'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>probablyIDE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>dirListingText</name>.<name>append</name></name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>dirListingText</name>.<name>append</name></name><argument_list>(<argument><expr>"the IDE Ant configuration dialogs"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>dirListingText</name>.<name>append</name></name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>dirListingText</name>.<name>append</name></name><argument_list>(<argument><expr><name>libDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>dirListingText</name>.<name>append</name></name><argument_list>(<argument><expr>'\n'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>dirListingText</name>.<name>append</name></name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>dirListingText</name>.<name>append</name></name><argument_list>(<argument><expr>"a directory added on the command line with the -lib argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <decl_stmt><decl><type><name>String</name></type> <name>dirListing</name> =<init> <expr><call><name><name>dirListingText</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">//look up the name</comment>
        <decl_stmt><decl><type><name>AntTypeDefinition</name></type> <name>def</name> =<init> <expr><call><name>getDefinition</name><argument_list>(<argument><expr><name>componentName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>def</name> == <name>null</name></expr>)</condition><then> <block>{
            <comment type="line">//not a known type</comment>
            <expr_stmt><expr><call><name>printUnknownDefinition</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>componentName</name></expr></argument>, <argument><expr><name>dirListing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>definitions</name> = true</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="line">//we are defined, so it is an instantiation problem</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>classname</name> =<init> <expr><call><name><name>def</name>.<name>getClassName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>antTask</name> = <call><name><name>classname</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"org.apache.tools.ant."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>optional</name> =<init> <expr><call><name><name>classname</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"org.apache.tools.ant.taskdefs.optional"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>optional</name> |= <call><name><name>classname</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"org.apache.tools.ant.types.optional"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">//start with instantiating the class.</comment>
            <decl_stmt><decl><type><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>clazz</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <expr_stmt><expr><name>clazz</name> = <call><name><name>def</name>.<name>innerGetTypeClass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>ClassNotFoundException</name></type> <name>e</name></decl></param>) <block>{
                <expr_stmt><expr><name>jars</name> = true</expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>optional</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>definitions</name> = true</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>printClassNotFound</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>classname</name></expr></argument>, <argument><expr><name>optional</name></expr></argument>, <argument><expr><name>dirListing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch> <catch>catch (<param><decl><type><name>NoClassDefFoundError</name></type> <name>ncdfe</name></decl></param>) <block>{
                <expr_stmt><expr><name>jars</name> = true</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printNotLoadDependentClass</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>optional</name></expr></argument>, <argument><expr><name>ncdfe</name></expr></argument>, <argument><expr><name>dirListing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch></try>
            <comment type="line">//here we successfully loaded the class or failed.</comment>
            <if>if <condition>(<expr><name>clazz</name> != <name>null</name></expr>)</condition><then> <block>{
                <comment type="line">//success: proceed with more steps</comment>
                <try>try <block>{
                    <expr_stmt><expr><call><name><name>def</name>.<name>innerCreateAndSet</name></name><argument_list>(<argument><expr><name>clazz</name></expr></argument>, <argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">//hey, there is nothing wrong with us</comment>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"The component could be instantiated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> <catch>catch (<param><decl><type><name>NoSuchMethodException</name></type> <name>e</name></decl></param>) <block>{
                    <expr_stmt><expr><name>lowlevel</name> = true</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Cause: The class " + <name>classname</name>
                            + " has no compatible constructor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                }</block></catch> <catch>catch (<param><decl><type><name>InstantiationException</name></type> <name>e</name></decl></param>) <block>{
                    <expr_stmt><expr><name>lowlevel</name> = true</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Cause: The class " + <name>classname</name>
                            + " is abstract and cannot be instantiated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></catch> <catch>catch (<param><decl><type><name>IllegalAccessException</name></type> <name>e</name></decl></param>) <block>{
                    <expr_stmt><expr><name>lowlevel</name> = true</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Cause: The constructor for " + <name>classname</name>
                            + " is private and cannot be invoked."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></catch> <catch>catch (<param><decl><type><name>InvocationTargetException</name></type> <name>ex</name></decl></param>) <block>{
                    <expr_stmt><expr><name>lowlevel</name> = true</expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>Throwable</name></type> <name>t</name> =<init> <expr><call><name><name>ex</name>.<name>getTargetException</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Cause: The constructor threw the exception"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>t</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>t</name>.<name>printStackTrace</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></catch>  <catch>catch (<param><decl><type><name>NoClassDefFoundError</name></type> <name>ncdfe</name></decl></param>) <block>{
                    <expr_stmt><expr><name>jars</name> = true</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Cause:  A class needed by class " + <name>classname</name>
                            + " cannot be found: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"       " + <call><name><name>ncdfe</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Action: Determine what extra JAR files are"
                            + " needed, and place them in:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr><name>dirListing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></catch></try>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Do not panic, this is a common problem."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>definitions</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"It may just be a typographical error in the build file "
                        + "or the task/type declaration."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>jars</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"The commonest cause is a missing JAR."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>lowlevel</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"This is quite a low level problem, which may need "
                        + "consultation with the author of the task."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>antTask</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"This may be the Ant team. Please file a "
                            + "defect or contact the developer team."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"This does not appear to be a task bundled with Ant."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Please take it up with the supplier of the third-party " + <name>type</name>
                            + "."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"If you have written it yourself, you probably have a bug to fix."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"This is not a bug; it is a configuration problem"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
        <expr_stmt><expr><call><name><name>out</name>.<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>errorText</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Print unknown definition.forking
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>printUnknownDefinition</name><parameter_list>(<param><decl><type><name>PrintWriter</name></type> <name>out</name></decl></param>, <param><decl><type><name>String</name></type> <name>componentName</name></decl></param>, <param><decl><type><name>String</name></type> <name>dirListing</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>isAntlib</name> =<init> <expr><call><name><name>componentName</name>.<name>indexOf</name></name><argument_list>(<argument><expr><name><name>MagicNames</name>.<name>ANTLIB_PREFIX</name></name></expr></argument>)</argument_list></call> == 0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>uri</name> =<init> <expr><call><name><name>ProjectHelper</name>.<name>extractUriFromComponentName</name></name><argument_list>(<argument><expr><name>componentName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Cause: The name is undefined."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Action: Check the spelling."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Action: Check that any custom tasks/types have been declared."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Action: Check that any &lt;presetdef&gt;/&lt;macrodef&gt;"
                + " declarations have taken place."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>uri</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>matches</name> =<init> <expr><call><name>findTypeMatches</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>matches</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"The definitions in the namespace " + <name>uri</name> + " are:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for (<init><decl><type><name>AntTypeDefinition</name></type> <name>def</name> :<range> <expr><name>matches</name></expr></range></decl></init>) <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>local</name> =<init> <expr><call><name><name>ProjectHelper</name>.<name>extractNameFromComponentName</name></name><argument_list>(<argument><expr><call><name><name>def</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"    " + <name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"No types or tasks have been defined in this namespace yet"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>isAntlib</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"This appears to be an antlib declaration. "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Action: Check that the implementing library exists in one of:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr><name>dirListing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Print class not found.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>printClassNotFound</name><parameter_list>(<param><decl><type><name>PrintWriter</name></type> <name>out</name></decl></param>, <param><decl><type><name>String</name></type> <name>classname</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>optional</name></decl></param>,
            <param><decl><type><name>String</name></type> <name>dirListing</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Cause: the class " + <name>classname</name> + " was not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>optional</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"        This looks like one of Ant's optional components."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Action: Check that the appropriate optional JAR exists in"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr><name>dirListing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Action: Check that the component has been correctly declared"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"        and that the implementing JAR is in one of:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr><name>dirListing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Print could not load dependent class.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>printNotLoadDependentClass</name><parameter_list>(<param><decl><type><name>PrintWriter</name></type> <name>out</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>optional</name></decl></param>,
            <param><decl><type><name>NoClassDefFoundError</name></type> <name>ncdfe</name></decl></param>, <param><decl><type><name>String</name></type> <name>dirListing</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Cause: Could not load a dependent class "
                    +  <call><name><name>ncdfe</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>optional</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"       It is not enough to have Ant's optional JARs"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"       you need the JAR files that the" + " optional tasks depend upon."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"       Ant's optional task dependencies are" + " listed in the manual."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"       This class may be in a separate JAR" + " that is not installed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Action: Determine what extra JAR files are"
                + " needed, and place them in one of:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr><name>dirListing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Create a list of all definitions that match a prefix, usually the URI
     * of a library
     * @param prefix prefix to match off
     * @return the (possibly empty) list of definitions
     */</comment>
    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>findTypeMatches</name><parameter_list>(<param><decl><type><name>String</name></type> <name>prefix</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name></type> <name>result</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>AntTypeDefinition</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <synchronized>synchronized (<expr><name>antTypeTable</name></expr>) <block>{
            <for>for (<init><decl><type><name>AntTypeDefinition</name></type> <name>def</name> :<range> <expr><call><name><name>antTypeTable</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                <if>if <condition>(<expr><call><name><name>def</name>.<name>getName</name></name><argument_list>()</argument_list></call>.<call><name>startsWith</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>result</name>.<name>add</name></name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></synchronized>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>
}</block></class>
</unit>
