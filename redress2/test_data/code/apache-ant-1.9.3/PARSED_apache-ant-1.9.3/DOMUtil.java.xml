<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\taskdefs\optional\junit\DOMUtil.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>optional</name>.<name>junit</name></name>;</package>

<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>Attr</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>CDATASection</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>Comment</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>DOMException</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>Document</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>Element</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>NamedNodeMap</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>Node</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>NodeList</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>ProcessingInstruction</name></name>;</import>
<import>import <name><name>org</name>.<name>w3c</name>.<name>dom</name>.<name>Text</name></name>;</import>

<comment type="javadoc">/**
 * Some utilities that might be useful when manipulating DOM trees.
 *
 */</comment>
<class><specifier>public</specifier> <specifier>final</specifier> class <name>DOMUtil</name> <block>{

    <comment type="javadoc">/** unused constructor */</comment>
    <constructor><specifier>private</specifier> <name>DOMUtil</name><parameter_list>()</parameter_list> <block>{
    }</block></constructor>

    <comment type="javadoc">/**
     * Filter interface to be applied when iterating over a DOM tree.
     * Just think of it like a &lt;tt&gt;FileFilter&lt;/tt&gt; clone.
     */</comment>
    <class type="interface"><specifier>public</specifier> interface <name>NodeFilter</name> <block>{
        <comment type="javadoc">/**
         * @param       node    the node to check for acceptance.
         * @return      &lt;tt&gt;true&lt;/tt&gt; if the node is accepted by this filter,
         *                      otherwise &lt;tt&gt;false&lt;/tt&gt;
         */</comment>
        <function_decl><type><name>boolean</name></type> <name>accept</name><parameter_list>(<param><decl><type><name>Node</name></type> <name>node</name></decl></param>)</parameter_list>;</function_decl>
    }</block></class>

    <comment type="javadoc">/**
     * list a set of node that match a specific filter. The list can be made
     * recursively or not.
     * @param   parent  the parent node to search from
     * @param   filter  the filter that children should match.
     * @param   recurse &lt;tt&gt;true&lt;/tt&gt; if you want the list to be made recursively
     *                  otherwise &lt;tt&gt;false&lt;/tt&gt;.
     * @return the node list that matches the filter.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>NodeList</name></type> <name>listChildNodes</name><parameter_list>(<param><decl><type><name>Node</name></type> <name>parent</name></decl></param>, <param><decl><type><name>NodeFilter</name></type> <name>filter</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>recurse</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>NodeListImpl</name></type> <name>matches</name> =<init> <expr>new <call><name>NodeListImpl</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>NodeList</name></type> <name>children</name> =<init> <expr><call><name><name>parent</name>.<name>getChildNodes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>children</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> =<init> <expr><call><name><name>children</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>Node</name></type> <name>child</name> =<init> <expr><call><name><name>children</name>.<name>item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>filter</name>.<name>accept</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>matches</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>recurse</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>NodeList</name></type> <name>recmatches</name> =<init> <expr><call><name>listChildNodes</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>reclength</name> =<init> <expr><call><name><name>recmatches</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>reclength</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                        <expr_stmt><expr><call><name><name>matches</name>.<name>addElement</name></name><argument_list>(<argument><expr><call><name><name>recmatches</name>.<name>item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>matches</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/** custom implementation of a nodelist */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>NodeListImpl</name> <super><extends>extends <name>Vector</name></extends> <implements>implements <name>NodeList</name></implements></super> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> =<init> <expr>3175749150080946423L</expr></init></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Get the number of nodes in the list.
         * @return the length of the list.
         */</comment>
        <function><type><specifier>public</specifier> <name>int</name></type> <name>getLength</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name>size</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>
        <comment type="javadoc">/**
         * Get a particular node.
         * @param i the index of the node to get.
         * @return the node if the index is in bounds, null otherwise.
         */</comment>
        <function><type><specifier>public</specifier> <name>Node</name></type> <name>item</name><parameter_list>(<param><decl><type><name>int</name></type> <name>i</name></decl></param>)</parameter_list> <block>{
            <try>try <block>{
                <return>return <expr>(<name>Node</name>) <call><name>elementAt</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block> <catch>catch (<param><decl><type><name>ArrayIndexOutOfBoundsException</name></type> <name>e</name></decl></param>) <block>{
                <return>return <expr><name>null</name></expr>;</return> <comment type="line">// conforming to NodeList interface</comment>
            }</block></catch></try>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * return the attribute value of an element.
     * @param node the node to get the attribute from.
     * @param name the name of the attribute we are looking for the value.
     * @return the value of the requested attribute or &lt;tt&gt;null&lt;/tt&gt; if the
     *         attribute was not found or if &lt;tt&gt;node&lt;/tt&gt; is not an &lt;tt&gt;Element&lt;/tt&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getNodeAttribute</name><parameter_list>(<param><decl><type><name>Node</name></type> <name>node</name></decl></param>, <param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>node</name> <name>instanceof</name> <name>Element</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>Element</name></type> <name>element</name> =<init> <expr>(<name>Element</name>) <name>node</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>element</name>.<name>getAttribute</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>null</name></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Iterate over the children of a given node and return the first node
     * that has a specific name.
     * @param   parent  the node to search child from. Can be &lt;tt&gt;null&lt;/tt&gt;.
     * @param   tagname the child name we are looking for. Cannot be &lt;tt&gt;null&lt;/tt&gt;.
     * @return  the first child that matches the given name or &lt;tt&gt;null&lt;/tt&gt; if
     *                  the parent is &lt;tt&gt;null&lt;/tt&gt; or if a child does not match the
     *                  given name.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Element</name></type> <name>getChildByTagName</name> <parameter_list>(<param><decl><type><name>Node</name></type> <name>parent</name></decl></param>, <param><decl><type><name>String</name></type> <name>tagname</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>parent</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr><name>null</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>NodeList</name></type> <name>childList</name> =<init> <expr><call><name><name>parent</name>.<name>getChildNodes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> =<init> <expr><call><name><name>childList</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>Node</name></type> <name>child</name> =<init> <expr><call><name><name>childList</name>.<name>item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>child</name> != <name>null</name> &amp;&amp; <call><name><name>child</name>.<name>getNodeType</name></name><argument_list>()</argument_list></call> == <name><name>Node</name>.<name>ELEMENT_NODE</name></name>
                &amp;&amp; <call><name><name>child</name>.<name>getNodeName</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name>tagname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>(<name>Element</name>) <name>child</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>null</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Simple tree walker that will clone recursively a node. This is to
     * avoid using parser-specific API such as Sun's &lt;tt&gt;changeNodeOwner&lt;/tt&gt;
     * when we are dealing with DOM L1 implementations since &lt;tt&gt;cloneNode(boolean)&lt;/tt&gt;
     * will not change the owner document.
     * &lt;tt&gt;changeNodeOwner&lt;/tt&gt; is much faster and avoid the costly cloning process.
     * &lt;tt&gt;importNode&lt;/tt&gt; is in the DOM L2 interface.
     * @param   parent  the node parent to which we should do the import to.
     * @param   child   the node to clone recursively. Its clone will be
     *              appended to &lt;tt&gt;parent&lt;/tt&gt;.
     * @return  the cloned node that is appended to &lt;tt&gt;parent&lt;/tt&gt;
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Node</name></type> <name>importNode</name><parameter_list>(<param><decl><type><name>Node</name></type> <name>parent</name></decl></param>, <param><decl><type><name>Node</name></type> <name>child</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Node</name></type> <name>copy</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Document</name></type> <name>doc</name> =<init> <expr><call><name><name>parent</name>.<name>getOwnerDocument</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><call><name><name>child</name>.<name>getNodeType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <case>case <expr><name><name>Node</name>.<name>CDATA_SECTION_NODE</name></name></expr>:
            <expr_stmt><expr><name>copy</name> = <call><name><name>doc</name>.<name>createCDATASection</name></name><argument_list>(<argument><expr>((<name>CDATASection</name>) <name>child</name>).<call><name>getData</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name><name>Node</name>.<name>COMMENT_NODE</name></name></expr>:
            <expr_stmt><expr><name>copy</name> = <call><name><name>doc</name>.<name>createComment</name></name><argument_list>(<argument><expr>((<name>Comment</name>) <name>child</name>).<call><name>getData</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name><name>Node</name>.<name>DOCUMENT_FRAGMENT_NODE</name></name></expr>:
            <expr_stmt><expr><name>copy</name> = <call><name><name>doc</name>.<name>createDocumentFragment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name><name>Node</name>.<name>ELEMENT_NODE</name></name></expr>:
            <decl_stmt><decl><type><specifier>final</specifier> <name>Element</name></type> <name>elem</name> =<init> <expr><call><name><name>doc</name>.<name>createElement</name></name><argument_list>(<argument><expr>((<name>Element</name>) <name>child</name>).<call><name>getTagName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>copy</name> = <name>elem</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>NamedNodeMap</name></type> <name>attributes</name> =<init> <expr><call><name><name>child</name>.<name>getAttributes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>attributes</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name> =<init> <expr><call><name><name>attributes</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>Attr</name></type> <name>attr</name> =<init> <expr>(<name>Attr</name>) <call><name><name>attributes</name>.<name>item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>elem</name>.<name>setAttribute</name></name><argument_list>(<argument><expr><call><name><name>attr</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>attr</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></then></if>
            <break>break;</break>
        </case><case>case <expr><name><name>Node</name>.<name>ENTITY_REFERENCE_NODE</name></name></expr>:
            <expr_stmt><expr><name>copy</name> = <call><name><name>doc</name>.<name>createEntityReference</name></name><argument_list>(<argument><expr><call><name><name>child</name>.<name>getNodeName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name><name>Node</name>.<name>PROCESSING_INSTRUCTION_NODE</name></name></expr>:
            <decl_stmt><decl><type><specifier>final</specifier> <name>ProcessingInstruction</name></type> <name>pi</name> =<init> <expr>(<name>ProcessingInstruction</name>) <name>child</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>copy</name> = <call><name><name>doc</name>.<name>createProcessingInstruction</name></name><argument_list>(<argument><expr><call><name><name>pi</name>.<name>getTarget</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pi</name>.<name>getData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name><name>Node</name>.<name>TEXT_NODE</name></name></expr>:
            <expr_stmt><expr><name>copy</name> = <call><name><name>doc</name>.<name>createTextNode</name></name><argument_list>(<argument><expr>((<name>Text</name>) <name>child</name>).<call><name>getData</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><default>default:
            <comment type="line">// this should never happen</comment>
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Invalid node type: " + <call><name><name>child</name>.<name>getNodeType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </default>}</block></switch>

        <comment type="line">// okay we have a copy of the child, now the child becomes the parent</comment>
        <comment type="line">// and we are iterating recursively over its children.</comment>
        <try>try <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>NodeList</name></type> <name>children</name> =<init> <expr><call><name><name>child</name>.<name>getChildNodes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>children</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name> =<init> <expr><call><name><name>children</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>Node</name></type> <name>newChild</name> =<init> <expr><call><name><name>children</name>.<name>item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>newChild</name> != <name>null</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>importNode</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>newChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></then></if>
        }</block> <catch>catch (<param><decl><type><name>DOMException</name></type> <name>ignored</name></decl></param>) <block>{
            <comment type="line">// Ignore</comment>
        }</block></catch></try>

        <comment type="line">// bingo append it. (this should normally not be done here)</comment>
        <expr_stmt><expr><call><name><name>parent</name>.<name>appendChild</name></name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>copy</name></expr>;</return>
    }</block></function>
}</block></class>
</unit>
