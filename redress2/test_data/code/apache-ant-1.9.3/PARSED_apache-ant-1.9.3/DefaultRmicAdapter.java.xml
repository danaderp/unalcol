<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\taskdefs\rmic\DefaultRmicAdapter.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>rmic</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Random</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>Rmic</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Commandline</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Path</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileNameMapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>StringUtils</name></name>;</import>

<comment type="javadoc">/**
 * This is the default implementation for the RmicAdapter interface.
 * Currently, this is a cut-and-paste of the original rmic task and
 * DefaultCompilerAdapter.
 *
 * @since Ant 1.4
 */</comment>
<class><specifier>public</specifier> <specifier>abstract</specifier> class <name>DefaultRmicAdapter</name> <super><implements>implements <name>RmicAdapter</name></implements></super> <block>{

    <decl_stmt><decl><type><specifier>private</specifier> <name>Rmic</name></type> <name>attributes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>FileNameMapper</name></type> <name>mapper</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Random</name></type> <name>RAND</name> =<init> <expr>new <call><name>Random</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** suffix denoting a stub file: {@value} */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>RMI_STUB_SUFFIX</name> =<init> <expr>"_Stub"</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** suffix denoting a skel file: {@value} */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>RMI_SKEL_SUFFIX</name> =<init> <expr>"_Skel"</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** suffix denoting a tie file: {@value} */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>RMI_TIE_SUFFIX</name> =<init> <expr>"_Tie"</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** arg for compat: {@value} */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>STUB_COMPAT</name> =<init> <expr>"-vcompat"</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** arg for 1.1: {@value} */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>STUB_1_1</name> =<init> <expr>"-v1.1"</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** arg for 1.2: {@value} */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>STUB_1_2</name> =<init> <expr>"-v1.2"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * option for stub 1.1 in the rmic task: {@value}
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>STUB_OPTION_1_1</name> =<init> <expr>"1.1"</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/**
     * option for stub 1.2 in the rmic task: {@value}
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>STUB_OPTION_1_2</name> =<init> <expr>"1.2"</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/**
     * option for stub compat in the rmic task: {@value}
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>STUB_OPTION_COMPAT</name> =<init> <expr>"compat"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Default constructor
     */</comment>
    <constructor><specifier>public</specifier> <name>DefaultRmicAdapter</name><parameter_list>()</parameter_list> <block>{
    }</block></constructor>

    <comment type="javadoc">/**
     * Sets Rmic attributes
     * @param attributes the rmic attributes
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setRmic</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Rmic</name></type> <name>attributes</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>attributes</name></name> = <name>attributes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mapper</name> = new <call><name>RmicFileNameMapper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Get the Rmic attributes
     * @return the attributes as a Rmic taskdef
     */</comment>
    <function><type><specifier>public</specifier> <name>Rmic</name></type> <name>getRmic</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>attributes</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the stub class suffix
     * @return the stub suffix &amp;quot;_Stub&amp;quot;
     */</comment>
    <function><type><specifier>protected</specifier> <name>String</name></type> <name>getStubClassSuffix</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>RMI_STUB_SUFFIX</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the skeleton class suffix
     * @return the skeleton suffix &amp;quot;_Skel&amp;quot;
     */</comment>
    <function><type><specifier>protected</specifier> <name>String</name></type> <name>getSkelClassSuffix</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>RMI_SKEL_SUFFIX</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the tie class suffix
     * @return the tie suffix &amp;quot;_Tie&amp;quot;
     */</comment>
    <function><type><specifier>protected</specifier> <name>String</name></type> <name>getTieClassSuffix</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>RMI_TIE_SUFFIX</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * This implementation returns a mapper that may return up to two
     * file names.
     *
     * &lt;ul&gt;
     *   &lt;li&gt;for JRMP it will return *_getStubClassSuffix (and
     *   *_getSkelClassSuffix if JDK 1.1 is used)&lt;/li&gt;
     *
     *   &lt;li&gt;for IDL it will return a random name, causing &amp;lt;rmic&amp;gt; to
     *     always recompile.&lt;/li&gt;
     *
     *   &lt;li&gt;for IIOP it will return _*_getStubClassSuffix for
     *   interfaces and _*_getStubClassSuffix for non-interfaces (and
     *   determine the interface and create _*_Stub from that).&lt;/li&gt;
     * &lt;/ul&gt;
     * @return a &lt;code&gt;FileNameMapper&lt;/code&gt;
     */</comment>
    <function><type><specifier>public</specifier> <name>FileNameMapper</name></type> <name>getMapper</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mapper</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the CLASSPATH this rmic process will use.
     * @return the classpath
     */</comment>
    <function><type><specifier>public</specifier> <name>Path</name></type> <name>getClasspath</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>getCompileClasspath</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Builds the compilation classpath.
     * @return the classpath
     */</comment>
    <function><type><specifier>protected</specifier> <name>Path</name></type> <name>getCompileClasspath</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>Path</name></type> <name>classpath</name> =<init> <expr>new <call><name>Path</name><argument_list>(<argument><expr><call><name><name>attributes</name>.<name>getProject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// add dest dir to classpath so that previously compiled and</comment>
        <comment type="line">// untouched classes are on classpath</comment>
        <expr_stmt><expr><call><name><name>classpath</name>.<name>setLocation</name></name><argument_list>(<argument><expr><call><name><name>attributes</name>.<name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Combine the build classpath with the system classpath, in an</comment>
        <comment type="line">// order determined by the value of build.sysclasspath</comment>

        <decl_stmt><decl><type><name>Path</name></type> <name>cp</name> =<init> <expr><call><name><name>attributes</name>.<name>getClasspath</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cp</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cp</name> = new <call><name>Path</name><argument_list>(<argument><expr><call><name><name>attributes</name>.<name>getProject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>attributes</name>.<name>getIncludeantruntime</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>classpath</name>.<name>addExisting</name></name><argument_list>(<argument><expr><call><name><name>cp</name>.<name>concatSystemClasspath</name></name><argument_list>(<argument><expr>"last"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>classpath</name>.<name>addExisting</name></name><argument_list>(<argument><expr><call><name><name>cp</name>.<name>concatSystemClasspath</name></name><argument_list>(<argument><expr>"ignore"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><call><name><name>attributes</name>.<name>getIncludejavaruntime</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>classpath</name>.<name>addJavaRuntime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>classpath</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Setup rmic argument for rmic.
     * @return the command line
     */</comment>
    <function><type><specifier>protected</specifier> <name>Commandline</name></type> <name>setupRmicCommand</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>setupRmicCommand</name><argument_list>(<argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Setup rmic argument for rmic.
     * @param options additional parameters needed by a specific
     *                implementation.
     * @return the command line
     */</comment>
    <function><type><specifier>protected</specifier> <name>Commandline</name></type> <name>setupRmicCommand</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>options</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Commandline</name></type> <name>cmd</name> =<init> <expr>new <call><name>Commandline</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>options</name> != <name>null</name></expr>)</condition><then> <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>options</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>

        <decl_stmt><decl><type><name>Path</name></type> <name>classpath</name> =<init> <expr><call><name>getCompileClasspath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr>"-d"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setFile</name><argument_list>(<argument><expr><call><name><name>attributes</name>.<name>getOutputDir</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>attributes</name>.<name>getExtdirs</name></name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr>"-extdirs"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setPath</name><argument_list>(<argument><expr><call><name><name>attributes</name>.<name>getExtdirs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr>"-classpath"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setPath</name><argument_list>(<argument><expr><name>classpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>stubOption</name> =<init> <expr><call><name>addStubVersionOptions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>stubOption</name> != <name>null</name></expr>)</condition><then> <block>{
            <comment type="line">//set the non-null stubOption</comment>
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name>stubOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>


        <if>if <condition>(<expr><name>null</name> != <call><name><name>attributes</name>.<name>getSourceBase</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr>"-keepgenerated"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>attributes</name>.<name>getIiop</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr>"IIOP has been turned on."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_INFO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr>"-iiop"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>attributes</name>.<name>getIiopopts</name></name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr>"IIOP Options: " + <call><name><name>attributes</name>.<name>getIiopopts</name></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><name><name>Project</name>.<name>MSG_INFO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><call><name><name>attributes</name>.<name>getIiopopts</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>attributes</name>.<name>getIdl</name></name><argument_list>()</argument_list></call></expr>)</condition><then>  <block>{
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr>"-idl"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr>"IDL has been turned on."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_INFO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>attributes</name>.<name>getIdlopts</name></name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><call><name><name>attributes</name>.<name>getIdlopts</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr>"IDL Options: " + <call><name><name>attributes</name>.<name>getIdlopts</name></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><name><name>Project</name>.<name>MSG_INFO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>attributes</name>.<name>getDebug</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr>"-g"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>compilerArgs</name> =<init> <expr><call><name><name>attributes</name>.<name>getCurrentCompilerArgs</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>compilerArgs</name> = <call><name>preprocessCompilerArgs</name><argument_list>(<argument><expr><name>compilerArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cmd</name>.<name>addArguments</name></name><argument_list>(<argument><expr><name>compilerArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>logAndAddFilesToCompile</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>cmd</name></expr>;</return>
     }</block></function>

    <comment type="javadoc">/**
     * This is an override point; get the stub version off the rmic command and
     * translate that into a compiler-specific argument
     * @return a string to use for the stub version; can be null
     * @since Ant1.7.1
     */</comment>
    <function><type><specifier>protected</specifier> <name>String</name></type> <name>addStubVersionOptions</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">//handle the many different stub options.</comment>
        <decl_stmt><decl><type><name>String</name></type> <name>stubVersion</name> =<init> <expr><call><name><name>attributes</name>.<name>getStubVersion</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">//default is compatibility</comment>
        <decl_stmt><decl><type><name>String</name></type> <name>stubOption</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>null</name> != <name>stubVersion</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>STUB_OPTION_1_1</name>.<name>equals</name></name><argument_list>(<argument><expr><name>stubVersion</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>stubOption</name> = <name>STUB_1_1</name></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><call><name><name>STUB_OPTION_1_2</name>.<name>equals</name></name><argument_list>(<argument><expr><name>stubVersion</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>stubOption</name> = <name>STUB_1_2</name></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><call><name><name>STUB_OPTION_COMPAT</name>.<name>equals</name></name><argument_list>(<argument><expr><name>stubVersion</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>stubOption</name> = <name>STUB_COMPAT</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <comment type="line">//anything else</comment>
                <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr>"Unknown stub option " + <name>stubVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">//do nothing with the value? or go -v+stubVersion??</comment>
            }</block></else></if></else></if></else></if>
        }</block></then></if>
        <comment type="line">//for java1.5+, we generate compatible stubs, that is, unless</comment>
        <comment type="line">//the caller asked for IDL or IIOP support.</comment>
        <if>if <condition>(<expr><name>stubOption</name> == <name>null</name>
            &amp;&amp; !<call><name><name>attributes</name>.<name>getIiop</name></name><argument_list>()</argument_list></call>
            &amp;&amp; !<call><name><name>attributes</name>.<name>getIdl</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>stubOption</name> = <name>STUB_COMPAT</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>stubOption</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Preprocess the compiler arguments in any way you see fit.
     * This is to allow compiler adapters to validate or filter the arguments.
     * The base implementation returns the original compiler arguments unchanged.
     * @param compilerArgs the original compiler arguments
     * @return the filtered set.
     */</comment>
    <function><type><specifier>protected</specifier> <name>String</name><index>[]</index></type> <name>preprocessCompilerArgs</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>compilerArgs</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>compilerArgs</name></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Strip out all -J args from the command list. Invoke this from
     * {@link #preprocessCompilerArgs(String[])} if you have a non-forking
     * compiler.
     * @param compilerArgs the original compiler arguments
     * @return the filtered set.
     */</comment>
    <function><type><specifier>protected</specifier> <name>String</name><index>[]</index></type> <name>filterJvmCompilerArgs</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>compilerArgs</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr><name><name>compilerArgs</name>.<name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name></type> <name>args</name> =<init> <expr>new <call><name>ArrayList</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>arg</name> =<init> <expr><name><name>compilerArgs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>arg</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"-J"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>args</name>.<name>add</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr>"Dropping " + <name>arg</name> + " from compiler arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> =<init> <expr><call><name><name>args</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr>(<name><name>String</name><index>[]</index></name>) <call><name><name>args</name>.<name>toArray</name></name><argument_list>(<argument><expr>new <name><name>String</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Logs the compilation parameters, adds the files to compile and logs the
     * &amp;quot;niceSourceList&amp;quot;
     * @param cmd the commandline args
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>logAndAddFilesToCompile</name><parameter_list>(<param><decl><type><name>Commandline</name></type> <name>cmd</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Vector</name></type> <name>compileList</name> =<init> <expr><call><name><name>attributes</name>.<name>getCompileList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr>"Compilation " + <call><name><name>cmd</name>.<name>describeArguments</name></name><argument_list>()</argument_list></call></expr></argument>,
                       <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>niceSourceList</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>(<argument><expr>"File"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>cListSize</name> =<init> <expr><call><name><name>compileList</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cListSize</name> != 1</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>niceSourceList</name>.<name>append</name></name><argument_list>(<argument><expr>"s"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>niceSourceList</name>.<name>append</name></name><argument_list>(<argument><expr>" to be compiled:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>cListSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>arg</name> =<init> <expr>(<name>String</name>) <call><name><name>compileList</name>.<name>elementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>niceSourceList</name>.<name>append</name></name><argument_list>(<argument><expr>"    "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>niceSourceList</name>.<name>append</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr><call><name><name>niceSourceList</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Mapper that may return up to two file names.
     *
     * &lt;ul&gt;
     *   &lt;li&gt;for JRMP it will return *_getStubClassSuffix (and
     *   *_getSkelClassSuffix if JDK 1.1 is used)&lt;/li&gt;
     *
     *   &lt;li&gt;for IDL it will return a random name, causing &lt;rmic&gt; to
     *     always recompile.&lt;/li&gt;
     *
     *   &lt;li&gt;for IIOP it will return _*_getStubClassSuffix for
     *   interfaces and _*_getStubClassSuffix for non-interfaces (and
     *   determine the interface and create _*_Stub from that).&lt;/li&gt;
     * &lt;/ul&gt;
     */</comment>
    <class><specifier>private</specifier> class <name>RmicFileNameMapper</name> <super><implements>implements <name>FileNameMapper</name></implements></super> <block>{

        <constructor><name>RmicFileNameMapper</name><parameter_list>()</parameter_list> <block>{
        }</block></constructor>

        <comment type="javadoc">/**
         * Empty implementation.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setFrom</name><parameter_list>(<param><decl><type><name>String</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
        }</block></function>
        <comment type="javadoc">/**
         * Empty implementation.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setTo</name><parameter_list>(<param><decl><type><name>String</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
        }</block></function>

        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>mapFileName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr><name>name</name> == <name>null</name>
                || !<call><name><name>name</name>.<name>endsWith</name></name><argument_list>(<argument><expr>".class"</expr></argument>)</argument_list></call>
                || <call><name><name>name</name>.<name>endsWith</name></name><argument_list>(<argument><expr><call><name>getStubClassSuffix</name><argument_list>()</argument_list></call> + ".class"</expr></argument>)</argument_list></call>
                || <call><name><name>name</name>.<name>endsWith</name></name><argument_list>(<argument><expr><call><name>getSkelClassSuffix</name><argument_list>()</argument_list></call> + ".class"</expr></argument>)</argument_list></call>
                || <call><name><name>name</name>.<name>endsWith</name></name><argument_list>(<argument><expr><call><name>getTieClassSuffix</name><argument_list>()</argument_list></call> + ".class"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// Not a .class file or the one we'd generate</comment>
                <return>return <expr><name>null</name></expr>;</return>
            }</block></then></if>

            <comment type="line">// we know that name.endsWith(".class")</comment>
            <decl_stmt><decl><type><name>String</name></type> <name>base</name> =<init> <expr><call><name><name>StringUtils</name>.<name>removeSuffix</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>".class"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>String</name></type> <name>classname</name> =<init> <expr><call><name><name>base</name>.<name>replace</name></name><argument_list>(<argument><expr><name><name>File</name>.<name>separatorChar</name></name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>attributes</name>.<name>getVerify</name></name><argument_list>()</argument_list></call>
                &amp;&amp; !<call><name><name>attributes</name>.<name>isValidRmiRemote</name></name><argument_list>(<argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>null</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/*
             * fallback in case we have trouble loading the class or
             * don't know how to handle it (there is no easy way to
             * know what IDL mode would generate.
             *
             * This is supposed to make Ant always recompile the
             * class, as a file of that name should not exist.
             */</comment>
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>target</name> =<init> <expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><name>name</name> + ".tmp." + <call><name><name>RAND</name>.<name>nextLong</name></name><argument_list>()</argument_list></call></expr>}</block></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<call><name><name>attributes</name>.<name>getIiop</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>attributes</name>.<name>getIdl</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// JRMP with simple naming convention</comment>
                <if>if <condition>(<expr><call><name><name>STUB_OPTION_1_2</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>attributes</name>.<name>getStubVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>target</name> = new <name><name>String</name><index>[]</index></name> <block>{
                        <expr><name>base</name> + <call><name>getStubClassSuffix</name><argument_list>()</argument_list></call> + ".class"</expr>
                    }</block></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>target</name> = new <name><name>String</name><index>[]</index></name> <block>{
                        <expr><name>base</name> + <call><name>getStubClassSuffix</name><argument_list>()</argument_list></call> + ".class"</expr>,
                        <expr><name>base</name> + <call><name>getSkelClassSuffix</name><argument_list>()</argument_list></call> + ".class"</expr>,
                    }</block></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then> <else>else <if>if <condition>(<expr>!<call><name><name>attributes</name>.<name>getIdl</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>lastSlash</name> =<init> <expr><call><name><name>base</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr><name><name>File</name>.<name>separatorChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>String</name></type> <name>dirname</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
                <comment type="block">/*
                 * I know, this is not necessary, but I prefer it explicit (SB)
                 */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>index</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>lastSlash</name> == -1</expr>)</condition><then> <block>{
                    <comment type="line">// no package</comment>
                    <expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>index</name> = <name>lastSlash</name> + 1</expr>;</expr_stmt>
                    <expr_stmt><expr><name>dirname</name> = <call><name><name>base</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

                <decl_stmt><decl><type><name>String</name></type> <name>filename</name> =<init> <expr><call><name><name>base</name>.<name>substring</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <try>try <block>{
                    <decl_stmt><decl><type><name>Class</name></type> <name>c</name> =<init> <expr><call><name><name>attributes</name>.<name>getLoader</name></name><argument_list>()</argument_list></call>.<call><name>loadClass</name><argument_list>(<argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><call><name><name>c</name>.<name>isInterface</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="line">// only stub, no tie</comment>
                        <expr_stmt><expr><name>target</name> = new <name><name>String</name><index>[]</index></name> <block>{
                            <expr><name>dirname</name> + "_" + <name>filename</name> + <call><name>getStubClassSuffix</name><argument_list>()</argument_list></call>
                            + ".class"</expr>
                        }</block></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <comment type="block">/*
                         * stub is derived from implementation,
                         * tie from interface name.
                         */</comment>
                        <decl_stmt><decl><type><name>Class</name></type> <name>interf</name> =<init> <expr><call><name><name>attributes</name>.<name>getRemoteInterface</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>String</name></type> <name>iName</name> =<init> <expr><call><name><name>interf</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>String</name></type> <name>iDir</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>iIndex</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>lastDot</name> =<init> <expr><call><name><name>iName</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr>"."</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>lastDot</name> == -1</expr>)</condition><then> <block>{
                            <comment type="line">// no package</comment>
                            <expr_stmt><expr><name>iIndex</name> = 0</expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><name>iIndex</name> = <name>lastDot</name> + 1</expr>;</expr_stmt>
                            <expr_stmt><expr><name>iDir</name> = <call><name><name>iName</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>iIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>iDir</name> = <call><name><name>iDir</name>.<name>replace</name></name><argument_list>(<argument><expr>'.'</expr></argument>, <argument><expr><name><name>File</name>.<name>separatorChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>

                        <expr_stmt><expr><name>target</name> = new <name><name>String</name><index>[]</index></name> <block>{
                            <expr><name>dirname</name> + "_" + <name>filename</name> + <call><name>getTieClassSuffix</name><argument_list>()</argument_list></call>
                            + ".class"</expr>,
                            <expr><name>iDir</name> + "_" + <call><name><name>iName</name>.<name>substring</name></name><argument_list>(<argument><expr><name>iIndex</name></expr></argument>)</argument_list></call>
                            + <call><name>getStubClassSuffix</name><argument_list>()</argument_list></call> + ".class"</expr>
                        }</block></expr>;</expr_stmt>
                    }</block></else></if>
                }</block> <catch>catch (<param><decl><type><name>ClassNotFoundException</name></type> <name>e</name></decl></param>) <block>{
                    <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr>"Unable to verify class " + <name>classname</name>
                                   + ". It could not be found."</expr></argument>,
                                   <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></catch> <catch>catch (<param><decl><type><name>NoClassDefFoundError</name></type> <name>e</name></decl></param>) <block>{
                    <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr>"Unable to verify class " + <name>classname</name>
                                   + ". It is not defined."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></catch> <catch>catch (<param><decl><type><name>Throwable</name></type> <name>t</name></decl></param>) <block>{
                    <expr_stmt><expr><call><name><name>attributes</name>.<name>log</name></name><argument_list>(<argument><expr>"Unable to verify class " + <name>classname</name>
                                   + ". Loading caused Exception: "
                                   + <call><name><name>t</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></catch></try>
            }</block></then></if></else></if>
            <return>return <expr><name>target</name></expr>;</return>
        }</block></function>
    }</block></class>
}</block></class>
</unit>
