<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\taskdefs\Zip.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>ByteArrayInputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>ByteArrayOutputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileInputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileOutputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>InputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>OutputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Arrays</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Collections</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Comparator</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Enumeration</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashMap</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Hashtable</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Stack</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>zip</name>.<name>CRC32</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>DirectoryScanner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>FileScanner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>ArchiveFileSet</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>EnumeratedAttribute</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>FileSet</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>PatternSet</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Resource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>ResourceCollection</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>ZipFileSet</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>ZipScanner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>ArchiveResource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>FileProvider</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>FileResource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>Union</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>ZipResource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>selectors</name>.<name>ResourceSelector</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileNameMapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>GlobPatternMapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>IdentityMapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>MergingMapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>ResourceUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name>.<name>UnixStat</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name>.<name>Zip64Mode</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name>.<name>ZipEntry</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name>.<name>ZipExtraField</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name>.<name>ZipFile</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name>.<name>ZipOutputStream</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name>.<name>ZipOutputStream</name>.<name>UnicodeExtraFieldPolicy</name></name>;</import>

<comment type="javadoc">/**
 * Create a Zip file.
 *
 * @since Ant 1.1
 *
 * @ant.task category="packaging"
 */</comment>
<class><specifier>public</specifier> class <name>Zip</name> <super><extends>extends <name>MatchingTask</name></extends></super> <block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BUFFER_SIZE</name> =<init> <expr>8 * 1024</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>ROUNDUP_MILLIS</name> =<init> <expr>1999</expr></init></decl>;</decl_stmt> <comment type="line">// 2 seconds - 1</comment>
    <comment type="line">// CheckStyle:VisibilityModifier OFF - bc</comment>

    <decl_stmt><decl><type><specifier>protected</specifier> <name>File</name></type> <name>zipFile</name></decl>;</decl_stmt>
    <comment type="line">// use to scan own archive</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>ZipScanner</name></type> <name>zs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>baseDir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>entries</name> =<init> <expr>new <call><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>FileSet</name></argument>&gt;</argument_list></name></type> <name>groupfilesets</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>FileSet</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>ZipFileSet</name></argument>&gt;</argument_list></name></type> <name>filesetsFromGroupfilesets</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>ZipFileSet</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>String</name></type> <name>duplicate</name> =<init> <expr>"add"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>doCompress</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>doUpdate</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <comment type="line">// shadow of the above if the value is altered in execute</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>savedDoUpdate</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>doFilesonly</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>String</name></type> <name>archiveType</name> =<init> <expr>"zip"</expr></init></decl>;</decl_stmt>

    <comment type="line">// For directories:</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>EMPTY_CRC</name> =<init> <expr>new <call><name>CRC32</name> <argument_list>()</argument_list></call>.<call><name>getValue</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>String</name></type> <name>emptyBehavior</name> =<init> <expr>"skip"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name></type> <name>resources</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>addedDirs</name> =<init> <expr>new <call><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>addedFiles</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ResourceSelector</name></type> <name>MISSING_SELECTOR</name> =<init>
        <expr>new <class><super><name>ResourceSelector</name></super><argument_list>()</argument_list> <block>{
            <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isSelected</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>target</name></decl></param>)</parameter_list> <block>{
                <return>return <expr>!<call><name><name>target</name>.<name>isExists</name></name><argument_list>()</argument_list></call></expr>;</return>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>ResourceUtils</name>.<name>ResourceSelectorProvider</name></name></type>
        <name>MISSING_DIR_PROVIDER</name> =<init> <expr>new <class><super><name><name>ResourceUtils</name>.<name>ResourceSelectorProvider</name></name></super><argument_list>()</argument_list> <block>{
                <function><type><specifier>public</specifier> <name>ResourceSelector</name></type>
                    <name>getTargetSelectorForSource</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>sr</name></decl></param>)</parameter_list> <block>{
                    <return>return <expr><name>MISSING_SELECTOR</name></expr>;</return>
                }</block></function>
            }</block></class></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * If this flag is true, execute() will run most operations twice,
     * the first time with {@link #skipWriting skipWriting} set to
     * true and the second time with setting it to false.
     *
     * &lt;p&gt;The only situation in Ant's current code base where this is
     * ever going to be true is if the jar task has been configured
     * with a filesetmanifest other than "skip".&lt;/p&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>doubleFilePass</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/**
     * whether the methods should just perform some sort of dry-run.
     *
     * &lt;p&gt;Will only ever be true in the first pass if the task
     * performs two passes because {@link #doubleFilePass
     * doubleFilePass} is true.&lt;/p&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>skipWriting</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether this is the first time the archive building methods are invoked.
     *
     * @return true if either {@link #doubleFilePass doubleFilePass}
     * is false or {@link #skipWriting skipWriting} is true.
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>isFirstPass</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr>!<name>doubleFilePass</name> || <name>skipWriting</name></expr>;</return>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>FileUtils</name></type> <name>FILE_UTILS</name> =<init> <expr><call><name><name>FileUtils</name>.<name>getFileUtils</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// CheckStyle:VisibilityModifier ON</comment>

    <comment type="line">// This boolean is set if the task detects that the</comment>
    <comment type="line">// target is outofdate and has written to the target file.</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>updatedFile</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * true when we are adding new files into the Zip file, as opposed
     * to adding back the unchanged files
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>addingNewFiles</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Encoding to use for filenames, defaults to the platform's
     * default encoding.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>encoding</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether the original compression of entries coming from a ZIP
     * archive should be kept (for example when updating an archive).
     *
     * @since Ant 1.6
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>keepCompression</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether the file modification times will be rounded up to the
     * next even number of seconds.
     *
     * @since Ant 1.6.2
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>roundUp</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Comment for the archive.
     * @since Ant 1.6.3
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>comment</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>level</name> =<init> <expr><name><name>ZipOutputStream</name>.<name>DEFAULT_COMPRESSION</name></name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Assume 0 Unix mode is intentional.
     * @since Ant 1.8.0
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>preserve0Permissions</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether to set the language encoding flag when creating the archive.
     *
     * @since Ant 1.8.0
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>useLanguageEncodingFlag</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether to add unicode extra fields.
     *
     * @since Ant 1.8.0
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>UnicodeExtraField</name></type> <name>createUnicodeExtraFields</name> =<init>
        <expr><name><name>UnicodeExtraField</name>.<name>NEVER</name></name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether to fall back to UTF-8 if a name cannot be encoded using
     * the specified encoding.
     *
     * @since Ant 1.8.0
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>fallBackToUTF8</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether to enable Zip64 extensions.
     *
     * @since Ant 1.9.1
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Zip64ModeAttribute</name></type> <name>zip64Mode</name> =<init> <expr><name><name>Zip64ModeAttribute</name>.<name>AS_NEEDED</name></name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This is the name/location of where to
     * create the .zip file.
     * @param zipFile the path of the zipFile
     * @deprecated since 1.5.x.
     *             Use setDestFile(File) instead.
     * @ant.attribute ignore="true"
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setZipfile</name><parameter_list>(<param><decl><type><name>File</name></type> <name>zipFile</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>setDestFile</name><argument_list>(<argument><expr><name>zipFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * This is the name/location of where to
     * create the file.
     * @param file the path of the zipFile
     * @since Ant 1.5
     * @deprecated since 1.5.x.
     *             Use setDestFile(File) instead.
     * @ant.attribute ignore="true"
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFile</name><parameter_list>(<param><decl><type><name>File</name></type> <name>file</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>setDestFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * The file to create; required.
     * @since Ant 1.5
     * @param destFile The new destination File
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDestFile</name><parameter_list>(<param><decl><type><name>File</name></type> <name>destFile</name></decl></param>)</parameter_list> <block>{
       <expr_stmt><expr><name><name>this</name>.<name>zipFile</name></name> = <name>destFile</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * The file to create.
     * @return the destination file
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>public</specifier> <name>File</name></type> <name>getDestFile</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>zipFile</name></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Directory from which to archive files; optional.
     * @param baseDir the base directory
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setBasedir</name><parameter_list>(<param><decl><type><name>File</name></type> <name>baseDir</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>baseDir</name></name> = <name>baseDir</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether we want to compress the files or only store them;
     * optional, default=true;
     * @param c if true, compress the files
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompress</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>doCompress</name> = <name>c</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether we want to compress the files or only store them;
     * @return true if the files are to be compressed
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isCompress</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>doCompress</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * If true, emulate Sun's jar utility by not adding parent directories;
     * optional, defaults to false.
     * @param f if true, emulate sun's jar by not adding parent directories
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFilesonly</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>f</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>doFilesonly</name> = <name>f</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, updates an existing file, otherwise overwrite
     * any existing one; optional defaults to false.
     * @param c if true, updates an existing zip file
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setUpdate</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>doUpdate</name> = <name>c</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>savedDoUpdate</name> = <name>c</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Are we updating an existing archive?
     * @return true if updating an existing archive
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isInUpdateMode</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>doUpdate</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a set of files.
     * @param set the fileset to add
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addFileset</name><parameter_list>(<param><decl><type><name>FileSet</name></type> <name>set</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a set of files that can be
     * read from an archive and be given a prefix/fullpath.
     * @param set the zipfileset to add
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addZipfileset</name><parameter_list>(<param><decl><type><name>ZipFileSet</name></type> <name>set</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add a collection of resources to be archived.
     * @param a the resources to archive
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>ResourceCollection</name></type> <name>a</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>resources</name>.<name>add</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a group of zip files.
     * @param set the group (a fileset) to add
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addZipGroupFileset</name><parameter_list>(<param><decl><type><name>FileSet</name></type> <name>set</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>groupfilesets</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Sets behavior for when a duplicate file is about to be added -
     * one of &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;preserve&lt;/code&gt; or &lt;code&gt;fail&lt;/code&gt;.
     * Possible values are: &lt;code&gt;add&lt;/code&gt; (keep both
     * of the files); &lt;code&gt;preserve&lt;/code&gt; (keep the first version
     * of the file found); &lt;code&gt;fail&lt;/code&gt; halt a problem
     * Default for zip tasks is &lt;code&gt;add&lt;/code&gt;
     * @param df a &lt;code&gt;Duplicate&lt;/code&gt; enumerated value
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDuplicate</name><parameter_list>(<param><decl><type><name>Duplicate</name></type> <name>df</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>duplicate</name> = <call><name><name>df</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Possible behaviors when there are no matching files for the task:
     * "fail", "skip", or "create".
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>WhenEmpty</name> <super><extends>extends <name>EnumeratedAttribute</name></extends></super> <block>{
        <comment type="javadoc">/**
         * The string values for the enumerated value
         * @return the values
         */</comment>
        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getValues</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>new <name><name>String</name><index>[]</index></name> <block>{<expr>"fail"</expr>, <expr>"skip"</expr>, <expr>"create"</expr>}</block></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Sets behavior of the task when no files match.
     * Possible values are: &lt;code&gt;fail&lt;/code&gt; (throw an exception
     * and halt the build); &lt;code&gt;skip&lt;/code&gt; (do not create
     * any archive, but issue a warning); &lt;code&gt;create&lt;/code&gt;
     * (make an archive with no entries).
     * Default for zip tasks is &lt;code&gt;skip&lt;/code&gt;;
     * for jar tasks, &lt;code&gt;create&lt;/code&gt;.
     * @param we a &lt;code&gt;WhenEmpty&lt;/code&gt; enumerated value
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setWhenempty</name><parameter_list>(<param><decl><type><name>WhenEmpty</name></type> <name>we</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>emptyBehavior</name> = <call><name><name>we</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Encoding to use for filenames, defaults to the platform's
     * default encoding.
     *
     * &lt;p&gt;For a list of possible values see &lt;a
     * href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html"&gt;http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html&lt;/a&gt;.&lt;/p&gt;
     * @param encoding the encoding name
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setEncoding</name><parameter_list>(<param><decl><type><name>String</name></type> <name>encoding</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>encoding</name></name> = <name>encoding</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Encoding to use for filenames.
     * @return the name of the encoding to use
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getEncoding</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>encoding</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Whether the original compression of entries coming from a ZIP
     * archive should be kept (for example when updating an archive).
     * Default is false.
     * @param keep if true, keep the original compression
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setKeepCompression</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>keep</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>keepCompression</name> = <name>keep</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Comment to use for archive.
     *
     * @param comment The content of the comment.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setComment</name><parameter_list>(<param><decl><type><name>String</name></type> <name>comment</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>comment</name></name> = <name>comment</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Comment of the archive
     *
     * @return Comment of the archive.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getComment</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>comment</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set the compression level to use.  Default is
     * ZipOutputStream.DEFAULT_COMPRESSION.
     * @param level compression level.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setLevel</name><parameter_list>(<param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>level</name></name> = <name>level</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Get the compression level.
     * @return compression level.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getLevel</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>level</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Whether the file modification times will be rounded up to the
     * next even number of seconds.
     *
     * &lt;p&gt;Zip archives store file modification times with a
     * granularity of two seconds, so the times will either be rounded
     * up or down.  If you round down, the archive will always seem
     * out-of-date when you rerun the task, so the default is to round
     * up.  Rounding up may lead to a different type of problems like
     * JSPs inside a web archive that seem to be slightly more recent
     * than precompiled pages, rendering precompilation useless.&lt;/p&gt;
     * @param r a &lt;code&gt;boolean&lt;/code&gt; value
     * @since Ant 1.6.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setRoundUp</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>r</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>roundUp</name> = <name>r</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Assume 0 Unix mode is intentional.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setPreserve0Permissions</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>preserve0Permissions</name> = <name>b</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Assume 0 Unix mode is intentional.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getPreserve0Permissions</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>preserve0Permissions</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Whether to set the language encoding flag.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setUseLanguageEncodingFlag</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>useLanguageEncodingFlag</name> = <name>b</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether the language encoding flag will be used.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getUseLanguageEnodingFlag</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>useLanguageEncodingFlag</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Whether Unicode extra fields will be created.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCreateUnicodeExtraFields</name><parameter_list>(<param><decl><type><name>UnicodeExtraField</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>createUnicodeExtraFields</name> = <name>b</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether Unicode extra fields will be created.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>UnicodeExtraField</name></type> <name>getCreateUnicodeExtraFields</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>createUnicodeExtraFields</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Whether to fall back to UTF-8 if a name cannot be encoded using
     * the specified encoding.
     *
     * &lt;p&gt;Defaults to false.&lt;/p&gt;
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFallBackToUTF8</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>fallBackToUTF8</name> = <name>b</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether to fall back to UTF-8 if a name cannot be encoded using
     * the specified encoding.
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getFallBackToUTF8</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>fallBackToUTF8</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Whether Zip64 extensions should be used.
     * @since Ant 1.9.1
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setZip64Mode</name><parameter_list>(<param><decl><type><name>Zip64ModeAttribute</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>zip64Mode</name> = <name>b</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether Zip64 extensions will be used.
     * @since Ant 1.9.1
     */</comment>
    <function><type><specifier>public</specifier> <name>Zip64ModeAttribute</name></type> <name>getZip64Mode</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>zip64Mode</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * validate and build
     * @throws BuildException on error
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{

        <if>if <condition>(<expr><name>doubleFilePass</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>skipWriting</name> = true</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>executeMain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>skipWriting</name> = false</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>executeMain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>executeMain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Get the value of the updatedFile attribute.
     * This should only be called after executeMain has been
     * called.
     * @return true if executeMain has written to the zip file.
     */</comment>
    <function><type><specifier>protected</specifier> <name>boolean</name></type> <name>hasUpdatedFile</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>updatedFile</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Build the zip file.
     * This is called twice if doubleFilePass is true.
     * @throws BuildException on error
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>executeMain</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{

        <expr_stmt><expr><call><name>checkAttributesAndElements</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Renamed version of original file, if it exists</comment>
        <decl_stmt><decl><type><name>File</name></type> <name>renamedFile</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>addingNewFiles</name> = true</expr>;</expr_stmt>

        <expr_stmt><expr><call><name>processDoUpdate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>processGroupFilesets</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// collect filesets to pass them to getResourcesToAdd</comment>
        <decl_stmt><decl><type><name><name>Vector</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name></type> <name>vfss</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>baseDir</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>FileSet</name></type> <name>fs</name> =<init> <expr>(<name>FileSet</name>) <call><name>getImplicitFileSet</name><argument_list>()</argument_list></call>.<call><name>clone</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>fs</name>.<name>setDir</name></name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>vfss</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name> =<init> <expr><call><name><name>resources</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>ResourceCollection</name></type> <name>rc</name> =<init> <expr>(<name>ResourceCollection</name>) <call><name><name>resources</name>.<name>elementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>vfss</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <decl_stmt><decl><type><name>ResourceCollection</name><index>[]</index></type> <name>fss</name> =<init> <expr>new <name><name>ResourceCollection</name><index>[<expr><call><name><name>vfss</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>vfss</name>.<name>copyInto</name></name><argument_list>(<argument><expr><name>fss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>success</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <comment type="line">// can also handle empty archives</comment>
            <decl_stmt><decl><type><name>ArchiveState</name></type> <name>state</name> =<init> <expr><call><name>getResourcesToAdd</name><argument_list>(<argument><expr><name>fss</name></expr></argument>, <argument><expr><name>zipFile</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// quick exit if the target is up to date</comment>
            <if>if <condition>(<expr>!<call><name><name>state</name>.<name>isOutOfDate</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <return>return;</return>
            }</block></then></if>

            <decl_stmt><decl><type><name>File</name></type> <name>parent</name> =<init> <expr><call><name><name>zipFile</name>.<name>getParentFile</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>parent</name> != <name>null</name> &amp;&amp; !<call><name><name>parent</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>parent</name>.<name>mkdirs</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Failed to create missing parent"
                                         + " directory for " + <name>zipFile</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>

            <expr_stmt><expr><name>updatedFile</name> = true</expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>zipFile</name>.<name>exists</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>state</name>.<name>isWithoutAnyResources</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>createEmptyZip</name><argument_list>(<argument><expr><name>zipFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>
            <decl_stmt><decl><type><name>Resource</name><index>[]</index><index>[]</index></type> <name>addThem</name> =<init> <expr><call><name><name>state</name>.<name>getResourcesToAdd</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>doUpdate</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>renamedFile</name> = <call><name>renameFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <decl_stmt><decl><type><name>String</name></type> <name>action</name> =<init> <expr><name>doUpdate</name> ? "Updating " : "Building "</expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<name>skipWriting</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>action</name> + <name>archiveType</name> + ": " + <call><name><name>zipFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <decl_stmt><decl><type><name>ZipOutputStream</name></type> <name>zOut</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <if>if <condition>(<expr>!<name>skipWriting</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>zOut</name> = new <call><name>ZipOutputStream</name><argument_list>(<argument><expr><name>zipFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name><name>zOut</name>.<name>setEncoding</name></name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>zOut</name>.<name>setUseLanguageEncodingFlag</name></name><argument_list>(<argument><expr><name>useLanguageEncodingFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>zOut</name>.<name>setCreateUnicodeExtraFields</name></name><argument_list>(<argument><expr><call><name><name>createUnicodeExtraFields</name>.
                                                     <name>getPolicy</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>zOut</name>.<name>setFallbackToUTF8</name></name><argument_list>(<argument><expr><name>fallBackToUTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>zOut</name>.<name>setMethod</name></name><argument_list>(<argument><expr><name>doCompress</name>
                        ? <name><name>ZipOutputStream</name>.<name>DEFLATED</name></name> : <name><name>ZipOutputStream</name>.<name>STORED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>zOut</name>.<name>setLevel</name></name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>zOut</name>.<name>setUseZip64</name></name><argument_list>(<argument><expr><call><name><name>zip64Mode</name>.<name>getMode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>initZipOutputStream</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Add the explicit resource collections to the archive.</comment>
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>fss</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <if>if <condition>(<expr><name><name>addThem</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name> != 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>addResources</name><argument_list>(<argument><expr><name><name>fss</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>addThem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>

                <if>if <condition>(<expr><name>doUpdate</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>addingNewFiles</name> = false</expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>ZipFileSet</name></type> <name>oldFiles</name> =<init> <expr>new <call><name>ZipFileSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>oldFiles</name>.<name>setProject</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>oldFiles</name>.<name>setSrc</name></name><argument_list>(<argument><expr><name>renamedFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>oldFiles</name>.<name>setDefaultexcludes</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>addSize</name> =<init> <expr><call><name><name>addedFiles</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>addSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                        <decl_stmt><decl><type><name><name>PatternSet</name>.<name>NameEntry</name></name></type> <name>ne</name> =<init> <expr><call><name><name>oldFiles</name>.<name>createExclude</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>ne</name>.<name>setName</name></name><argument_list>(<argument><expr>(<name>String</name>) <call><name><name>addedFiles</name>.<name>elementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>
                    <decl_stmt><decl><type><name>DirectoryScanner</name></type> <name>ds</name> =<init>
                        <expr><call><name><name>oldFiles</name>.<name>getDirectoryScanner</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr>((<name>ZipScanner</name>) <name>ds</name>).<call><name>setEncoding</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>f</name> =<init> <expr><call><name><name>ds</name>.<name>getIncludedFiles</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Resource</name><index>[]</index></type> <name>r</name> =<init> <expr>new <name><name>Resource</name><index>[<expr><name><name>f</name>.<name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>f</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                        <expr_stmt><expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name><name>ds</name>.<name>getResource</name></name><argument_list>(<argument><expr><name><name>f</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>

                    <if>if <condition>(<expr>!<name>doFilesonly</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>d</name> =<init> <expr><call><name><name>ds</name>.<name>getIncludedDirectories</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Resource</name><index>[]</index></type> <name>dr</name> =<init> <expr>new <name><name>Resource</name><index>[<expr><name><name>d</name>.<name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>d</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                            <expr_stmt><expr><name><name>dr</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name><name>ds</name>.<name>getResource</name></name><argument_list>(<argument><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></for>
                        <decl_stmt><decl><type><name>Resource</name><index>[]</index></type> <name>tmp</name> =<init> <expr><name>r</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>r</name> = new <name><name>Resource</name><index>[<expr><name><name>tmp</name>.<name>length</name></name> + <name><name>dr</name>.<name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>dr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>dr</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>dr</name>.<name>length</name></name></expr></argument>, <argument><expr><name><name>tmp</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><call><name>addResources</name><argument_list>(<argument><expr><name>oldFiles</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>zOut</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>zOut</name>.<name>setComment</name></name><argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>finalizeZipOutputStream</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// If we've been successful on an update, delete the</comment>
                <comment type="line">// temporary file</comment>
                <if>if <condition>(<expr><name>doUpdate</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name><name>renamedFile</name>.<name>delete</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>log</name> <argument_list>(<argument><expr>"Warning: unable to delete temporary file "
                            + <call><name><name>renamedFile</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>success</name> = true</expr>;</expr_stmt>
            }</block> <finally>finally <block>{
                <comment type="line">// Close the output stream.</comment>
                <expr_stmt><expr><call><name>closeZout</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></finally></try>
        }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ioe</name></decl></param>) <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>msg</name> =<init> <expr>"Problem creating " + <name>archiveType</name> + ": "
                + <call><name><name>ioe</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// delete a bogus ZIP file (but only if it's not the original one)</comment>
            <if>if <condition>(<expr>(!<name>doUpdate</name> || <name>renamedFile</name> != <name>null</name>) &amp;&amp; !<call><name><name>zipFile</name>.<name>delete</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>msg</name> += " (and the archive is probably corrupt but I could not "
                    + "delete it)"</expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>doUpdate</name> &amp;&amp; <name>renamedFile</name> != <name>null</name></expr>)</condition><then> <block>{
                <try>try <block>{
                    <expr_stmt><expr><call><name><name>FILE_UTILS</name>.<name>rename</name></name><argument_list>(<argument><expr><name>renamedFile</name></expr></argument>, <argument><expr><name>zipFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>) <block>{
                    <expr_stmt><expr><name>msg</name> += " (and I couldn't rename the temporary file "
                            + <call><name><name>renamedFile</name>.<name>getName</name></name><argument_list>()</argument_list></call> + " back)"</expr>;</expr_stmt>
                }</block></catch></try>
            }</block></then></if>

            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ioe</name></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <finally>finally <block>{
            <expr_stmt><expr><call><name>cleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/** rename the zip file. */</comment>
    <function><type><specifier>private</specifier> <name>File</name></type> <name>renameFile</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>File</name></type> <name>renamedFile</name> =<init> <expr><call><name><name>FILE_UTILS</name>.<name>createTempFile</name></name><argument_list>(
            <argument><expr>"zip"</expr></argument>, <argument><expr>".tmp"</expr></argument>, <argument><expr><call><name><name>zipFile</name>.<name>getParentFile</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <expr_stmt><expr><call><name><name>FILE_UTILS</name>.<name>rename</name></name><argument_list>(<argument><expr><name>zipFile</name></expr></argument>, <argument><expr><name>renamedFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>SecurityException</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                <argument><expr>"Not allowed to rename old file ("
                + <call><name><name>zipFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call>
                + ") to temporary file"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                <argument><expr>"Unable to rename old file ("
                + <call><name><name>zipFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call>
                + ") to temporary file"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <return>return <expr><name>renamedFile</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/** Close zout */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>closeZout</name><parameter_list>(<param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>success</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>zOut</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <try>try <block>{
            <expr_stmt><expr><call><name><name>zOut</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ex</name></decl></param>) <block>{
            <comment type="line">// If we're in this finally clause because of an</comment>
            <comment type="line">// exception, we don't really care if there's an</comment>
            <comment type="line">// exception when closing the stream. E.g. if it</comment>
            <comment type="line">// throws "ZIP file must have at least one entry",</comment>
            <comment type="line">// because an exception happened before we added</comment>
            <comment type="line">// any files, then we must swallow this</comment>
            <comment type="line">// exception. Otherwise, the error that's reported</comment>
            <comment type="line">// will be the close() error, which is not the</comment>
            <comment type="line">// real cause of the problem.</comment>
            <if>if <condition>(<expr><name>success</name></expr>)</condition><then> <block>{
                <throw>throw <expr><name>ex</name></expr>;</throw>
            }</block></then></if>
        }</block></catch></try>
    }</block></function>

    <comment type="javadoc">/** Check the attributes and elements */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>checkAttributesAndElements</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>baseDir</name> == <name>null</name> &amp;&amp; <call><name><name>resources</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0
            &amp;&amp; <call><name><name>groupfilesets</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0 &amp;&amp; "zip".<call><name>equals</name><argument_list>(<argument><expr><name>archiveType</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"basedir attribute must be set, "
                                     + "or at least one "
                                     + "resource collection must be given!"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <if>if <condition>(<expr><name>zipFile</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"You must specify the "
                                     + <name>archiveType</name> + " file to create!"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>zipFile</name>.<name>exists</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>zipFile</name>.<name>isFile</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>zipFile</name> + " is not a file."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>zipFile</name>.<name>exists</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>zipFile</name>.<name>canWrite</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>zipFile</name> + " is read-only."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/** Process doupdate */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>processDoUpdate</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// Whether or not an actual update is required -</comment>
        <comment type="line">// we don't need to update if the original file doesn't exist</comment>
        <if>if <condition>(<expr><name>doUpdate</name> &amp;&amp; !<call><name><name>zipFile</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>doUpdate</name> = false</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr>"ignoring update attribute as " + <name>archiveType</name>
                           + " doesn't exist."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_DEBUG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/** Process groupfilesets */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>processGroupFilesets</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// Add the files found in groupfileset to fileset</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name> =<init> <expr><call><name><name>groupfilesets</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{

            <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr>"Processing groupfileset "</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>FileSet</name></type> <name>fs</name> =<init> <expr>(<name>FileSet</name>) <call><name><name>groupfilesets</name>.<name>elementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>FileScanner</name></type> <name>scanner</name> =<init> <expr><call><name><name>fs</name>.<name>getDirectoryScanner</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>files</name> =<init> <expr><call><name><name>scanner</name>.<name>getIncludedFiles</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>File</name></type> <name>basedir</name> =<init> <expr><call><name><name>scanner</name>.<name>getBasedir</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name><name>files</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{

                <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr>"Adding file " + <name><name>files</name><index>[<expr><name>j</name></expr>]</index></name> + " to fileset"</expr></argument>,
                               <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>ZipFileSet</name></type> <name>zf</name> =<init> <expr>new <call><name>ZipFileSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>zf</name>.<name>setProject</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>zf</name>.<name>setSrc</name></name><argument_list>(<argument><expr>new <call><name>File</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name><name>files</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>zf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>filesetsFromGroupfilesets</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>zf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Indicates if the task is adding new files into the archive as opposed to
     * copying back unchanged files from the backup copy
     * @return true if adding new files
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>isAddingNewFiles</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>addingNewFiles</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Add the given resources.
     *
     * @param fileset may give additional information like fullpath or
     * permissions.
     * @param resources the resources to add
     * @param zOut the stream to write to
     * @throws IOException on error
     *
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>void</name></type> <name>addResources</name><parameter_list>(<param><decl><type><name>FileSet</name></type> <name>fileset</name></decl></param>, <param><decl><type><name><name>Resource</name><index>[]</index></name></type> <name>resources</name></decl></param>,
                                      <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{

        <decl_stmt><decl><type><name>String</name></type> <name>prefix</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>fullpath</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>dirMode</name> =<init> <expr><name><name>ArchiveFileSet</name>.<name>DEFAULT_DIR_MODE</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>fileMode</name> =<init> <expr><name><name>ArchiveFileSet</name>.<name>DEFAULT_FILE_MODE</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>ArchiveFileSet</name></type> <name>zfs</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>fileset</name> <name>instanceof</name> <name>ArchiveFileSet</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>zfs</name> = (<name>ArchiveFileSet</name>) <name>fileset</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>prefix</name> = <call><name><name>zfs</name>.<name>getPrefix</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>fullpath</name> = <call><name><name>zfs</name>.<name>getFullpath</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dirMode</name> = <call><name><name>zfs</name>.<name>getDirMode</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>fileMode</name> = <call><name><name>zfs</name>.<name>getFileMode</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>prefix</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0 &amp;&amp; <call><name><name>fullpath</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Both prefix and fullpath attributes must"
                                     + " not be set on the same fileset."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>resources</name>.<name>length</name></name> != 1 &amp;&amp; <call><name><name>fullpath</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"fullpath attribute may only be specified"
                                     + " for filesets that specify a single"
                                     + " file."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>prefix</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name><name>prefix</name>.<name>endsWith</name></name><argument_list>(<argument><expr>"/"</expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>prefix</name>.<name>endsWith</name></name><argument_list>(<argument><expr>"\\"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>prefix</name> += "/"</expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>addParentDirs</name><argument_list>(<argument><expr><name>null</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>dirMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>ZipFile</name></type> <name>zf</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <decl_stmt><decl><type><name>boolean</name></type> <name>dealingWithFiles</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>File</name></type> <name>base</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>zfs</name> == <name>null</name> || <call><name><name>zfs</name>.<name>getSrc</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>dealingWithFiles</name> = true</expr>;</expr_stmt>
                <expr_stmt><expr><name>base</name> = <call><name><name>fileset</name>.<name>getDir</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>zfs</name> <name>instanceof</name> <name>ZipFileSet</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>zf</name> = new <call><name>ZipFile</name><argument_list>(<argument><expr><call><name><name>zfs</name>.<name>getSrc</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>resources</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>fullpath</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>name</name> = <name>fullpath</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>name</name> = <name><name>resources</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>getName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><name>name</name> = <call><name><name>name</name>.<name>replace</name></name><argument_list>(<argument><expr><name><name>File</name>.<name>separatorChar</name></name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr>"".<call><name>equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <continue>continue;</continue>
                }</block></then></if>

                <if>if <condition>(<expr><name><name>resources</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>isDirectory</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>doFilesonly</name></expr>)</condition><then> <block>{
                        <continue>continue;</continue>
                    }</block></then></if>
                    <decl_stmt><decl><type><name>int</name></type> <name>thisDirMode</name> =<init> <expr><name>zfs</name> != <name>null</name> &amp;&amp; <call><name><name>zfs</name>.<name>hasDirModeBeenSet</name></name><argument_list>()</argument_list></call>
                        ? <name>dirMode</name> : <call><name>getUnixMode</name><argument_list>(<argument><expr><name><name>resources</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zf</name></expr></argument>, <argument><expr><name>dirMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>addDirectoryResource</name><argument_list>(<argument><expr><name><name>resources</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>,
                                         <argument><expr><name>base</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>,
                                         <argument><expr><name>dirMode</name></expr></argument>, <argument><expr><name>thisDirMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                }</block></then> <else>else <block>{ <comment type="line">// !isDirectory</comment>

                    <expr_stmt><expr><call><name>addParentDirs</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>dirMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if>if <condition>(<expr><name>dealingWithFiles</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>File</name></type> <name>f</name> =<init> <expr><call><name><name>FILE_UTILS</name>.<name>resolveFile</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>,
                                                        <argument><expr><name><name>resources</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>zipFile</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>prefix</name> + <name>name</name></expr></argument>, <argument><expr><name>fileMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>thisFileMode</name> =<init>
                            <expr><name>zfs</name> != <name>null</name> &amp;&amp; <call><name><name>zfs</name>.<name>hasFileModeBeenSet</name></name><argument_list>()</argument_list></call>
                            ? <name>fileMode</name> : <call><name>getUnixMode</name><argument_list>(<argument><expr><name><name>resources</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zf</name></expr></argument>,
                                                     <argument><expr><name>fileMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>addResource</name><argument_list>(<argument><expr><name><name>resources</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>,
                                    <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>thisFileMode</name></expr></argument>, <argument><expr><name>zf</name></expr></argument>,
                                    <argument><expr><name>zfs</name> == <name>null</name>
                                    ? <name>null</name> : <call><name><name>zfs</name>.<name>getSrc</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></else></if>
            }</block></for>
        }</block> <finally>finally <block>{
            <if>if <condition>(<expr><name>zf</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>zf</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * Add a directory entry to the archive using a specified
     * Unix-mode and the default mode for its parent directories (if
     * necessary).
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>addDirectoryResource</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>r</name></decl></param>, <param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>String</name></type> <name>prefix</name></decl></param>,
                                      <param><decl><type><name>File</name></type> <name>base</name></decl></param>, <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>,
                                      <param><decl><type><name>int</name></type> <name>defaultDirMode</name></decl></param>, <param><decl><type><name>int</name></type> <name>thisDirMode</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{

        <if>if <condition>(<expr>!<call><name><name>name</name>.<name>endsWith</name></name><argument_list>(<argument><expr>"/"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>name</name> = <name>name</name> + "/"</expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name>nextToLastSlash</name> =<init> <expr><call><name><name>name</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr>"/"</expr></argument>, <argument><expr><call><name><name>name</name>.<name>length</name></name><argument_list>()</argument_list></call> - 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>nextToLastSlash</name> != -1</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>addParentDirs</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><call><name><name>name</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>nextToLastSlash</name> + 1</expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>defaultDirMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>zipDir</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>prefix</name> + <name>name</name></expr></argument>, <argument><expr><name>thisDirMode</name></expr></argument>,
               <argument><expr><name>r</name> <name>instanceof</name> <name>ZipResource</name>
               ? ((<name>ZipResource</name>) <name>r</name>).<call><name>getExtraFields</name><argument_list>()</argument_list></call> : <name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Determine a Resource's Unix mode or return the given default
     * value if not available.
     */</comment>
    <function><type><specifier>private</specifier> <name>int</name></type> <name>getUnixMode</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>r</name></decl></param>, <param><decl><type><name>ZipFile</name></type> <name>zf</name></decl></param>, <param><decl><type><name>int</name></type> <name>defaultMode</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{

        <decl_stmt><decl><type><name>int</name></type> <name>unixMode</name> =<init> <expr><name>defaultMode</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>zf</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>ZipEntry</name></type> <name>ze</name> =<init> <expr><call><name><name>zf</name>.<name>getEntry</name></name><argument_list>(<argument><expr><call><name><name>r</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>unixMode</name> = <call><name><name>ze</name>.<name>getUnixMode</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>unixMode</name> == 0 || <name>unixMode</name> == <name><name>UnixStat</name>.<name>DIR_FLAG</name></name>)
                &amp;&amp; !<name>preserve0Permissions</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>unixMode</name> = <name>defaultMode</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><name>r</name> <name>instanceof</name> <name>ArchiveResource</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>unixMode</name> = ((<name>ArchiveResource</name>) <name>r</name>).<call><name>getMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <return>return <expr><name>unixMode</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Add a file entry.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>addResource</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>r</name></decl></param>, <param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>String</name></type> <name>prefix</name></decl></param>,
                             <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>,
                             <param><decl><type><name>ZipFile</name></type> <name>zf</name></decl></param>, <param><decl><type><name>File</name></type> <name>fromArchive</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{

        <if>if <condition>(<expr><name>zf</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>ZipEntry</name></type> <name>ze</name> =<init> <expr><call><name><name>zf</name>.<name>getEntry</name></name><argument_list>(<argument><expr><call><name><name>r</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>ze</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>boolean</name></type> <name>oldCompress</name> =<init> <expr><name>doCompress</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>keepCompression</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>doCompress</name> = (<call><name><name>ze</name>.<name>getMethod</name></name><argument_list>()</argument_list></call> == <name><name>ZipEntry</name>.<name>DEFLATED</name></name>)</expr>;</expr_stmt>
                }</block></then></if>
                <decl_stmt><decl><type><name>InputStream</name></type> <name>is</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
                <try>try <block>{
                    <expr_stmt><expr><name>is</name> = <call><name><name>zf</name>.<name>getInputStream</name></name><argument_list>(<argument><expr><name>ze</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>zipFile</name><argument_list>(<argument><expr><name>is</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>prefix</name> + <name>name</name></expr></argument>, <argument><expr><call><name><name>ze</name>.<name>getTime</name></name><argument_list>()</argument_list></call></expr></argument>,
                            <argument><expr><name>fromArchive</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><call><name><name>ze</name>.<name>getExtraFields</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> <finally>finally <block>{
                    <expr_stmt><expr><name>doCompress</name> = <name>oldCompress</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>FileUtils</name>.<name>close</name></name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></finally></try>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>InputStream</name></type> <name>is</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <expr_stmt><expr><name>is</name> = <call><name><name>r</name>.<name>getInputStream</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>zipFile</name><argument_list>(<argument><expr><name>is</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>prefix</name> + <name>name</name></expr></argument>, <argument><expr><call><name><name>r</name>.<name>getLastModified</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><name>fromArchive</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>r</name> <name>instanceof</name> <name>ZipResource</name>
                        ? ((<name>ZipResource</name>) <name>r</name>).<call><name>getExtraFields</name><argument_list>()</argument_list></call> : <name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <finally>finally <block>{
                <expr_stmt><expr><call><name><name>FileUtils</name>.<name>close</name></name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></finally></try>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Add the given resources.
     *
     * @param rc may give additional information like fullpath or
     * permissions.
     * @param resources the resources to add
     * @param zOut the stream to write to
     * @throws IOException on error
     *
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>void</name></type> <name>addResources</name><parameter_list>(<param><decl><type><name>ResourceCollection</name></type> <name>rc</name></decl></param>,
                                      <param><decl><type><name><name>Resource</name><index>[]</index></name></type> <name>resources</name></decl></param>,
                                      <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>rc</name> <name>instanceof</name> <name>FileSet</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>addResources</name><argument_list>(<argument><expr>(<name>FileSet</name>) <name>rc</name></expr></argument>, <argument><expr><name>resources</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>resources</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>Resource</name></type> <name>resource</name> =<init> <expr><name><name>resources</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><call><name><name>resource</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>name</name> == <name>null</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>name</name> = <call><name><name>name</name>.<name>replace</name></name><argument_list>(<argument><expr><name><name>File</name>.<name>separatorChar</name></name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr>"".<call><name>equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>resource</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>doFilesonly</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <decl_stmt><decl><type><name>File</name></type> <name>base</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>FileProvider</name></type> <name>fp</name> =<init> <expr><call><name><name>resource</name>.<name>as</name></name><argument_list>(<argument><expr><name><name>FileProvider</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>fp</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>base</name> = <call><name><name>ResourceUtils</name>.<name>asFileResource</name></name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call>.<call><name>getBaseDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><call><name><name>resource</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>addDirectoryResource</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>,
                                     <argument><expr><name><name>ArchiveFileSet</name>.<name>DEFAULT_DIR_MODE</name></name></expr></argument>,
                                     <argument><expr><name><name>ArchiveFileSet</name>.<name>DEFAULT_DIR_MODE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>addParentDirs</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr>""</expr></argument>,
                              <argument><expr><name><name>ArchiveFileSet</name>.<name>DEFAULT_DIR_MODE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>fp</name> != <name>null</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>File</name></type> <name>f</name> =<init> <expr>(<name>fp</name>).<call><name>getFile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>zipFile</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ArchiveFileSet</name>.<name>DEFAULT_FILE_MODE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>addResource</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>zOut</name></expr></argument>,
                                <argument><expr><name><name>ArchiveFileSet</name>.<name>DEFAULT_FILE_MODE</name></name></expr></argument>,
                                <argument><expr><name>null</name></expr></argument>, <argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * method for subclasses to override
     * @param zOut the zip output stream
     * @throws IOException on output error
     * @throws BuildException on other errors
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>initZipOutputStream</name><parameter_list>(<param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
    }</block></function>

    <comment type="javadoc">/**
     * method for subclasses to override
     * @param zOut the zip output stream
     * @throws IOException on output error
     * @throws BuildException on other errors
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>finalizeZipOutputStream</name><parameter_list>(<param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
    }</block></function>

    <comment type="javadoc">/**
     * Create an empty zip file
     * @param zipFile the zip file
     * @return true for historic reasons
     * @throws BuildException on error
     */</comment>
    <function><type><specifier>protected</specifier> <name>boolean</name></type> <name>createEmptyZip</name><parameter_list>(<param><decl><type><name>File</name></type> <name>zipFile</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <comment type="line">// In this case using java.util.zip will not work</comment>
        <comment type="line">// because it does not permit a zero-entry archive.</comment>
        <comment type="line">// Must create it manually.</comment>
        <if>if <condition>(<expr>!<name>skipWriting</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Note: creating empty " + <name>archiveType</name> + " archive " + <name>zipFile</name></expr></argument>,
                <argument><expr><name><name>Project</name>.<name>MSG_INFO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><name>OutputStream</name></type> <name>os</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <expr_stmt><expr><name>os</name> = new <call><name>FileOutputStream</name><argument_list>(<argument><expr><name>zipFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// CheckStyle:MagicNumber OFF</comment>
            <comment type="line">// Cf. PKZIP specification.</comment>
            <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>empty</name> =<init> <expr>new <name><name>byte</name><index>[<expr>22</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>empty</name><index>[<expr>0</expr>]</index></name> = 80</expr>;</expr_stmt> <comment type="line">// P</comment>
            <expr_stmt><expr><name><name>empty</name><index>[<expr>1</expr>]</index></name> = 75</expr>;</expr_stmt> <comment type="line">// K</comment>
            <expr_stmt><expr><name><name>empty</name><index>[<expr>2</expr>]</index></name> = 5</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>empty</name><index>[<expr>3</expr>]</index></name> = 6</expr>;</expr_stmt>
            <comment type="line">// remainder zeros</comment>
            <comment type="line">// CheckStyle:MagicNumber ON</comment>
            <expr_stmt><expr><call><name><name>os</name>.<name>write</name></name><argument_list>(<argument><expr><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ioe</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Could not create empty ZIP archive "
                                     + "(" + <call><name><name>ioe</name>.<name>getMessage</name></name><argument_list>()</argument_list></call> + ")"</expr></argument>, <argument><expr><name>ioe</name></expr></argument>,
                                     <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <finally>finally <block>{
            <expr_stmt><expr><call><name><name>FileUtils</name>.<name>close</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>private</specifier> <specifier>synchronized</specifier> <name>ZipScanner</name></type> <name>getZipScanner</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>zs</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>zs</name> = new <call><name>ZipScanner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>zs</name>.<name>setEncoding</name></name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>zs</name>.<name>setSrc</name></name><argument_list>(<argument><expr><name>zipFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>zs</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Collect the resources that are newer than the corresponding
     * entries (or missing) in the original archive.
     *
     * &lt;p&gt;If we are going to recreate the archive instead of updating
     * it, all resources should be considered as new, if a single one
     * is.  Because of this, subclasses overriding this method must
     * call &lt;code&gt;super.getResourcesToAdd&lt;/code&gt; and indicate with the
     * third arg if they already know that the archive is
     * out-of-date.&lt;/p&gt;
     *
     * &lt;p&gt;This method first delegates to getNonFileSetResourcesToAdd
     * and then invokes the FileSet-arg version.  All this to keep
     * backwards compatibility for subclasses that don't know how to
     * deal with non-FileSet ResourceCollections.&lt;/p&gt;
     *
     * @param rcs The resource collections to grab resources from
     * @param zipFile intended archive file (may or may not exist)
     * @param needsUpdate whether we already know that the archive is
     * out-of-date.  Subclasses overriding this method are supposed to
     * set this value correctly in their call to
     * &lt;code&gt;super.getResourcesToAdd&lt;/code&gt;.
     * @return an array of resources to add for each fileset passed in as well
     *         as a flag that indicates whether the archive is uptodate.
     *
     * @exception BuildException if it likes
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>protected</specifier> <name>ArchiveState</name></type> <name>getResourcesToAdd</name><parameter_list>(<param><decl><type><name><name>ResourceCollection</name><index>[]</index></name></type> <name>rcs</name></decl></param>,
                                             <param><decl><type><name>File</name></type> <name>zipFile</name></decl></param>,
                                             <param><decl><type><name>boolean</name></type> <name>needsUpdate</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name></type> <name>filesets</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name></type> <name>rest</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>rcs</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>rcs</name><index>[<expr><name>i</name></expr>]</index></name> <name>instanceof</name> <name>FileSet</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>filesets</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>rcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>rest</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>rcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <decl_stmt><decl><type><name>ResourceCollection</name><index>[]</index></type> <name>rc</name> =<init>
            <expr><call><name><name>rest</name>.<name>toArray</name></name><argument_list>(<argument><expr>new <name><name>ResourceCollection</name><index>[<expr><call><name><name>rest</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ArchiveState</name></type> <name>as</name> =<init> <expr><call><name>getNonFileSetResourcesToAdd</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>zipFile</name></expr></argument>,
                                                      <argument><expr><name>needsUpdate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>FileSet</name><index>[]</index></type> <name>fs</name> =<init> <expr>(<name><name>FileSet</name><index>[]</index></name>) <call><name><name>filesets</name>.<name>toArray</name></name><argument_list>(<argument><expr>new <name><name>FileSet</name><index>[<expr><call><name><name>filesets</name>
                                                                .<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ArchiveState</name></type> <name>as2</name> =<init> <expr><call><name>getResourcesToAdd</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>zipFile</name></expr></argument>, <argument><expr><call><name><name>as</name>.<name>isOutOfDate</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>as</name>.<name>isOutOfDate</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>as2</name>.<name>isOutOfDate</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Bad luck.
             *
             * There are resources in the filesets that make the
             * archive out of date, but not in the non-fileset
             * resources. We need to rescan the non-FileSets to grab
             * all of them now.
             */</comment>
            <expr_stmt><expr><name>as</name> = <call><name>getNonFileSetResourcesToAdd</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>zipFile</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>Resource</name><index>[]</index><index>[]</index></type> <name>toAdd</name> =<init> <expr>new <name><name>Resource</name><index>[<expr><name><name>rcs</name>.<name>length</name></name></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>fsIndex</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>restIndex</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>rcs</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>rcs</name><index>[<expr><name>i</name></expr>]</index></name> <name>instanceof</name> <name>FileSet</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>toAdd</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name><name>as2</name>.<name>getResourcesToAdd</name></name><argument_list>()</argument_list></call><index>[<expr><name>fsIndex</name>++</expr>]</index></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name><name>toAdd</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name><name>as</name>.<name>getResourcesToAdd</name></name><argument_list>()</argument_list></call><index>[<expr><name>restIndex</name>++</expr>]</index></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr><call><name><name>as2</name>.<name>isOutOfDate</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>toAdd</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * This is yet another hacky construct to extend the FileSet[]
     * getResourcesToAdd method so we can pass the information whether
     * non-fileset resources have been available to it without having
     * to move the withEmpty behavior checks (since either would break
     * subclasses in several ways).
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>ThreadLocal</name><argument_list>&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>HAVE_NON_FILE_SET_RESOURCES_TO_ADD</name> =<init> <expr>new <class><super><name><name>ThreadLocal</name><argument_list>&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
            <function><type><specifier>protected</specifier> <name>Boolean</name></type> <name>initialValue</name><parameter_list>()</parameter_list> <block>{
                <return>return <expr><name><name>Boolean</name>.<name>FALSE</name></name></expr>;</return>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Collect the resources that are newer than the corresponding
     * entries (or missing) in the original archive.
     *
     * &lt;p&gt;If we are going to recreate the archive instead of updating
     * it, all resources should be considered as new, if a single one
     * is.  Because of this, subclasses overriding this method must
     * call &lt;code&gt;super.getResourcesToAdd&lt;/code&gt; and indicate with the
     * third arg if they already know that the archive is
     * out-of-date.&lt;/p&gt;
     *
     * @param filesets The filesets to grab resources from
     * @param zipFile intended archive file (may or may not exist)
     * @param needsUpdate whether we already know that the archive is
     * out-of-date.  Subclasses overriding this method are supposed to
     * set this value correctly in their call to
     * &lt;code&gt;super.getResourcesToAdd&lt;/code&gt;.
     * @return an array of resources to add for each fileset passed in as well
     *         as a flag that indicates whether the archive is uptodate.
     *
     * @exception BuildException if it likes
     */</comment>
    <function><type><specifier>protected</specifier> <name>ArchiveState</name></type> <name>getResourcesToAdd</name><parameter_list>(<param><decl><type><name><name>FileSet</name><index>[]</index></name></type> <name>filesets</name></decl></param>,
                                             <param><decl><type><name>File</name></type> <name>zipFile</name></decl></param>,
                                             <param><decl><type><name>boolean</name></type> <name>needsUpdate</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{

        <decl_stmt><decl><type><name>Resource</name><index>[]</index><index>[]</index></type> <name>initialResources</name> =<init> <expr><call><name>grabResources</name><argument_list>(<argument><expr><name>filesets</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>Boolean</name>.<name>FALSE</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>HAVE_NON_FILE_SET_RESOURCES_TO_ADD</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>needsUpdate</name> &amp;&amp; <name>doUpdate</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * This is a rather hairy case.
                     *
                     * One of our subclasses knows that we need to
                     * update the archive, but at the same time, there
                     * are no resources known to us that would need to
                     * be added.  Only the subclass seems to know
                     * what's going on.
                     *
                     * This happens if &lt;jar&gt; detects that the manifest
                     * has changed, for example.  The manifest is not
                     * part of any resources because of our support
                     * for inline &lt;manifest&gt;s.
                     *
                     * If we invoke createEmptyZip like Ant 1.5.2 did,
                     * we'll loose all stuff that has been in the
                     * original archive (bugzilla report 17780).
                     */</comment>
                    <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>

                <if>if <condition>(<expr><call><name><name>emptyBehavior</name>.<name>equals</name></name><argument_list>(<argument><expr>"skip"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>doUpdate</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr><name>archiveType</name> + " archive " + <name>zipFile</name>
                                       + " not updated because no new files were"
                                       + " included."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr>"Warning: skipping " + <name>archiveType</name>
                                       + " archive " + <name>zipFile</name>
                                       + " because no files were included."</expr></argument>,
                                       <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>emptyBehavior</name>.<name>equals</name></name><argument_list>(<argument><expr>"fail"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Cannot create " + <name>archiveType</name>
                                             + " archive " + <name>zipFile</name>
                                             + ": no files were included."</expr></argument>,
                                             <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then> <else>else <block>{
                    <comment type="line">// Create.</comment>
                    <if>if <condition>(<expr>!<call><name><name>zipFile</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then>  <block>{
                        <expr_stmt><expr><name>needsUpdate</name> = true</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if></else></if>
            }</block></then></if>

            <comment type="line">// either there are non-fileset resources or we</comment>
            <comment type="line">// (re-)create the archive anyway</comment>
            <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr><name>needsUpdate</name></expr></argument>, <argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="line">// initialResources is not empty</comment>

        <if>if <condition>(<expr>!<call><name><name>zipFile</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>needsUpdate</name> &amp;&amp; !<name>doUpdate</name></expr>)</condition><then> <block>{
            <comment type="line">// we are recreating the archive, need all resources</comment>
            <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>Resource</name><index>[]</index><index>[]</index></type> <name>newerResources</name> =<init> <expr>new <name><name>Resource</name><index>[<expr><name><name>filesets</name>.<name>length</name></name></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>filesets</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>!(<name>fileset</name> <name>instanceof</name> <name>ZipFileSet</name>)
                || ((<name>ZipFileSet</name>) <name>fileset</name>).<call><name>getSrc</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>File</name></type> <name>base</name> =<init> <expr><name><name>filesets</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>getDir</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name><name>initialResources</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>File</name></type> <name>resourceAsFile</name> =<init>
                        <expr><call><name><name>FILE_UTILS</name>.<name>resolveFile</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>,
                                              <argument><expr><name><name>initialResources</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name>.<call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><call><name><name>resourceAsFile</name>.<name>equals</name></name><argument_list>(<argument><expr><name>zipFile</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"A zip file cannot include "
                                                 + "itself"</expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></then></if>
                }</block></for>
            }</block></then></if>
        }</block></for>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>filesets</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>initialResources</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>newerResources</name><index>[<expr><name>i</name></expr>]</index></name> = new <name><name>Resource</name><index>[]</index></name> <block>{}</block></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <decl_stmt><decl><type><name>FileNameMapper</name></type> <name>myMapper</name> =<init> <expr>new <call><name>IdentityMapper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>filesets</name><index>[<expr><name>i</name></expr>]</index></name> <name>instanceof</name> <name>ZipFileSet</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>ZipFileSet</name></type> <name>zfs</name> =<init> <expr>(<name>ZipFileSet</name>) <name><name>filesets</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>zfs</name>.<name>getFullpath</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> != <name>null</name>
                    &amp;&amp; !<call><name><name>zfs</name>.<name>getFullpath</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="line">// in this case all files from origin map to</comment>
                    <comment type="line">// the fullPath attribute of the zipfileset at</comment>
                    <comment type="line">// destination</comment>
                    <decl_stmt><decl><type><name>MergingMapper</name></type> <name>fm</name> =<init> <expr>new <call><name>MergingMapper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>fm</name>.<name>setTo</name></name><argument_list>(<argument><expr><call><name><name>zfs</name>.<name>getFullpath</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>myMapper</name> = <name>fm</name></expr>;</expr_stmt>

                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>zfs</name>.<name>getPrefix</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> != <name>null</name>
                           &amp;&amp; !<call><name><name>zfs</name>.<name>getPrefix</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>GlobPatternMapper</name></type> <name>gm</name> =<init> <expr>new <call><name>GlobPatternMapper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>gm</name>.<name>setFrom</name></name><argument_list>(<argument><expr>"*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>String</name></type> <name>prefix</name> =<init> <expr><call><name><name>zfs</name>.<name>getPrefix</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<call><name><name>prefix</name>.<name>endsWith</name></name><argument_list>(<argument><expr>"/"</expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>prefix</name>.<name>endsWith</name></name><argument_list>(<argument><expr>"\\"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>prefix</name> += "/"</expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><call><name><name>gm</name>.<name>setTo</name></name><argument_list>(<argument><expr><name>prefix</name> + "*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>myMapper</name> = <name>gm</name></expr>;</expr_stmt>
                }</block></then></if></else></if>
            }</block></then></if>

            <expr_stmt><expr><name><name>newerResources</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>selectOutOfDateResources</name><argument_list>(<argument><expr><name><name>initialResources</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                         <argument><expr><name>myMapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>needsUpdate</name> = <name>needsUpdate</name> || (<name><name>newerResources</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name> &gt; 0)</expr>;</expr_stmt>

            <if>if <condition>(<expr><name>needsUpdate</name> &amp;&amp; !<name>doUpdate</name></expr>)</condition><then> <block>{
                <comment type="line">// we will return initialResources anyway, no reason</comment>
                <comment type="line">// to scan further.</comment>
                <break>break;</break>
            }</block></then></if>
        }</block></for>

        <if>if <condition>(<expr><name>needsUpdate</name> &amp;&amp; !<name>doUpdate</name></expr>)</condition><then> <block>{
            <comment type="line">// we are recreating the archive, need all resources</comment>
            <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr><name>needsUpdate</name></expr></argument>, <argument><expr><name>newerResources</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Collect the resources that are newer than the corresponding
     * entries (or missing) in the original archive.
     *
     * &lt;p&gt;If we are going to recreate the archive instead of updating
     * it, all resources should be considered as new, if a single one
     * is.  Because of this, subclasses overriding this method must
     * call &lt;code&gt;super.getResourcesToAdd&lt;/code&gt; and indicate with the
     * third arg if they already know that the archive is
     * out-of-date.&lt;/p&gt;
     *
     * @param rcs The filesets to grab resources from
     * @param zipFile intended archive file (may or may not exist)
     * @param needsUpdate whether we already know that the archive is
     * out-of-date.  Subclasses overriding this method are supposed to
     * set this value correctly in their call to
     * &lt;code&gt;super.getResourcesToAdd&lt;/code&gt;.
     * @return an array of resources to add for each fileset passed in as well
     *         as a flag that indicates whether the archive is uptodate.
     *
     * @exception BuildException if it likes
     */</comment>
    <function><type><specifier>protected</specifier> <name>ArchiveState</name></type> <name>getNonFileSetResourcesToAdd</name><parameter_list>(<param><decl><type><name><name>ResourceCollection</name><index>[]</index></name></type> <name>rcs</name></decl></param>,
                                                       <param><decl><type><name>File</name></type> <name>zipFile</name></decl></param>,
                                                       <param><decl><type><name>boolean</name></type> <name>needsUpdate</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <comment type="block">/*
         * Backwards compatibility forces us to repeat the logic of
         * getResourcesToAdd(FileSet[], ...) here once again.
         */</comment>

        <decl_stmt><decl><type><name>Resource</name><index>[]</index><index>[]</index></type> <name>initialResources</name> =<init> <expr><call><name>grabNonFileSetResources</name><argument_list>(<argument><expr><name>rcs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>empty</name> =<init> <expr><call><name>isEmpty</name><argument_list>(<argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>HAVE_NON_FILE_SET_RESOURCES_TO_ADD</name>.<name>set</name></name><argument_list>(<argument><expr><call><name><name>Boolean</name>.<name>valueOf</name></name><argument_list>(<argument><expr>!<name>empty</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>empty</name></expr>)</condition><then> <block>{
            <comment type="line">// no emptyBehavior handling since the FileSet version</comment>
            <comment type="line">// will take care of it.</comment>
            <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr><name>needsUpdate</name></expr></argument>, <argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="line">// initialResources is not empty</comment>

        <if>if <condition>(<expr>!<call><name><name>zipFile</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>needsUpdate</name> &amp;&amp; !<name>doUpdate</name></expr>)</condition><then> <block>{
            <comment type="line">// we are recreating the archive, need all resources</comment>
            <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>Resource</name><index>[]</index><index>[]</index></type> <name>newerResources</name> =<init> <expr>new <name><name>Resource</name><index>[<expr><name><name>rcs</name>.<name>length</name></name></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>rcs</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>initialResources</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>newerResources</name><index>[<expr><name>i</name></expr>]</index></name> = new <name><name>Resource</name><index>[]</index></name> <block>{}</block></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name><name>initialResources</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>FileProvider</name></type> <name>fp</name> =<init>
                    <expr><name><name>initialResources</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name>.<call><name>as</name><argument_list>(<argument><expr><name><name>FileProvider</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>fp</name> != <name>null</name> &amp;&amp; <call><name><name>zipFile</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>fp</name>.<name>getFile</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"A zip file cannot include "
                                             + "itself"</expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
            }</block></for>

            <expr_stmt><expr><name><name>newerResources</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>selectOutOfDateResources</name><argument_list>(<argument><expr><name><name>initialResources</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                         <argument><expr>new <call><name>IdentityMapper</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>needsUpdate</name> = <name>needsUpdate</name> || (<name><name>newerResources</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name> &gt; 0)</expr>;</expr_stmt>

            <if>if <condition>(<expr><name>needsUpdate</name> &amp;&amp; !<name>doUpdate</name></expr>)</condition><then> <block>{
                <comment type="line">// we will return initialResources anyway, no reason</comment>
                <comment type="line">// to scan further.</comment>
                <break>break;</break>
            }</block></then></if>
        }</block></for>

        <if>if <condition>(<expr><name>needsUpdate</name> &amp;&amp; !<name>doUpdate</name></expr>)</condition><then> <block>{
            <comment type="line">// we are recreating the archive, need all resources</comment>
            <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>initialResources</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <return>return <expr>new <call><name>ArchiveState</name><argument_list>(<argument><expr><name>needsUpdate</name></expr></argument>, <argument><expr><name>newerResources</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>Resource</name><index>[]</index></type> <name>selectOutOfDateResources</name><parameter_list>(<param><decl><type><name><name>Resource</name><index>[]</index></name></type> <name>initial</name></decl></param>,
                                                <param><decl><type><name>FileNameMapper</name></type> <name>mapper</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Resource</name><index>[]</index></type> <name>rs</name> =<init> <expr><call><name>selectFileResources</name><argument_list>(<argument><expr><name>initial</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Resource</name><index>[]</index></type> <name>result</name> =<init>
            <expr><call><name><name>ResourceUtils</name>.<name>selectOutOfDateSources</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name>mapper</name></expr></argument>,
                                                 <argument><expr><call><name>getZipScanner</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>doFilesonly</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>Union</name></type> <name>u</name> =<init> <expr>new <call><name>Union</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>u</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><call><name>selectDirectoryResources</name><argument_list>(<argument><expr><name>initial</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>ResourceCollection</name></type> <name>rc</name> =<init>
                <expr><call><name><name>ResourceUtils</name>.<name>selectSources</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>mapper</name></expr></argument>,
                                            <argument><expr><call><name>getZipScanner</name><argument_list>()</argument_list></call></expr></argument>,
                                            <argument><expr><name>MISSING_DIR_PROVIDER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>rc</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>newer</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>newer</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr>((<name>Union</name>) <name>rc</name>).<call><name>listResources</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>newer</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> = <call><name><name>newer</name>.<name>toArray</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Fetch all included and not excluded resources from the sets.
     *
     * &lt;p&gt;Included directories will precede included files.&lt;/p&gt;
     * @param filesets an array of filesets
     * @return the resources included
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>protected</specifier> <name>Resource</name><index>[]</index><index>[]</index></type> <name>grabResources</name><parameter_list>(<param><decl><type><name><name>FileSet</name><index>[]</index></name></type> <name>filesets</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Resource</name><index>[]</index><index>[]</index></type> <name>result</name> =<init> <expr>new <name><name>Resource</name><index>[<expr><name><name>filesets</name>.<name>length</name></name></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>filesets</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>boolean</name></type> <name>skipEmptyNames</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>filesets</name><index>[<expr><name>i</name></expr>]</index></name> <name>instanceof</name> <name>ZipFileSet</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>ZipFileSet</name></type> <name>zfs</name> =<init> <expr>(<name>ZipFileSet</name>) <name><name>filesets</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>skipEmptyNames</name> = <call><name><name>zfs</name>.<name>getPrefix</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call>
                    &amp;&amp; <call><name><name>zfs</name>.<name>getFullpath</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <decl_stmt><decl><type><name>DirectoryScanner</name></type> <name>rs</name> =<init>
                <expr><name><name>filesets</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>getDirectoryScanner</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>rs</name> <name>instanceof</name> <name>ZipScanner</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>((<name>ZipScanner</name>) <name>rs</name>).<call><name>setEncoding</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <decl_stmt><decl><type><name><name>Vector</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>resources</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>doFilesonly</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>directories</name> =<init> <expr><call><name><name>rs</name>.<name>getIncludedDirectories</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name><name>directories</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                    <if>if <condition>(<expr>!"".<call><name>equals</name><argument_list>(<argument><expr><name><name>directories</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> || !<name>skipEmptyNames</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>resources</name>.<name>addElement</name></name><argument_list>(<argument><expr><call><name><name>rs</name>.<name>getResource</name></name><argument_list>(<argument><expr><name><name>directories</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></then></if>
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>files</name> =<init> <expr><call><name><name>rs</name>.<name>getIncludedFiles</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name><name>files</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr>!"".<call><name>equals</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> || !<name>skipEmptyNames</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>resources</name>.<name>addElement</name></name><argument_list>(<argument><expr><call><name><name>rs</name>.<name>getResource</name></name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> = new <name><name>Resource</name><index>[<expr><call><name><name>resources</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>resources</name>.<name>copyInto</name></name><argument_list>(<argument><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Fetch all included and not excluded resources from the collections.
     *
     * &lt;p&gt;Included directories will precede included files.&lt;/p&gt;
     * @param rcs an array of resource collections
     * @return the resources included
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>protected</specifier> <name>Resource</name><index>[]</index><index>[]</index></type> <name>grabNonFileSetResources</name><parameter_list>(<param><decl><type><name><name>ResourceCollection</name><index>[]</index></name></type> <name>rcs</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Resource</name><index>[]</index><index>[]</index></type> <name>result</name> =<init> <expr>new <name><name>Resource</name><index>[<expr><name><name>rcs</name>.<name>length</name></name></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>rcs</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>dirs</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>files</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>Resource</name></type> <name>r</name> :<range> <expr><name><name>rcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></range></decl></init>) <block>{
                <if>if <condition>(<expr><call><name><name>r</name>.<name>isExists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name><name>r</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>dirs</name>.<name>add</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>files</name>.<name>add</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then></if>
            }</block></for>
            <comment type="line">// make sure directories are in alpha-order - this also</comment>
            <comment type="line">// ensures parents come before their children</comment>
            <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name>dirs</name></expr></argument>, <argument><expr>new <class><super><name><name>Comparator</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
                    <function><type><specifier>public</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>r1</name></decl></param>, <param><decl><type><name>Resource</name></type> <name>r2</name></decl></param>)</parameter_list> <block>{
                        <return>return <expr><call><name><name>r1</name>.<name>getName</name></name><argument_list>()</argument_list></call>.<call><name>compareTo</name><argument_list>(<argument><expr><call><name><name>r2</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                    }</block></function>
                }</block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>rs</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>dirs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>rs</name>.<name>addAll</name></name><argument_list>(<argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name><name>rs</name>.<name>toArray</name></name><argument_list>(<argument><expr>new <name><name>Resource</name><index>[<expr><call><name><name>rs</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Add a directory to the zip stream.
     * @param dir  the directort to add to the archive
     * @param zOut the stream to write to
     * @param vPath the name this entry shall have in the archive
     * @param mode the Unix permissions to set.
     * @throws IOException on error
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>zipDir</name><parameter_list>(<param><decl><type><name>File</name></type> <name>dir</name></decl></param>, <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>, <param><decl><type><name>String</name></type> <name>vPath</name></decl></param>,
                          <param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>zipDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>vPath</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add a directory to the zip stream.
     * @param dir  the directory to add to the archive
     * @param zOut the stream to write to
     * @param vPath the name this entry shall have in the archive
     * @param mode the Unix permissions to set.
     * @param extra ZipExtraFields to add
     * @throws IOException on error
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>zipDir</name><parameter_list>(<param><decl><type><name>File</name></type> <name>dir</name></decl></param>, <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>, <param><decl><type><name>String</name></type> <name>vPath</name></decl></param>,
                          <param><decl><type><name>int</name></type> <name>mode</name></decl></param>, <param><decl><type><name><name>ZipExtraField</name><index>[]</index></name></type> <name>extra</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>zipDir</name><argument_list>(<argument><expr><name>dir</name> == <name>null</name> ? (<name>Resource</name>) <name>null</name> : new <call><name>FileResource</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>vPath</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add a directory to the zip stream.
     * @param dir  the directory to add to the archive
     * @param zOut the stream to write to
     * @param vPath the name this entry shall have in the archive
     * @param mode the Unix permissions to set.
     * @param extra ZipExtraFields to add
     * @throws IOException on error
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>zipDir</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>dir</name></decl></param>, <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>, <param><decl><type><name>String</name></type> <name>vPath</name></decl></param>,
                          <param><decl><type><name>int</name></type> <name>mode</name></decl></param>, <param><decl><type><name><name>ZipExtraField</name><index>[]</index></name></type> <name>extra</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>doFilesonly</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr>"skipping directory " + <name>vPath</name>
                           + " for file-only archive"</expr></argument>,
                           <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>addedDirs</name>.<name>get</name></name><argument_list>(<argument><expr><name>vPath</name></expr></argument>)</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
            <comment type="line">// don't add directories we've already added.</comment>
            <comment type="line">// no warning if we try, it is harmless in and of itself</comment>
            <return>return;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr>"adding directory " + <name>vPath</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>addedDirs</name>.<name>put</name></name><argument_list>(<argument><expr><name>vPath</name></expr></argument>, <argument><expr><name>vPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>skipWriting</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>ZipEntry</name></type> <name>ze</name> =<init> <expr>new <call><name>ZipEntry</name> <argument_list>(<argument><expr><name>vPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// ZIPs store time with a granularity of 2 seconds, round up</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>millisToAdd</name> =<init> <expr><name>roundUp</name> ? <name>ROUNDUP_MILLIS</name> : 0</expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>dir</name> != <name>null</name> &amp;&amp; <call><name><name>dir</name>.<name>isExists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>ze</name>.<name>setTime</name></name><argument_list>(<argument><expr><call><name><name>dir</name>.<name>getLastModified</name></name><argument_list>()</argument_list></call> + <name>millisToAdd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>ze</name>.<name>setTime</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> + <name>millisToAdd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><call><name><name>ze</name>.<name>setSize</name></name> <argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ze</name>.<name>setMethod</name></name> <argument_list>(<argument><expr><name><name>ZipEntry</name>.<name>STORED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// This is faintly ridiculous:</comment>
            <expr_stmt><expr><call><name><name>ze</name>.<name>setCrc</name></name> <argument_list>(<argument><expr><name>EMPTY_CRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ze</name>.<name>setUnixMode</name></name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>extra</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>ze</name>.<name>setExtraFields</name></name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name><name>zOut</name>.<name>putNextEntry</name></name><argument_list>(<argument><expr><name>ze</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="block">/*
     * This is a hacky construct to extend the zipFile method to
     * support a new parameter (extra fields to preserve) without
     * breaking subclasses that override the old method signature.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>ThreadLocal</name><argument_list>&lt;<argument><name>ZipExtraField</name><index>[]</index></argument>&gt;</argument_list></name></type> <name>CURRENT_ZIP_EXTRA</name> =<init> <expr>new <call><name><name>ThreadLocal</name><argument_list>&lt;<argument><name><name>ZipExtraField</name><index>[]</index></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Provides the extra fields for the zip entry currently being
     * added to the archive - if any.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>ZipExtraField</name><index>[]</index></type> <name>getCurrentExtraFields</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr>(<name><name>ZipExtraField</name><index>[]</index></name>) <call><name><name>CURRENT_ZIP_EXTRA</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the extra fields for the zip entry currently being
     * added to the archive - if any.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>void</name></type> <name>setCurrentExtraFields</name><parameter_list>(<param><decl><type><name><name>ZipExtraField</name><index>[]</index></name></type> <name>extra</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>CURRENT_ZIP_EXTRA</name>.<name>set</name></name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a new entry to the archive, takes care of duplicates as well.
     *
     * @param in the stream to read data for the entry from.  The
     * caller of the method is responsible for closing the stream.
     * @param zOut the stream to write to.
     * @param vPath the name this entry shall have in the archive.
     * @param lastModified last modification time for the entry.
     * @param fromArchive the original archive we are copying this
     * entry from, will be null if we are not copying from an archive.
     * @param mode the Unix permissions to set.
     *
     * @since Ant 1.5.2
     * @throws IOException on error
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>zipFile</name><parameter_list>(<param><decl><type><name>InputStream</name></type> <name>in</name></decl></param>, <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>, <param><decl><type><name>String</name></type> <name>vPath</name></decl></param>,
                           <param><decl><type><name>long</name></type> <name>lastModified</name></decl></param>, <param><decl><type><name>File</name></type> <name>fromArchive</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <comment type="line">// fromArchive is used in subclasses overriding this method</comment>

        <if>if <condition>(<expr><call><name><name>entries</name>.<name>containsKey</name></name><argument_list>(<argument><expr><name>vPath</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

            <if>if <condition>(<expr><call><name><name>duplicate</name>.<name>equals</name></name><argument_list>(<argument><expr>"preserve"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr><name>vPath</name> + " already added, skipping"</expr></argument>,
                               <argument><expr><name><name>Project</name>.<name>MSG_INFO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then> <else>else <if>if <condition>(<expr><call><name><name>duplicate</name>.<name>equals</name></name><argument_list>(<argument><expr>"fail"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Duplicate file " + <name>vPath</name>
                                         + " was found and the duplicate "
                                         + "attribute is 'fail'."</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then> <else>else <block>{
                <comment type="line">// duplicate equal to add, so we continue</comment>
                <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr>"duplicate file " + <name>vPath</name>
                               + " found, adding."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr>"adding entry " + <name>vPath</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name><name>entries</name>.<name>put</name></name><argument_list>(<argument><expr><name>vPath</name></expr></argument>, <argument><expr><name>vPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>skipWriting</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>ZipEntry</name></type> <name>ze</name> =<init> <expr>new <call><name>ZipEntry</name><argument_list>(<argument><expr><name>vPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ze</name>.<name>setTime</name></name><argument_list>(<argument><expr><name>lastModified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ze</name>.<name>setMethod</name></name><argument_list>(<argument><expr><name>doCompress</name> ? <name><name>ZipEntry</name>.<name>DEFLATED</name></name> : <name><name>ZipEntry</name>.<name>STORED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * ZipOutputStream.putNextEntry expects the ZipEntry to
             * know its size and the CRC sum before you start writing
             * the data when using STORED mode - unless it is seekable.
             *
             * This forces us to process the data twice.
             */</comment>
            <if>if <condition>(<expr>!<call><name><name>zOut</name>.<name>isSeekable</name></name><argument_list>()</argument_list></call> &amp;&amp; !<name>doCompress</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>long</name></type> <name>size</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CRC32</name></type> <name>cal</name> =<init> <expr>new <call><name>CRC32</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name><name>in</name>.<name>markSupported</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="line">// Store data into a byte[]</comment>
                    <decl_stmt><decl><type><name>ByteArrayOutputStream</name></type> <name>bos</name> =<init> <expr>new <call><name>ByteArrayOutputStream</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>BUFFER_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                    <do>do <block>{
                        <expr_stmt><expr><name>size</name> += <name>count</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>cal</name>.<name>update</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>bos</name>.<name>write</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>count</name> = <call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>buffer</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> while <condition>(<expr><name>count</name> != -1</expr>)</condition>;</do>
                    <expr_stmt><expr><name>in</name> = new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><call><name><name>bos</name>.<name>toByteArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name><name>in</name>.<name>mark</name></name><argument_list>(<argument><expr><name><name>Integer</name>.<name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>BUFFER_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                    <do>do <block>{
                        <expr_stmt><expr><name>size</name> += <name>count</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>cal</name>.<name>update</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>count</name> = <call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>buffer</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> while <condition>(<expr><name>count</name> != -1</expr>)</condition>;</do>
                    <expr_stmt><expr><call><name><name>in</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><call><name><name>ze</name>.<name>setSize</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>ze</name>.<name>setCrc</name></name><argument_list>(<argument><expr><call><name><name>cal</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name><name>ze</name>.<name>setUnixMode</name></name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>ZipExtraField</name><index>[]</index></type> <name>extra</name> =<init> <expr><call><name>getCurrentExtraFields</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>extra</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>ze</name>.<name>setExtraFields</name></name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name><name>zOut</name>.<name>putNextEntry</name></name><argument_list>(<argument><expr><name>ze</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>BUFFER_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
            <do>do <block>{
                <if>if <condition>(<expr><name>count</name> != 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>zOut</name>.<name>write</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>count</name> = <call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>buffer</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>count</name> != -1</expr>)</condition>;</do>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>addedFiles</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>vPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a new entry to the archive, takes care of duplicates as well.
     *
     * @param in the stream to read data for the entry from.  The
     * caller of the method is responsible for closing the stream.
     * @param zOut the stream to write to.
     * @param vPath the name this entry shall have in the archive.
     * @param lastModified last modification time for the entry.
     * @param fromArchive the original archive we are copying this
     * entry from, will be null if we are not copying from an archive.
     * @param mode the Unix permissions to set.
     * @param extra ZipExtraFields to add
     *
     * @since Ant 1.8.0
     * @throws IOException on error
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>void</name></type> <name>zipFile</name><parameter_list>(<param><decl><type><name>InputStream</name></type> <name>in</name></decl></param>, <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>,
                                 <param><decl><type><name>String</name></type> <name>vPath</name></decl></param>, <param><decl><type><name>long</name></type> <name>lastModified</name></decl></param>,
                                 <param><decl><type><name>File</name></type> <name>fromArchive</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>,
                                 <param><decl><type><name><name>ZipExtraField</name><index>[]</index></name></type> <name>extra</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <try>try <block>{
            <expr_stmt><expr><call><name>setCurrentExtraFields</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>zipFile</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>vPath</name></expr></argument>, <argument><expr><name>lastModified</name></expr></argument>, <argument><expr><name>fromArchive</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <finally>finally <block>{
            <expr_stmt><expr><call><name>setCurrentExtraFields</name><argument_list>(<argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * Method that gets called when adding from &lt;code&gt;java.io.File&lt;/code&gt; instances.
     *
     * &lt;p&gt;This implementation delegates to the six-arg version.&lt;/p&gt;
     *
     * @param file the file to add to the archive
     * @param zOut the stream to write to
     * @param vPath the name this entry shall have in the archive
     * @param mode the Unix permissions to set.
     * @throws IOException on error
     *
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>zipFile</name><parameter_list>(<param><decl><type><name>File</name></type> <name>file</name></decl></param>, <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>, <param><decl><type><name>String</name></type> <name>vPath</name></decl></param>,
                           <param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><call><name><name>file</name>.<name>equals</name></name><argument_list>(<argument><expr><name>zipFile</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"A zip file cannot include itself"</expr></argument>,
                                     <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <decl_stmt><decl><type><name>FileInputStream</name></type> <name>fIn</name> =<init> <expr>new <call><name>FileInputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <comment type="line">// ZIPs store time with a granularity of 2 seconds, round up</comment>
            <expr_stmt><expr><call><name>zipFile</name><argument_list>(<argument><expr><name>fIn</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>vPath</name></expr></argument>,
                    <argument><expr><call><name><name>file</name>.<name>lastModified</name></name><argument_list>()</argument_list></call> + (<name>roundUp</name> ? <name>ROUNDUP_MILLIS</name> : 0)</expr></argument>,
                    <argument><expr><name>null</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <finally>finally <block>{
            <expr_stmt><expr><call><name><name>fIn</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * Ensure all parent dirs of a given entry have been added.
     * @param baseDir the base directory to use (may be null)
     * @param entry   the entry name to create directories from
     * @param zOut    the stream to write to
     * @param prefix  a prefix to place on the created entries
     * @param dirMode the directory mode
     * @throws IOException on error
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>void</name></type> <name>addParentDirs</name><parameter_list>(<param><decl><type><name>File</name></type> <name>baseDir</name></decl></param>, <param><decl><type><name>String</name></type> <name>entry</name></decl></param>,
                                       <param><decl><type><name>ZipOutputStream</name></type> <name>zOut</name></decl></param>, <param><decl><type><name>String</name></type> <name>prefix</name></decl></param>,
                                       <param><decl><type><name>int</name></type> <name>dirMode</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr>!<name>doFilesonly</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>Stack</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>directories</name> =<init> <expr>new <call><name><name>Stack</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>slashPos</name> =<init> <expr><call><name><name>entry</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr>(<name>slashPos</name> = <call><name><name>entry</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr>'/'</expr></argument>, <argument><expr><name>slashPos</name> - 1</expr></argument>)</argument_list></call>) != -1</expr>)</condition> <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>dir</name> =<init> <expr><call><name><name>entry</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>slashPos</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>addedDirs</name>.<name>get</name></name><argument_list>(<argument><expr><name>prefix</name> + <name>dir</name></expr></argument>)</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>directories</name>.<name>push</name></name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>

            <while>while <condition>(<expr>!<call><name><name>directories</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>dir</name> =<init> <expr><call><name><name>directories</name>.<name>pop</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>File</name></type> <name>f</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>baseDir</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>f</name> = new <call><name>File</name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>f</name> = new <call><name>File</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><call><name>zipDir</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>prefix</name> + <name>dir</name></expr></argument>, <argument><expr><name>dirMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Do any clean up necessary to allow this instance to be used again.
     *
     * &lt;p&gt;When we get here, the Zip file has been closed and all we
     * need to do is to reset some globals.&lt;/p&gt;
     *
     * &lt;p&gt;This method will only reset globals that have been changed
     * during execute(), it will not alter the attributes or nested
     * child elements.  If you want to reset the instance so that you
     * can later zip a completely different set of files, you must use
     * the reset method.&lt;/p&gt;
     *
     * @see #reset
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>cleanUp</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>addedDirs</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>addedFiles</name>.<name>removeAllElements</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>entries</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>addingNewFiles</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>doUpdate</name> = <name>savedDoUpdate</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Enumeration</name><argument_list>&lt;<argument><name>ZipFileSet</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><call><name><name>filesetsFromGroupfilesets</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>ZipFileSet</name></type> <name>zf</name> =<init> <expr><call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>resources</name>.<name>removeElement</name></name><argument_list>(<argument><expr><name>zf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name><name>filesetsFromGroupfilesets</name>.<name>removeAllElements</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>HAVE_NON_FILE_SET_RESOURCES_TO_ADD</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>Boolean</name>.<name>FALSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Makes this instance reset all attributes to their default
     * values and forget all children.
     *
     * @since Ant 1.5
     *
     * @see #cleanUp
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>reset</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>resources</name>.<name>removeAllElements</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zipFile</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>baseDir</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>groupfilesets</name>.<name>removeAllElements</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>duplicate</name> = "add"</expr>;</expr_stmt>
        <expr_stmt><expr><name>archiveType</name> = "zip"</expr>;</expr_stmt>
        <expr_stmt><expr><name>doCompress</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>emptyBehavior</name> = "skip"</expr>;</expr_stmt>
        <expr_stmt><expr><name>doUpdate</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>doFilesonly</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>encoding</name> = <name>null</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Check is the resource arrays are empty.
     * @param r the arrays to check
     * @return true if all individual arrays are empty
     *
     * @since Ant 1.5.2
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>isEmpty</name><parameter_list>(<param><decl><type><name><name>Resource</name><index>[]</index><index>[]</index></name></type> <name>r</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>r</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name> &gt; 0</expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Drops all non-file resources from the given array.
     * @param orig the resources to filter
     * @return the filters resources
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>protected</specifier> <name>Resource</name><index>[]</index></type> <name>selectFileResources</name><parameter_list>(<param><decl><type><name><name>Resource</name><index>[]</index></name></type> <name>orig</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>selectResources</name><argument_list>(<argument><expr><name>orig</name></expr></argument>,
                               <argument><expr>new <class><super><name>ResourceSelector</name></super><argument_list>()</argument_list> <block>{
                                   <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isSelected</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>r</name></decl></param>)</parameter_list> <block>{
                                       <if>if <condition>(<expr>!<call><name><name>r</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                                           <return>return <expr>true</expr>;</return>
                                       }</block></then> <else>else <if>if <condition>(<expr><name>doFilesonly</name></expr>)</condition><then> <block>{
                                           <expr_stmt><expr><call><name>logWhenWriting</name><argument_list>(<argument><expr>"Ignoring directory "
                                                          + <call><name><name>r</name>.<name>getName</name></name><argument_list>()</argument_list></call>
                                                          + " as only files will"
                                                          + " be added."</expr></argument>,
                                                          <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                       }</block></then></if></else></if>
                                       <return>return <expr>false</expr>;</return>
                                   }</block></function>
                               }</block></class></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Drops all non-directory resources from the given array.
     * @param orig the resources to filter
     * @return the filters resources
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>protected</specifier> <name>Resource</name><index>[]</index></type> <name>selectDirectoryResources</name><parameter_list>(<param><decl><type><name><name>Resource</name><index>[]</index></name></type> <name>orig</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>selectResources</name><argument_list>(<argument><expr><name>orig</name></expr></argument>,
                               <argument><expr>new <class><super><name>ResourceSelector</name></super><argument_list>()</argument_list> <block>{
                                   <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isSelected</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>r</name></decl></param>)</parameter_list> <block>{
                                       <return>return <expr><call><name><name>r</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call></expr>;</return>
                                   }</block></function>
                               }</block></class></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Drops all resources from the given array that are not selected
     * @param orig the resources to filter
     * @return the filters resources
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>protected</specifier> <name>Resource</name><index>[]</index></type> <name>selectResources</name><parameter_list>(<param><decl><type><name><name>Resource</name><index>[]</index></name></type> <name>orig</name></decl></param>,
                                         <param><decl><type><name>ResourceSelector</name></type> <name>selector</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>orig</name>.<name>length</name></name> == 0</expr>)</condition><then> <block>{
            <return>return <expr><name>orig</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>v</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>orig</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>orig</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name><name>selector</name>.<name>isSelected</name></name><argument_list>(<argument><expr><name><name>orig</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>v</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>orig</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <if>if <condition>(<expr><call><name><name>v</name>.<name>size</name></name><argument_list>()</argument_list></call> != <name><name>orig</name>.<name>length</name></name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>v</name>.<name>toArray</name></name><argument_list>(<argument><expr>new <name><name>Resource</name><index>[<expr><call><name><name>v</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>orig</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Logs a message at the given output level, but only if this is
     * the pass that will actually create the archive.
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>logWhenWriting</name><parameter_list>(<param><decl><type><name>String</name></type> <name>msg</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr>!<name>skipWriting</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Possible behaviors when a duplicate file is added:
     * "add", "preserve" or "fail"
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>Duplicate</name> <super><extends>extends <name>EnumeratedAttribute</name></extends></super> <block>{
        <comment type="javadoc">/**
         * @see EnumeratedAttribute#getValues()
         */</comment>
        <comment type="javadoc">/** {@inheritDoc} */</comment>
        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getValues</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>new <name><name>String</name><index>[]</index></name> <block>{<expr>"add"</expr>, <expr>"preserve"</expr>, <expr>"fail"</expr>}</block></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Holds the up-to-date status and the out-of-date resources of
     * the original archive.
     *
     * @since Ant 1.5.3
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>ArchiveState</name> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>outOfDate</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>Resource</name><index>[]</index><index>[]</index></type> <name>resourcesToAdd</name></decl>;</decl_stmt>

        <constructor><name>ArchiveState</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>state</name></decl></param>, <param><decl><type><name><name>Resource</name><index>[]</index><index>[]</index></name></type> <name>r</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name>outOfDate</name> = <name>state</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>resourcesToAdd</name> = <name>r</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Return the outofdate status.
         * @return the outofdate status
         */</comment>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isOutOfDate</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>outOfDate</name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Get the resources to add.
         * @return the resources to add
         */</comment>
        <function><type><specifier>public</specifier> <name>Resource</name><index>[]</index><index>[]</index></type> <name>getResourcesToAdd</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>resourcesToAdd</name></expr>;</return>
        }</block></function>
        <comment type="javadoc">/**
         * find out if there are absolutely no resources to add
         * @since Ant 1.6.3
         * @return true if there are no resources to add
         */</comment>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isWithoutAnyResources</name><parameter_list>()</parameter_list> <block>{
            <if>if <condition>(<expr><name>resourcesToAdd</name> == <name>null</name></expr>)</condition><then>  <block>{
                <return>return <expr>true</expr>;</return>
            }</block></then></if>
            <for>for (<init><decl><type><name>int</name></type> <name>counter</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>counter</name> &lt; <name><name>resourcesToAdd</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>counter</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>resourcesToAdd</name><index>[<expr><name>counter</name></expr>]</index></name> != <name>null</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>resourcesToAdd</name><index>[<expr><name>counter</name></expr>]</index></name>.<name>length</name> &gt; 0</expr>)</condition><then> <block>{
                        <return>return <expr>false</expr>;</return>
                    }</block></then></if>
                }</block></then></if>
            }</block></for>
            <return>return <expr>true</expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Policiy for creation of Unicode extra fields: never, always or
     * not-encodeable.
     *
     * @since Ant 1.8.0
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>UnicodeExtraField</name> <super><extends>extends <name>EnumeratedAttribute</name></extends></super> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>UnicodeExtraFieldPolicy</name></argument>&gt;</argument_list></name></type> <name>POLICIES</name> =<init> <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>UnicodeExtraFieldPolicy</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>NEVER_KEY</name> =<init> <expr>"never"</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ALWAYS_KEY</name> =<init> <expr>"always"</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>N_E_KEY</name> =<init> <expr>"not-encodeable"</expr></init></decl>;</decl_stmt>
        static <block>{
            <constructor_decl><name><name>POLICIES</name>.<name>put</name></name><parameter_list>(<param><decl><type><name>NEVER_KEY</name></type></decl></param>,
                         <param><decl><type><name><name>ZipOutputStream</name>.<name>UnicodeExtraFieldPolicy</name>.<name>NEVER</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
            <constructor_decl><name><name>POLICIES</name>.<name>put</name></name><parameter_list>(<param><decl><type><name>ALWAYS_KEY</name></type></decl></param>,
                         <param><decl><type><name><name>ZipOutputStream</name>.<name>UnicodeExtraFieldPolicy</name>.<name>ALWAYS</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
            <constructor_decl><name><name>POLICIES</name>.<name>put</name></name><parameter_list>(<param><decl><type><name>N_E_KEY</name></type></decl></param>,
                         <param><decl><type><name><name>ZipOutputStream</name>.<name>UnicodeExtraFieldPolicy</name>
                         .<name>NOT_ENCODEABLE</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        }</block>

        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getValues</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><name>NEVER_KEY</name></expr>, <expr><name>ALWAYS_KEY</name></expr>, <expr><name>N_E_KEY</name></expr>}</block></expr>;</return>
        }</block></function>

        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>UnicodeExtraField</name></type> <name>NEVER</name> =<init>
            <expr>new <call><name>UnicodeExtraField</name><argument_list>(<argument><expr><name>NEVER_KEY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>UnicodeExtraField</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>setValue</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <constructor><specifier>public</specifier> <name>UnicodeExtraField</name><parameter_list>()</parameter_list> <block>{
        }</block></constructor>

        <function><type><specifier>public</specifier> <name><name>ZipOutputStream</name>.<name>UnicodeExtraFieldPolicy</name></name></type> <name>getPolicy</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name><name>POLICIES</name>.<name>get</name></name><argument_list>(<argument><expr><call><name>getValue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>


    <comment type="javadoc">/**
     * The choices for Zip64 extensions.
     *
     * &lt;p&gt;&lt;b&gt;never&lt;/b&gt;: never add any Zip64 extensions.  This will
     * cause the task to fail if you try to add entries bigger than
     * 4GB or create an archive bigger than 4GB or holding more that
     * 65535 entries.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;b&gt;as-needed&lt;/b&gt;: create Zip64 extensions only when the
     * entry's size is bigger than 4GB or one of the archive limits is
     * hit.  This mode also adds partial Zip64 extensions for all
     * deflated entries written by Ant.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;b&gt;always&lt;/b&gt;: create Zip64 extensions for all entries.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt; some ZIP implementations don't handle Zip64
     * extensions well and others may fail if the Zip64 extra field
     * data is only present inside the local file header but not the
     * central directory - which is what &lt;em&gt;as-needed&lt;/em&gt; may result
     * in.  Java5 and Microsoft Visual Studio's Extension loader are
     * known to fconsider the archive broken in such cases.  If you
     * are targeting such an archiver uset the value &lt;em&gt;never&lt;/em&gt;
     * unless you know you need Zip64 extensions.&lt;/p&gt;
     *
     * @since Ant 1.9.1
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>Zip64ModeAttribute</name> <super><extends>extends <name>EnumeratedAttribute</name></extends></super> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Zip64Mode</name></argument>&gt;</argument_list></name></type> <name>MODES</name> =<init> <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Zip64Mode</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>NEVER_KEY</name> =<init> <expr>"never"</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ALWAYS_KEY</name> =<init> <expr>"always"</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>A_N_KEY</name> =<init> <expr>"as-needed"</expr></init></decl>;</decl_stmt>
        static <block>{
            <constructor_decl><name><name>MODES</name>.<name>put</name></name><parameter_list>(<param><decl><type><name>NEVER_KEY</name></type></decl></param>, <param><decl><type><name><name>Zip64Mode</name>.<name>Never</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
            <constructor_decl><name><name>MODES</name>.<name>put</name></name><parameter_list>(<param><decl><type><name>ALWAYS_KEY</name></type></decl></param>, <param><decl><type><name><name>Zip64Mode</name>.<name>Always</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
            <constructor_decl><name><name>MODES</name>.<name>put</name></name><parameter_list>(<param><decl><type><name>A_N_KEY</name></type></decl></param>, <param><decl><type><name><name>Zip64Mode</name>.<name>AsNeeded</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        }</block>

        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getValues</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><name>NEVER_KEY</name></expr>, <expr><name>ALWAYS_KEY</name></expr>, <expr><name>A_N_KEY</name></expr>}</block></expr>;</return>
        }</block></function>

        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Zip64ModeAttribute</name></type> <name>NEVER</name> =<init>
            <expr>new <call><name>Zip64ModeAttribute</name><argument_list>(<argument><expr><name>NEVER_KEY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Zip64ModeAttribute</name></type> <name>AS_NEEDED</name> =<init>
            <expr>new <call><name>Zip64ModeAttribute</name><argument_list>(<argument><expr><name>A_N_KEY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>Zip64ModeAttribute</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>setValue</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <constructor><specifier>public</specifier> <name>Zip64ModeAttribute</name><parameter_list>()</parameter_list> <block>{
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>Zip64Mode</name></type> <name>getMode</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name><name>MODES</name>.<name>get</name></name><argument_list>(<argument><expr><call><name>getValue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

    }</block></class>
 }</block></class>
</unit>
