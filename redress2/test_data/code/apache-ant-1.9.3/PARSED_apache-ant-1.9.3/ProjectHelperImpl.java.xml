<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\helper\ProjectHelperImpl.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>helper</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileInputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileNotFoundException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>UnsupportedEncodingException</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Locale</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>IntrospectionHelper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Location</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>ProjectHelper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>RuntimeConfigurable</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Target</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Task</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>TypeAdapter</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>TaskContainer</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>UnknownElement</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>JAXPUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>AttributeList</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>DocumentHandler</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>HandlerBase</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>InputSource</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>Locator</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>SAXException</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>SAXParseException</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>helpers</name>.<name>XMLReaderAdapter</name></name>;</import>

<comment type="javadoc">/**
 * Original helper.
 *
 */</comment>
<class><specifier>public</specifier> class <name>ProjectHelperImpl</name> <super><extends>extends <name>ProjectHelper</name></extends></super> <block>{

    <comment type="javadoc">/**
     * helper for path -&gt; URI and URI -&gt; path conversions.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>FileUtils</name></type> <name>FILE_UTILS</name> =<init> <expr><call><name><name>FileUtils</name>.<name>getFileUtils</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * SAX 1 style parser used to parse the given file. This may
     * in fact be a SAX 2 XMLReader wrapped in an XMLReaderAdapter.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>Parser</name></name></type> <name>parser</name></decl>;</decl_stmt>

    <comment type="javadoc">/** The project to configure. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Project</name></type> <name>project</name></decl>;</decl_stmt>

    <comment type="javadoc">/** The configuration file to parse. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>buildFile</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Parent directory of the build file. Used for resolving entities
     * and setting the project's base directory.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>buildFileParent</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Locator for the configuration file parser.
     * Used for giving locations of errors etc.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Locator</name></type> <name>locator</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Target that all other targets will depend upon implicitly.
     *
     * &lt;p&gt;This holds all tasks and data type definitions that have
     * been placed outside of targets.&lt;/p&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Target</name></type> <name>implicitTarget</name> =<init> <expr>new <call><name>Target</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * default constructor
     */</comment>
    <constructor><specifier>public</specifier> <name>ProjectHelperImpl</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>implicitTarget</name>.<name>setName</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Parses the project file, configuring the project as it goes.
     *
     * @param project project instance to be configured.
     * @param source the source from which the project is read.
     * @exception BuildException if the configuration is invalid or cannot
     *                           be read.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>parse</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>Object</name></type> <name>source</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr>!(<name>source</name> <name>instanceof</name> <name>File</name>)</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Only File source supported by "
                + "default plugin"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>File</name></type> <name>bFile</name> =<init> <expr>(<name>File</name>) <name>source</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FileInputStream</name></type> <name>inputStream</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>InputSource</name></type> <name>inputSource</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>this</name>.<name>project</name></name> = <name>project</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>buildFile</name></name> = new <call><name>File</name><argument_list>(<argument><expr><call><name><name>bFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buildFileParent</name> = new <call><name>File</name><argument_list>(<argument><expr><call><name><name>this</name>.<name>buildFile</name>.<name>getParent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <try>try <block>{
            <try>try <block>{
                <expr_stmt><expr><name>parser</name> = <call><name><name>JAXPUtils</name>.<name>getParser</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>BuildException</name></type> <name>e</name></decl></param>) <block>{
                <expr_stmt><expr><name>parser</name> = new <call><name>XMLReaderAdapter</name><argument_list>(<argument><expr><call><name><name>JAXPUtils</name>.<name>getXMLReader</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch></try>
            <decl_stmt><decl><type><name>String</name></type> <name>uri</name> =<init> <expr><call><name><name>FILE_UTILS</name>.<name>toURI</name></name><argument_list>(<argument><expr><call><name><name>bFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>inputStream</name> = new <call><name>FileInputStream</name><argument_list>(<argument><expr><name>bFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>inputSource</name> = new <call><name>InputSource</name><argument_list>(<argument><expr><name>inputStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>inputSource</name>.<name>setSystemId</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr>"parsing buildfile " + <name>bFile</name> + " with URI = " + <name>uri</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>HandlerBase</name></type> <name>hb</name> =<init> <expr>new <call><name>RootHandler</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>parser</name>.<name>setDocumentHandler</name></name><argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name>.<name>setEntityResolver</name></name><argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name>.<name>setErrorHandler</name></name><argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name>.<name>setDTDHandler</name></name><argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name>.<name>parse</name></name><argument_list>(<argument><expr><name>inputSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>SAXParseException</name></type> <name>exc</name></decl></param>) <block>{
            <decl_stmt><decl><type><name>Location</name></type> <name>location</name> =<init> <expr>new <call><name>Location</name><argument_list>(<argument><expr><call><name><name>exc</name>.<name>getSystemId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>exc</name>.<name>getLineNumber</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>exc</name>
                    .<name>getColumnNumber</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Throwable</name></type> <name>t</name> =<init> <expr><call><name><name>exc</name>.<name>getException</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>t</name> <name>instanceof</name> <name>BuildException</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>BuildException</name></type> <name>be</name> =<init> <expr>(<name>BuildException</name>) <name>t</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>be</name>.<name>getLocation</name></name><argument_list>()</argument_list></call> == <name><name>Location</name>.<name>UNKNOWN_LOCATION</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>be</name>.<name>setLocation</name></name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <throw>throw <expr><name>be</name></expr>;</throw>
            }</block></then></if>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><call><name><name>exc</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>SAXException</name></type> <name>exc</name></decl></param>) <block>{
            <decl_stmt><decl><type><name>Throwable</name></type> <name>t</name> =<init> <expr><call><name><name>exc</name>.<name>getException</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>t</name> <name>instanceof</name> <name>BuildException</name></expr>)</condition><then> <block>{
                <throw>throw <expr>(<name>BuildException</name>) <name>t</name></expr>;</throw>
            }</block></then></if>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><call><name><name>exc</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>FileNotFoundException</name></type> <name>exc</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>UnsupportedEncodingException</name></type> <name>exc</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Encoding of project file is invalid."</expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>IOException</name></type> <name>exc</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Error reading project file: " + <call><name><name>exc</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <finally>finally <block>{
            <expr_stmt><expr><call><name><name>FileUtils</name>.<name>close</name></name><argument_list>(<argument><expr><name>inputStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * The common superclass for all SAX event handlers used to parse
     * the configuration file. Each method just throws an exception,
     * so subclasses should override what they can handle.
     *
     * Each type of XML element (task, target, etc.) in Ant has
     * a specific subclass.
     *
     * In the constructor, this class takes over the handling of SAX
     * events from the parent handler and returns
     * control back to the parent in the endElement method.
     */</comment>
    <class><specifier>static</specifier> class <name>AbstractHandler</name> <super><extends>extends <name>HandlerBase</name></extends></super> <block>{
        <comment type="line">// CheckStyle:VisibilityModifier OFF - bc</comment>

        <comment type="javadoc">/**
         * Previous handler for the document.
         * When the next element is finished, control returns
         * to this handler.
         */</comment>
        <decl_stmt><decl><type><specifier>protected</specifier> <name>DocumentHandler</name></type> <name>parentHandler</name></decl>;</decl_stmt>

        <comment type="javadoc">/** Helper impl. With non-static internal classes, the compiler will generate
            this automatically - but this will fail with some compilers ( reporting
            "Expecting to find object/array on stack" ). If we pass it
            explicitly it'll work with more compilers.
        */</comment>
        <decl_stmt><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl>;</decl_stmt>
        <comment type="line">// CheckStyle:VisibilityModifier ON</comment>

        <comment type="javadoc">/**
         * Creates a handler and sets the parser to use it
         * for the current element.
         *
         * @param helperImpl the ProjectHelperImpl instance associated
         *                   with this handler.
         *
         * @param parentHandler The handler which should be restored to the
         *                      parser at the end of the element.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         */</comment>
        <constructor><specifier>public</specifier> <name>AbstractHandler</name><parameter_list>(<param><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl></param>, <param><decl><type><name>DocumentHandler</name></type> <name>parentHandler</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>parentHandler</name></name> = <name>parentHandler</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>helperImpl</name></name> = <name>helperImpl</name></expr>;</expr_stmt>

            <comment type="line">// Start handling SAX events</comment>
            <expr_stmt><expr><call><name><name>helperImpl</name>.<name>parser</name>.<name>setDocumentHandler</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Handles the start of an element. This base implementation just
         * throws an exception.
         *
         * @param tag The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException if this method is not overridden, or in
         *                              case of error in an overridden version
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>startElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"Unexpected element \"" + <name>tag</name> + "\""</expr></argument>, <argument><expr><name><name>helperImpl</name>.<name>locator</name></name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></function>

        <comment type="javadoc">/**
         * Handles text within an element. This base implementation just
         * throws an exception.
         *
         * @param buf A character array of the text within the element.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param start The start element in the array.
         * @param count The number of characters to read from the array.
         *
         * @exception SAXParseException if this method is not overridden, or in
         *                              case of error in an overridden version
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>characters</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>s</name> =<init> <expr>new <call><name>String</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call>.<call><name>trim</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>s</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"Unexpected text \"" + <name>s</name> + "\""</expr></argument>, <argument><expr><name><name>helperImpl</name>.<name>locator</name></name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the end of an element. Any required clean-up is performed
         * by the finished() method and then the original handler is restored to
         * the parser.
         *
         * @param name The name of the element which is ending.
         *             Will not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXException in case of error (not thrown in
         *                         this implementation)
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>endElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXException</name></expr></argument></throws> <block>{
            <comment type="line">// Let parent resume handling SAX events</comment>
            <expr_stmt><expr><call><name><name>helperImpl</name>.<name>parser</name>.<name>setDocumentHandler</name></name><argument_list>(<argument><expr><name>parentHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Handler for the root element. Its only child must be the "project" element.
     */</comment>
    <class><specifier>static</specifier> class <name>RootHandler</name> <super><extends>extends <name>HandlerBase</name></extends></super> <block>{
        <comment type="line">// CheckStyle:VisibilityModifier OFF - bc</comment>
        <decl_stmt><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl>;</decl_stmt>
        <comment type="line">// CheckStyle:VisibilityModifier ON</comment>

        <constructor><specifier>public</specifier> <name>RootHandler</name><parameter_list>(<param><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>helperImpl</name></name> = <name>helperImpl</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Resolves file: URIs relative to the build file.
         *
         * @param publicId The public identifier, or &lt;code&gt;null&lt;/code&gt;
         *                 if none is available. Ignored in this
         *                 implementation.
         * @param systemId The system identifier provided in the XML
         *                 document. Will not be &lt;code&gt;null&lt;/code&gt;.
         */</comment>
        <function><type><specifier>public</specifier> <name>InputSource</name></type> <name>resolveEntity</name><parameter_list>(<param><decl><type><name>String</name></type> <name>publicId</name></decl></param>, <param><decl><type><name>String</name></type> <name>systemId</name></decl></param>)</parameter_list> <block>{

            <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>log</name></name><argument_list>(<argument><expr>"resolving systemId: " + <name>systemId</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name><name>systemId</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"file:"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>path</name> =<init> <expr><call><name><name>FILE_UTILS</name>.<name>fromURI</name></name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>File</name></type> <name>file</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name><name>file</name>.<name>isAbsolute</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>file</name> = <call><name><name>FILE_UTILS</name>.<name>resolveFile</name></name><argument_list>(<argument><expr><name><name>helperImpl</name>.<name>buildFileParent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>log</name></name><argument_list>(<argument><expr>"Warning: '" + <name>systemId</name> + "' in " + <name><name>helperImpl</name>.<name>buildFile</name></name>
                            + " should be expressed simply as '" + <call><name><name>path</name>.<name>replace</name></name><argument_list>(<argument><expr>'\\'</expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call>
                            + "' for compliance with other XML tools"</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <try>try <block>{
                    <decl_stmt><decl><type><name>InputSource</name></type> <name>inputSource</name> =<init> <expr>new <call><name>InputSource</name><argument_list>(<argument><expr>new <call><name>FileInputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>inputSource</name>.<name>setSystemId</name></name><argument_list>(<argument><expr><call><name><name>FILE_UTILS</name>.<name>toURI</name></name><argument_list>(<argument><expr><call><name><name>file</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>inputSource</name></expr>;</return>
                }</block> <catch>catch (<param><decl><type><name>FileNotFoundException</name></type> <name>fne</name></decl></param>) <block>{
                    <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>log</name></name><argument_list>(<argument><expr><call><name><name>file</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call> + " could not be found"</expr></argument>,
                            <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></catch></try>
            }</block></then></if>
            <comment type="line">// use default if not file or file not found</comment>
            <return>return <expr><name>null</name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of a project element. A project handler is created
         * and initialised with the element name and attributes.
         *
         * @param tag The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException if the tag given is not
         *                              &lt;code&gt;"project"&lt;/code&gt;
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>startElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <if>if <condition>(<expr><call><name><name>tag</name>.<name>equals</name></name><argument_list>(<argument><expr>"project"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>new <call><name>ProjectHandler</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call>.<call><name>init</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"Config file is not of expected " + "XML type"</expr></argument>,
                        <argument><expr><name><name>helperImpl</name>.<name>locator</name></name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></else></if>
        }</block></function>

        <comment type="javadoc">/**
         * Sets the locator in the project helper for future reference.
         *
         * @param locator The locator used by the parser.
         *                Will not be &lt;code&gt;null&lt;/code&gt;.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setDocumentLocator</name><parameter_list>(<param><decl><type><name>Locator</name></type> <name>locator</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>helperImpl</name>.<name>locator</name></name> = <name>locator</name></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Handler for the top level "project" element.
     */</comment>
    <class><specifier>static</specifier> class <name>ProjectHandler</name> <super><extends>extends <name>AbstractHandler</name></extends></super> <block>{

        <comment type="javadoc">/**
         * Constructor which just delegates to the superconstructor.
         *
         * @param parentHandler The handler which should be restored to the
         *                      parser at the end of the element.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         */</comment>
        <constructor><specifier>public</specifier> <name>ProjectHandler</name><parameter_list>(<param><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl></param>, <param><decl><type><name>DocumentHandler</name></type> <name>parentHandler</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>parentHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Initialisation routine called after handler creation
         * with the element name and attributes. The attributes which
         * this handler can deal with are: &lt;code&gt;"default"&lt;/code&gt;,
         * &lt;code&gt;"name"&lt;/code&gt;, &lt;code&gt;"id"&lt;/code&gt; and &lt;code&gt;"basedir"&lt;/code&gt;.
         *
         * @param tag Name of the element which caused this handler
         *            to be created. Should not be &lt;code&gt;null&lt;/code&gt;.
         *            Ignored in this implementation.
         * @param attrs Attributes of the element which caused this
         *              handler to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException if an unexpected attribute is
         *            encountered or if the &lt;code&gt;"default"&lt;/code&gt; attribute
         *            is missing.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>def</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>id</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>baseDir</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>attrs</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>key</name> =<init> <expr><call><name><name>attrs</name>.<name>getName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>value</name> =<init> <expr><call><name><name>attrs</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"default"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>def</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"name"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>name</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"id"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>id</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"basedir"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>baseDir</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(
                            <argument><expr>"Unexpected attribute \"" + <call><name><name>attrs</name>.<name>getName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>
                            + "\""</expr></argument>, <argument><expr><name><name>helperImpl</name>.<name>locator</name></name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></else></if></else></if></else></if></else></if>
            }</block></for>

            <if>if <condition>(<expr><name>def</name> != <name>null</name> &amp;&amp; !<call><name><name>def</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>setDefault</name></name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"The default attribute is required"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></else></if>

            <if>if <condition>(<expr><name>name</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>setName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>helperImpl</name>.<name>project</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>id</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>helperImpl</name>.<name>project</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><call><name><name>helperImpl</name>.<name>project</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"basedir"</expr></argument>)</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>setBasedir</name></name><argument_list>(<argument><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"basedir"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><name>baseDir</name> == <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>setBasedir</name></name><argument_list>(<argument><expr><call><name><name>helperImpl</name>.<name>buildFileParent</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <comment type="line">// check whether the user has specified an absolute path</comment>
                    <if>if <condition>(<expr>(new <call><name>File</name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>)</argument_list></call>).<call><name>isAbsolute</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>setBasedir</name></name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <decl_stmt><decl><type><name>File</name></type> <name>resolvedBaseDir</name> =<init> <expr><call><name><name>FILE_UTILS</name>.<name>resolveFile</name></name><argument_list>(<argument><expr><name><name>helperImpl</name>.<name>buildFileParent</name></name></expr></argument>,
                                <argument><expr><name>baseDir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>setBaseDir</name></name><argument_list>(<argument><expr><name>resolvedBaseDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></else></if>
            }</block></else></if>

            <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>addTarget</name></name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name><name>helperImpl</name>.<name>implicitTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of a top-level element within the project. An
         * appropriate handler is created and initialised with the details
         * of the element.
         *
         * @param name The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException if the tag given is not
         *            &lt;code&gt;"taskdef"&lt;/code&gt;, &lt;code&gt;"typedef"&lt;/code&gt;,
         *            &lt;code&gt;"property"&lt;/code&gt;, &lt;code&gt;"target"&lt;/code&gt;
         *            or a data type definition
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>startElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <if>if <condition>(<expr><call><name><name>name</name>.<name>equals</name></name><argument_list>(<argument><expr>"target"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>handleTarget</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>handleElement</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>helperImpl</name>.<name>implicitTarget</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></function>

        <comment type="javadoc">/**
         * Handles a target definition element by creating a target handler
         * and initialising is with the details of the element.
         *
         * @param tag The name of the element to be handled.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param attrs Attributes of the element to be handled.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException if an error occurs initialising
         *                              the handler
         */</comment>
        <function><type><specifier>private</specifier> <name>void</name></type> <name>handleTarget</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <expr_stmt><expr>new <call><name>TargetHandler</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call>.<call><name>init</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Handler for "target" elements.
     */</comment>
    <class><specifier>static</specifier> class <name>TargetHandler</name> <super><extends>extends <name>AbstractHandler</name></extends></super> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <name>Target</name></type> <name>target</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Constructor which just delegates to the superconstructor.
         *
         * @param parentHandler The handler which should be restored to the
         *                      parser at the end of the element.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         */</comment>
        <constructor><specifier>public</specifier> <name>TargetHandler</name><parameter_list>(<param><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl></param>, <param><decl><type><name>DocumentHandler</name></type> <name>parentHandler</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>parentHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Initialisation routine called after handler creation
         * with the element name and attributes. The attributes which
         * this handler can deal with are: &lt;code&gt;"name"&lt;/code&gt;,
         * &lt;code&gt;"depends"&lt;/code&gt;, &lt;code&gt;"if"&lt;/code&gt;,
         * &lt;code&gt;"unless"&lt;/code&gt;, &lt;code&gt;"id"&lt;/code&gt; and
         * &lt;code&gt;"description"&lt;/code&gt;.
         *
         * @param tag Name of the element which caused this handler
         *            to be created. Should not be &lt;code&gt;null&lt;/code&gt;.
         *            Ignored in this implementation.
         * @param attrs Attributes of the element which caused this
         *              handler to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException if an unexpected attribute is encountered
         *            or if the &lt;code&gt;"name"&lt;/code&gt; attribute is missing.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>depends</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>ifCond</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>unlessCond</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>id</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>description</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>attrs</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>key</name> =<init> <expr><call><name><name>attrs</name>.<name>getName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>value</name> =<init> <expr><call><name><name>attrs</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"name"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>name</name> = <name>value</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name><name>name</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"name attribute must not" + " be empty"</expr></argument>,
                                <argument><expr>new <call><name>Location</name><argument_list>(<argument><expr><name><name>helperImpl</name>.<name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></then></if>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"depends"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>depends</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"if"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ifCond</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"unless"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>unlessCond</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"id"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>id</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"description"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>description</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"Unexpected attribute \"" + <name>key</name> + "\""</expr></argument>,
                            <argument><expr><name><name>helperImpl</name>.<name>locator</name></name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></else></if></else></if></else></if></else></if></else></if></else></if>
            }</block></for>

            <if>if <condition>(<expr><name>name</name> == <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"target element appears without a name attribute"</expr></argument>,
                        <argument><expr><name><name>helperImpl</name>.<name>locator</name></name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>

            <expr_stmt><expr><name>target</name> = new <call><name>Target</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// implicit target must be first on dependency list</comment>
            <expr_stmt><expr><call><name><name>target</name>.<name>addDependency</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>target</name>.<name>setName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>target</name>.<name>setIf</name></name><argument_list>(<argument><expr><name>ifCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>target</name>.<name>setUnless</name></name><argument_list>(<argument><expr><name>unlessCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>target</name>.<name>setDescription</name></name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>addTarget</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>id</name> != <name>null</name> &amp;&amp; !<call><name><name>id</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// take care of dependencies</comment>

            <if>if <condition>(<expr><call><name><name>depends</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>target</name>.<name>setDepends</name></name><argument_list>(<argument><expr><name>depends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of an element within a target.
         *
         * @param name The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException if an error occurs when initialising
         *                              the appropriate child handler
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>startElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <expr_stmt><expr><call><name>handleElement</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Start a new DataTypeHandler if element is known to be a
     * data-type and a TaskHandler otherwise.
     *
     * &lt;p&gt;Factored out of TargetHandler.&lt;/p&gt;
     *
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>handleElement</name><parameter_list>(<param><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl></param>, <param><decl><type><name>DocumentHandler</name></type> <name>parent</name></decl></param>,
            <param><decl><type><name>Target</name></type> <name>target</name></decl></param>, <param><decl><type><name>String</name></type> <name>elementName</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><call><name><name>elementName</name>.<name>equals</name></name><argument_list>(<argument><expr>"description"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>new <call><name>DescriptionHandler</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name><name>helperImpl</name>.<name>project</name>.<name>getDataTypeDefinitions</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>elementName</name></expr></argument>)</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>new <call><name>DataTypeHandler</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call>.<call><name>init</name><argument_list>(<argument><expr><name>elementName</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr>new <call><name>TaskHandler</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>null</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call>.<call><name>init</name><argument_list>(<argument><expr><name>elementName</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Handler for "description" elements.
     */</comment>
    <class><specifier>static</specifier> class <name>DescriptionHandler</name> <super><extends>extends <name>AbstractHandler</name></extends></super> <block>{

        <comment type="javadoc">/**
         * Constructor which just delegates to the superconstructor.
         *
         * @param parentHandler The handler which should be restored to the
         *                      parser at the end of the element.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         */</comment>
        <constructor><specifier>public</specifier> <name>DescriptionHandler</name><parameter_list>(<param><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl></param>,
                                  <param><decl><type><name>DocumentHandler</name></type> <name>parentHandler</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>parentHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Adds the text as description to the project.
         *
         * @param buf A character array of the text within the element.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param start The start element in the array.
         * @param count The number of characters to read from the array.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>characters</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>text</name> =<init> <expr>new <call><name>String</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>currentDescription</name> =<init> <expr><call><name><name>helperImpl</name>.<name>project</name>.<name>getDescription</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>currentDescription</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>setDescription</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>helperImpl</name>.<name>project</name>.<name>setDescription</name></name><argument_list>(<argument><expr><name>currentDescription</name> + <name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></function>

    }</block></class>

    <comment type="javadoc">/**
     * Handler for all task elements.
     */</comment>
    <class><specifier>static</specifier> class <name>TaskHandler</name> <super><extends>extends <name>AbstractHandler</name></extends></super> <block>{
        <comment type="javadoc">/** Containing target, if any. */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>Target</name></type> <name>target</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Container for the task, if any. If target is
         * non-&lt;code&gt;null&lt;/code&gt;, this must be too.
         */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>TaskContainer</name></type> <name>container</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Task created by this handler.
         */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>Task</name></type> <name>task</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Wrapper for the parent element, if any. The wrapper for this
         * element will be added to this wrapper as a child.
         */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>RuntimeConfigurable</name></type> <name>parentWrapper</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Wrapper for this element which takes care of actually configuring
         * the element, if this element is contained within a target.
         * Otherwise the configuration is performed with the configure method.
         * @see ProjectHelper#configure(Object,AttributeList,Project)
         */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>RuntimeConfigurable</name></type> <name>wrapper</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Constructor.
         *
         * @param parentHandler The handler which should be restored to the
         *                      parser at the end of the element.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param container     Container for the element.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param parentWrapper Wrapper for the parent element, if any.
         *                      May be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param target        Target this element is part of.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         */</comment>
        <constructor><specifier>public</specifier> <name>TaskHandler</name><parameter_list>(<param><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl></param>, <param><decl><type><name>DocumentHandler</name></type> <name>parentHandler</name></decl></param>,
                           <param><decl><type><name>TaskContainer</name></type> <name>container</name></decl></param>,
                           <param><decl><type><name>RuntimeConfigurable</name></type> <name>parentWrapper</name></decl></param>, <param><decl><type><name>Target</name></type> <name>target</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>parentHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>container</name></name> = <name>container</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>parentWrapper</name></name> = <name>parentWrapper</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>target</name></name> = <name>target</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Initialisation routine called after handler creation
         * with the element name and attributes. This configures
         * the element with its attributes and sets it up with
         * its parent container (if any). Nested elements are then
         * added later as the parser encounters them.
         *
         * @param tag Name of the element which caused this handler
         *            to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param attrs Attributes of the element which caused this
         *              handler to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException in case of error (not thrown in
         *                              this implementation)
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <try>try <block>{
                <expr_stmt><expr><name>task</name> = <call><name><name>helperImpl</name>.<name>project</name>.<name>createTask</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>BuildException</name></type> <name>e</name></decl></param>) <block>{
                <comment type="line">// swallow here, will be thrown again in</comment>
                <comment type="line">// UnknownElement.maybeConfigure if the problem persists.</comment>
            }</block></catch></try>
            <if>if <condition>(<expr><name>task</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>task</name> = new <call><name>UnknownElement</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>task</name>.<name>setProject</name></name><argument_list>(<argument><expr><name><name>helperImpl</name>.<name>project</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">//TODO task.setTaskType(tag);</comment>
                <expr_stmt><expr><call><name><name>task</name>.<name>setTaskName</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>task</name>.<name>setLocation</name></name><argument_list>(<argument><expr>new <call><name>Location</name><argument_list>(<argument><expr><name><name>helperImpl</name>.<name>locator</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>helperImpl</name>.<name>configureId</name></name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>task</name>.<name>setOwningTarget</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>container</name>.<name>addTask</name></name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>wrapper</name> = <call><name><name>task</name>.<name>getRuntimeConfigurableWrapper</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>wrapper</name>.<name>setAttributes</name></name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>parentWrapper</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>parentWrapper</name>.<name>addChild</name></name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></function>

        <comment type="javadoc">/**
         * Adds text to the task, using the wrapper.
         *
         * @param buf A character array of the text within the element.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param start The start element in the array.
         * @param count The number of characters to read from the array.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>characters</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>wrapper</name>.<name>addText</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of an element within a target. Task containers
         * will always use another task handler, and all other tasks
         * will always use a nested element handler.
         *
         * @param name The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException if an error occurs when initialising
         *                              the appropriate child handler
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>startElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <if>if <condition>(<expr><name>task</name> <name>instanceof</name> <name>TaskContainer</name></expr>)</condition><then> <block>{
                <comment type="line">// task can contain other tasks - no other nested elements possible</comment>
                <expr_stmt><expr>new <call><name>TaskHandler</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr>(<name>TaskContainer</name>) <name>task</name></expr></argument>, <argument><expr><name>wrapper</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call>.<call><name>init</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
                        <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr>new <call><name>NestedElementHandler</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>task</name></expr></argument>, <argument><expr><name>wrapper</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call>.<call><name>init</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Handler for all nested properties.
     */</comment>
    <class><specifier>static</specifier> class <name>NestedElementHandler</name> <super><extends>extends <name>AbstractHandler</name></extends></super> <block>{
        <comment type="javadoc">/** Parent object (task/data type/etc). */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>Object</name></type> <name>parent</name></decl>;</decl_stmt>

        <comment type="javadoc">/** The nested element itself. */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>Object</name></type> <name>child</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Wrapper for the parent element, if any. The wrapper for this
         * element will be added to this wrapper as a child.
         */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>RuntimeConfigurable</name></type> <name>parentWrapper</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Wrapper for this element which takes care of actually configuring
         * the element, if a parent wrapper is provided.
         * Otherwise the configuration is performed with the configure method.
         * @see ProjectHelper#configure(Object,AttributeList,Project)
         */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>RuntimeConfigurable</name></type> <name>childWrapper</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

        <comment type="javadoc">/** Target this element is part of, if any. */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>Target</name></type> <name>target</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Constructor.
         *
         * @param parentHandler The handler which should be restored to the
         *                      parser at the end of the element.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param parent        Parent of this element (task/data type/etc).
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param parentWrapper Wrapper for the parent element, if any.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param target        Target this element is part of.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         */</comment>
        <constructor><specifier>public</specifier> <name>NestedElementHandler</name><parameter_list>(<param><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl></param>,
                                    <param><decl><type><name>DocumentHandler</name></type> <name>parentHandler</name></decl></param>,
                                    <param><decl><type><name>Object</name></type> <name>parent</name></decl></param>,
                                    <param><decl><type><name>RuntimeConfigurable</name></type> <name>parentWrapper</name></decl></param>,
                                    <param><decl><type><name>Target</name></type> <name>target</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>parentHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>parent</name> <name>instanceof</name> <name>TypeAdapter</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>this</name>.<name>parent</name></name> = ((<name>TypeAdapter</name>) <name>parent</name>).<call><name>getProxy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name><name>this</name>.<name>parent</name></name> = <name>parent</name></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name><name>this</name>.<name>parentWrapper</name></name> = <name>parentWrapper</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>target</name></name> = <name>target</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Initialisation routine called after handler creation
         * with the element name and attributes. This configures
         * the element with its attributes and sets it up with
         * its parent container (if any). Nested elements are then
         * added later as the parser encounters them.
         *
         * @param propType Name of the element which caused this handler
         *            to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param attrs Attributes of the element which caused this
         *              handler to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException in case of error, such as a
         *            BuildException being thrown during configuration.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>(<param><decl><type><name>String</name></type> <name>propType</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name><name>Class</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>parentClass</name> =<init> <expr><call><name><name>parent</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IntrospectionHelper</name></type> <name>ih</name> =<init> <expr><call><name><name>IntrospectionHelper</name>.<name>getHelper</name></name><argument_list>(<argument><expr><name><name>helperImpl</name>.<name>project</name></name></expr></argument>, <argument><expr><name>parentClass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <try>try <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>elementName</name> =<init> <expr><call><name><name>propType</name>.<name>toLowerCase</name></name><argument_list>(<argument><expr><name><name>Locale</name>.<name>ENGLISH</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>parent</name> <name>instanceof</name> <name>UnknownElement</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>UnknownElement</name></type> <name>uc</name> =<init> <expr>new <call><name>UnknownElement</name><argument_list>(<argument><expr><name>elementName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>uc</name>.<name>setProject</name></name><argument_list>(<argument><expr><name><name>helperImpl</name>.<name>project</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr>((<name>UnknownElement</name>) <name>parent</name>).<call><name>addChild</name><argument_list>(<argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>child</name> = <name>uc</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>child</name> = <call><name><name>ih</name>.<name>createElement</name></name><argument_list>(<argument><expr><name><name>helperImpl</name>.<name>project</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>elementName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><call><name><name>helperImpl</name>.<name>configureId</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>childWrapper</name> = new <call><name>RuntimeConfigurable</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>propType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>childWrapper</name>.<name>setAttributes</name></name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>parentWrapper</name>.<name>addChild</name></name><argument_list>(<argument><expr><name>childWrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>BuildException</name></type> <name>exc</name></decl></param>) <block>{
                <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr><call><name><name>exc</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>helperImpl</name>.<name>locator</name></name></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></function>

        <comment type="javadoc">/**
         * Adds text to the element, using the wrapper.
         *
         * @param buf A character array of the text within the element.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param start The start element in the array.
         * @param count The number of characters to read from the array.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>characters</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>childWrapper</name>.<name>addText</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of an element within this one. Task containers
         * will always use a task handler, and all other elements
         * will always use another nested element handler.
         *
         * @param name The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException if an error occurs when initialising
         *                              the appropriate child handler
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>startElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <if>if <condition>(<expr><name>child</name> <name>instanceof</name> <name>TaskContainer</name></expr>)</condition><then> <block>{
                <comment type="line">// taskcontainer nested element can contain other tasks - no other</comment>
                <comment type="line">// nested elements possible</comment>
                <expr_stmt><expr>new <call><name>TaskHandler</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr>(<name>TaskContainer</name>) <name>child</name></expr></argument>, <argument><expr><name>childWrapper</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call>
                        .<call><name>init</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr>new <call><name>NestedElementHandler</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>childWrapper</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call>.<call><name>init</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
                        <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Handler for all data types directly subordinate to project or target.
     */</comment>
    <class><specifier>static</specifier> class <name>DataTypeHandler</name> <super><extends>extends <name>AbstractHandler</name></extends></super> <block>{
        <comment type="javadoc">/** Parent target, if any. */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>Target</name></type> <name>target</name></decl>;</decl_stmt>

        <comment type="javadoc">/** The element being configured. */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>Object</name></type> <name>element</name></decl>;</decl_stmt>

        <comment type="javadoc">/** Wrapper for this element, if it's part of a target. */</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>RuntimeConfigurable</name></type> <name>wrapper</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Constructor with a target specified.
         *
         * @param parentHandler The handler which should be restored to the
         *                      parser at the end of the element.
         *                      Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param target The parent target of this element.
         *               Must not be &lt;code&gt;null&lt;/code&gt;.
         */</comment>
        <constructor><specifier>public</specifier> <name>DataTypeHandler</name><parameter_list>(<param><decl><type><name>ProjectHelperImpl</name></type> <name>helperImpl</name></decl></param>, <param><decl><type><name>DocumentHandler</name></type> <name>parentHandler</name></decl></param>,
                <param><decl><type><name>Target</name></type> <name>target</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>parentHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>target</name></name> = <name>target</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Initialisation routine called after handler creation
         * with the element name and attributes. This configures
         * the element with its attributes and sets it up with
         * its parent container (if any). Nested elements are then
         * added later as the parser encounters them.
         *
         * @param propType Name of the element which caused this handler
         *            to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param attrs Attributes of the element which caused this
         *              handler to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException in case of error, such as a
         *            BuildException being thrown during configuration.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>(<param><decl><type><name>String</name></type> <name>propType</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <try>try <block>{
                <expr_stmt><expr><name>element</name> = <call><name><name>helperImpl</name>.<name>project</name>.<name>createDataType</name></name><argument_list>(<argument><expr><name>propType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>element</name> == <name>null</name></expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Unknown data type " + <name>propType</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <expr_stmt><expr><name>wrapper</name> = new <call><name>RuntimeConfigurable</name><argument_list>(<argument><expr><name>element</name></expr></argument>, <argument><expr><name>propType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>wrapper</name>.<name>setAttributes</name></name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>target</name>.<name>addDataType</name></name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>BuildException</name></type> <name>exc</name></decl></param>) <block>{
                <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr><call><name><name>exc</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>helperImpl</name>.<name>locator</name></name></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></function>

        <comment type="javadoc">/**
         * Adds text to the using the wrapper.
         *
         * @param buf A character array of the text within the element.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param start The start element in the array.
         * @param count The number of characters to read from the array.
         *
         * @see ProjectHelper#addText(Project,Object,char[],int,int)
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>characters</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>wrapper</name>.<name>addText</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of an element within this one.
         * This will always use a nested element handler.
         *
         * @param name The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception SAXParseException if an error occurs when initialising
         *                              the child handler
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>startElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <expr_stmt><expr>new <call><name>NestedElementHandler</name><argument_list>(<argument><expr><name>helperImpl</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>element</name></expr></argument>, <argument><expr><name>wrapper</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call>.<call><name>init</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Scans an attribute list for the &lt;code&gt;id&lt;/code&gt; attribute and
     * stores a reference to the target object in the project if an
     * id is found.
     * &lt;p&gt;
     * This method was moved out of the configure method to allow
     * it to be executed at parse time.
     *
     * @see #configure(Object,AttributeList,Project)
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>configureId</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>target</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attr</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>id</name> =<init> <expr><call><name><name>attr</name>.<name>getValue</name></name><argument_list>(<argument><expr>"id"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>id</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>project</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>
}</block></class>
</unit>
