<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\bzip2\CBZip2OutputStream.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>

<comment type="block">/*
 * This package is based on the work done by Keiron Liddle, Aftex Software
 * &lt;keiron@aftexsw.com&gt; to whom the Ant project is very grateful for his
 * great code.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>bzip2</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>OutputStream</name></name>;</import>

<comment type="javadoc">/**
 * An output stream that compresses into the BZip2 format (without the file
 * header chars) into another stream.
 *
 * &lt;p&gt;
 * The compression requires large amounts of memory. Thus you should call the
 * {@link #close() close()} method as soon as possible, to force
 * &lt;tt&gt;CBZip2OutputStream&lt;/tt&gt; to release the allocated memory.
 * &lt;/p&gt;
 *
 * &lt;p&gt; You can shrink the amount of allocated memory and maybe raise
 * the compression speed by choosing a lower blocksize, which in turn
 * may cause a lower compression ratio. You can avoid unnecessary
 * memory allocation by avoiding using a blocksize which is bigger
 * than the size of the input.  &lt;/p&gt;
 *
 * &lt;p&gt; You can compute the memory usage for compressing by the
 * following formula: &lt;/p&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;code&amp;gt;400k + (9 * blocksize)&amp;lt;/code&amp;gt;.
 * &lt;/pre&gt;
 *
 * &lt;p&gt; To get the memory required for decompression by {@link
 * CBZip2InputStream CBZip2InputStream} use &lt;/p&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;code&amp;gt;65k + (5 * blocksize)&amp;lt;/code&amp;gt;.
 * &lt;/pre&gt;
 *
 * &lt;table width="100%" border="1"&gt;
 * &lt;colgroup&gt; &lt;col width="33%" /&gt; &lt;col width="33%" /&gt; &lt;col width="33%" /&gt;
 * &lt;/colgroup&gt;
 * &lt;tr&gt;
 * &lt;th colspan="3"&gt;Memory usage by blocksize&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;th align="right"&gt;Blocksize&lt;/th&gt; &lt;th align="right"&gt;Compression&lt;br&gt;
 * memory usage&lt;/th&gt; &lt;th align="right"&gt;Decompression&lt;br&gt;
 * memory usage&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td align="right"&gt;100k&lt;/td&gt;
 * &lt;td align="right"&gt;1300k&lt;/td&gt;
 * &lt;td align="right"&gt;565k&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td align="right"&gt;200k&lt;/td&gt;
 * &lt;td align="right"&gt;2200k&lt;/td&gt;
 * &lt;td align="right"&gt;1065k&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td align="right"&gt;300k&lt;/td&gt;
 * &lt;td align="right"&gt;3100k&lt;/td&gt;
 * &lt;td align="right"&gt;1565k&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td align="right"&gt;400k&lt;/td&gt;
 * &lt;td align="right"&gt;4000k&lt;/td&gt;
 * &lt;td align="right"&gt;2065k&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td align="right"&gt;500k&lt;/td&gt;
 * &lt;td align="right"&gt;4900k&lt;/td&gt;
 * &lt;td align="right"&gt;2565k&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td align="right"&gt;600k&lt;/td&gt;
 * &lt;td align="right"&gt;5800k&lt;/td&gt;
 * &lt;td align="right"&gt;3065k&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td align="right"&gt;700k&lt;/td&gt;
 * &lt;td align="right"&gt;6700k&lt;/td&gt;
 * &lt;td align="right"&gt;3565k&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td align="right"&gt;800k&lt;/td&gt;
 * &lt;td align="right"&gt;7600k&lt;/td&gt;
 * &lt;td align="right"&gt;4065k&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td align="right"&gt;900k&lt;/td&gt;
 * &lt;td align="right"&gt;8500k&lt;/td&gt;
 * &lt;td align="right"&gt;4565k&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;
 * For decompression &lt;tt&gt;CBZip2InputStream&lt;/tt&gt; allocates less memory if the
 * bzipped input is smaller than one block.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Instances of this class are not threadsafe.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * TODO: Update to BZip2 1.0.1
 * &lt;/p&gt;
 *
 */</comment>
<class><specifier>public</specifier> class <name>CBZip2OutputStream</name> <super><extends>extends <name>OutputStream</name></extends>
    <implements>implements <name>BZip2Constants</name></implements></super> <block>{

    <comment type="javadoc">/**
     * The minimum supported blocksize &lt;tt&gt; == 1&lt;/tt&gt;.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MIN_BLOCKSIZE</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The maximum supported blocksize &lt;tt&gt; == 9&lt;/tt&gt;.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MAX_BLOCKSIZE</name> =<init> <expr>9</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This constant is accessible by subclasses for historical
     * purposes. If you don't know what it means then you don't need
     * it.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>SETMASK</name> =<init> <expr>(1 &lt;&lt; 21)</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This constant is accessible by subclasses for historical
     * purposes. If you don't know what it means then you don't need
     * it.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CLEARMASK</name> =<init> <expr>(~<name>SETMASK</name>)</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This constant is accessible by subclasses for historical
     * purposes. If you don't know what it means then you don't need
     * it.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>GREATER_ICOST</name> =<init> <expr>15</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This constant is accessible by subclasses for historical
     * purposes. If you don't know what it means then you don't need
     * it.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>LESSER_ICOST</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This constant is accessible by subclasses for historical
     * purposes. If you don't know what it means then you don't need
     * it.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>SMALL_THRESH</name> =<init> <expr>20</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This constant is accessible by subclasses for historical
     * purposes. If you don't know what it means then you don't need
     * it.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEPTH_THRESH</name> =<init> <expr>10</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This constant is accessible by subclasses for historical
     * purposes. If you don't know what it means then you don't need
     * it.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>WORK_FACTOR</name> =<init> <expr>30</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This constant is accessible by subclasses for historical
     * purposes. If you don't know what it means then you don't need
     * it.
     * &lt;p&gt; If you are ever unlucky/improbable enough to get a stack
     * overflow whilst sorting, increase the following constant and
     * try again. In practice I have never seen the stack go above 27
     * elems, so the following limit seems very generous.  &lt;/p&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>QSORT_STACK_SIZE</name> =<init> <expr>1000</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Knuth's increments seem to work better than Incerpi-Sedgewick here.
     * Possibly because the number of elems to sort is usually small, typically
     * &amp;lt;= 20.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>INCS</name> =<init> <expr><block>{ <expr>1</expr>, <expr>4</expr>, <expr>13</expr>, <expr>40</expr>, <expr>121</expr>, <expr>364</expr>, <expr>1093</expr>, <expr>3280</expr>,
                                        <expr>9841</expr>, <expr>29524</expr>, <expr>88573</expr>, <expr>265720</expr>, <expr>797161</expr>,
                                        <expr>2391484</expr> }</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This method is accessible by subclasses for historical
     * purposes. If you don't know what it does then you don't need
     * it.
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>void</name></type> <name>hbMakeCodeLengths</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>len</name></decl></param>, <param><decl><type><name><name>int</name><index>[]</index></name></type> <name>freq</name></decl></param>,
                                            <param><decl><type><name>int</name></type> <name>alphaSize</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxLen</name></decl></param>)</parameter_list> <block>{
        <comment type="block">/*
         * Nodes and heap entries run from 1. Entry 0 for both the heap and
         * nodes is a sentinel.
         */</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>heap</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>MAX_ALPHA_SIZE</name> * 2</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>weight</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>MAX_ALPHA_SIZE</name> * 2</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>parent</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>MAX_ALPHA_SIZE</name> * 2</expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>alphaSize</name></expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name><name>weight</name><index>[<expr><name>i</name> + 1</expr>]</index></name> = (<name><name>freq</name><index>[<expr><name>i</name></expr>]</index></name> == 0 ? 1 : <name><name>freq</name><index>[<expr><name>i</name></expr>]</index></name>) &lt;&lt; 8</expr>;</expr_stmt>
        }</block></for>

        <for>for (<init><decl><type><name>boolean</name></type> <name>tooLong</name> =<init> <expr>true</expr></init></decl>;</init> <condition><expr><name>tooLong</name></expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name>tooLong</name> = false</expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>nNodes</name> =<init> <expr><name>alphaSize</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nHeap</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>heap</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>weight</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>parent</name><index>[<expr>0</expr>]</index></name> = -2</expr>;</expr_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>alphaSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name><name>parent</name><index>[<expr><name>i</name></expr>]</index></name> = -1</expr>;</expr_stmt>
                <expr_stmt><expr><name>nHeap</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>nHeap</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>zz</name> =<init> <expr><name>nHeap</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>tmp</name> =<init> <expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name><name>weight</name><index>[<expr><name>tmp</name></expr>]</index></name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>zz</name> &gt;&gt; 1</expr>]</index></name></expr>]</index></name></expr>)</condition> <block>{
                    <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name><name>heap</name><index>[<expr><name>zz</name> &gt;&gt; 1</expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>zz</name> &gt;&gt;= 1</expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// assert (nHeap &lt; (MAX_ALPHA_SIZE + 2)) : nHeap;</comment>

            <while>while <condition>(<expr><name>nHeap</name> &gt; 1</expr>)</condition> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>n1</name> =<init> <expr><name><name>heap</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>heap</name><index>[<expr>1</expr>]</index></name> = <name><name>heap</name><index>[<expr><name>nHeap</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nHeap</name>--</expr>;</expr_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>yy</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>zz</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>tmp</name> =<init> <expr><name><name>heap</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>

                <while>while <condition>(<expr>true</expr>)</condition> <block>{
                    <expr_stmt><expr><name>yy</name> = <name>zz</name> &lt;&lt; 1</expr>;</expr_stmt>

                    <if>if <condition>(<expr><name>yy</name> &gt; <name>nHeap</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>

                    <if>if <condition>(<expr>(<name>yy</name> &lt; <name>nHeap</name>)
                        &amp;&amp; (<name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name> + 1</expr>]</index></name></expr>]</index></name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>]</index></name>)</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>yy</name>++</expr>;</expr_stmt>
                    }</block></then></if>

                    <if>if <condition>(<expr><name><name>weight</name><index>[<expr><name>tmp</name></expr>]</index></name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>]</index></name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>

                    <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>zz</name> = <name>yy</name></expr>;</expr_stmt>
                }</block></while>

                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>n2</name> =<init> <expr><name><name>heap</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>heap</name><index>[<expr>1</expr>]</index></name> = <name><name>heap</name><index>[<expr><name>nHeap</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nHeap</name>--</expr>;</expr_stmt>

                <expr_stmt><expr><name>yy</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>zz</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>tmp</name> = <name><name>heap</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

                <while>while <condition>(<expr>true</expr>)</condition> <block>{
                    <expr_stmt><expr><name>yy</name> = <name>zz</name> &lt;&lt; 1</expr>;</expr_stmt>

                    <if>if <condition>(<expr><name>yy</name> &gt; <name>nHeap</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>

                    <if>if <condition>(<expr>(<name>yy</name> &lt; <name>nHeap</name>)
                        &amp;&amp; (<name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name> + 1</expr>]</index></name></expr>]</index></name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>]</index></name>)</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>yy</name>++</expr>;</expr_stmt>
                    }</block></then></if>

                    <if>if <condition>(<expr><name><name>weight</name><index>[<expr><name>tmp</name></expr>]</index></name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>]</index></name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>

                    <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>zz</name> = <name>yy</name></expr>;</expr_stmt>
                }</block></while>

                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nNodes</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>parent</name><index>[<expr><name>n1</name></expr>]</index></name> = <name><name>parent</name><index>[<expr><name>n2</name></expr>]</index></name> = <name>nNodes</name></expr>;</expr_stmt>

                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>weight_n1</name> =<init> <expr><name><name>weight</name><index>[<expr><name>n1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>weight_n2</name> =<init> <expr><name><name>weight</name><index>[<expr><name>n2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>weight</name><index>[<expr><name>nNodes</name></expr>]</index></name> = (((<name>weight_n1</name> &amp; 0xffffff00)
                                   + (<name>weight_n2</name> &amp; 0xffffff00))
                                  |
                                  (1 + (((<name>weight_n1</name> &amp; 0x000000ff)
                                         &gt; (<name>weight_n2</name> &amp; 0x000000ff))
                                        ? (<name>weight_n1</name> &amp; 0x000000ff)
                                        : (<name>weight_n2</name> &amp; 0x000000ff))
                                   ))</expr>;</expr_stmt>

                <expr_stmt><expr><name><name>parent</name><index>[<expr><name>nNodes</name></expr>]</index></name> = -1</expr>;</expr_stmt>
                <expr_stmt><expr><name>nHeap</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>nHeap</name></expr>]</index></name> = <name>nNodes</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>tmp</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>zz</name> = <name>nHeap</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tmp</name> = <name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name></expr>;</expr_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>weight_tmp</name> =<init> <expr><name><name>weight</name><index>[<expr><name>tmp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>weight_tmp</name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>zz</name> &gt;&gt; 1</expr>]</index></name></expr>]</index></name></expr>)</condition> <block>{
                    <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name><name>heap</name><index>[<expr><name>zz</name> &gt;&gt; 1</expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>zz</name> &gt;&gt;= 1</expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>

            }</block></while>

            <comment type="line">// assert (nNodes &lt; (MAX_ALPHA_SIZE * 2)) : nNodes;</comment>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>alphaSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>k</name> =<init> <expr><name>i</name></expr></init></decl>;</decl_stmt>

                <for>for (<init><decl><type><name>int</name></type> <name>parent_k</name></decl>;</init> <condition><expr>(<name>parent_k</name> = <name><name>parent</name><index>[<expr><name>k</name></expr>]</index></name>) &gt;= 0</expr>;</condition><incr/>) <block>{
                    <expr_stmt><expr><name>k</name> = <name>parent_k</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
                }</block></for>

                <expr_stmt><expr><name><name>len</name><index>[<expr><name>i</name> - 1</expr>]</index></name> = (<name>char</name>) <name>j</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>j</name> &gt; <name>maxLen</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>tooLong</name> = true</expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

            <if>if <condition>(<expr><name>tooLong</name></expr>)</condition><then> <block>{
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>alphaSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name><name>weight</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 8</expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>j</name> = 1 + (<name>j</name> &gt;&gt; 1)</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>weight</name><index>[<expr><name>i</name></expr>]</index></name> = <name>j</name> &lt;&lt; 8</expr>;</expr_stmt>
                }</block></for>
            }</block></then></if>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>hbMakeCodeLengths</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>len</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>freq</name></decl></param>,
                                          <param><decl><type><specifier>final</specifier> <name>Data</name></type> <name>dat</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>alphaSize</name></decl></param>,
                                          <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxLen</name></decl></param>)</parameter_list> <block>{
        <comment type="block">/*
         * Nodes and heap entries run from 1. Entry 0 for both the heap and
         * nodes is a sentinel.
         */</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>heap</name> =<init> <expr><name><name>dat</name>.<name>heap</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>weight</name> =<init> <expr><name><name>dat</name>.<name>weight</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>parent</name> =<init> <expr><name><name>dat</name>.<name>parent</name></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>alphaSize</name></expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name><name>weight</name><index>[<expr><name>i</name> + 1</expr>]</index></name> = (<name><name>freq</name><index>[<expr><name>i</name></expr>]</index></name> == 0 ? 1 : <name><name>freq</name><index>[<expr><name>i</name></expr>]</index></name>) &lt;&lt; 8</expr>;</expr_stmt>
        }</block></for>

        <for>for (<init><decl><type><name>boolean</name></type> <name>tooLong</name> =<init> <expr>true</expr></init></decl>;</init> <condition><expr><name>tooLong</name></expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name>tooLong</name> = false</expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>nNodes</name> =<init> <expr><name>alphaSize</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nHeap</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>heap</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>weight</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>parent</name><index>[<expr>0</expr>]</index></name> = -2</expr>;</expr_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>alphaSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name><name>parent</name><index>[<expr><name>i</name></expr>]</index></name> = -1</expr>;</expr_stmt>
                <expr_stmt><expr><name>nHeap</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>nHeap</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>zz</name> =<init> <expr><name>nHeap</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>tmp</name> =<init> <expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name><name>weight</name><index>[<expr><name>tmp</name></expr>]</index></name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>zz</name> &gt;&gt; 1</expr>]</index></name></expr>]</index></name></expr>)</condition> <block>{
                    <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name><name>heap</name><index>[<expr><name>zz</name> &gt;&gt; 1</expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>zz</name> &gt;&gt;= 1</expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
            }</block></for>

            <while>while <condition>(<expr><name>nHeap</name> &gt; 1</expr>)</condition> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>n1</name> =<init> <expr><name><name>heap</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>heap</name><index>[<expr>1</expr>]</index></name> = <name><name>heap</name><index>[<expr><name>nHeap</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nHeap</name>--</expr>;</expr_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>yy</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>zz</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>tmp</name> =<init> <expr><name><name>heap</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>

                <while>while <condition>(<expr>true</expr>)</condition> <block>{
                    <expr_stmt><expr><name>yy</name> = <name>zz</name> &lt;&lt; 1</expr>;</expr_stmt>

                    <if>if <condition>(<expr><name>yy</name> &gt; <name>nHeap</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>

                    <if>if <condition>(<expr>(<name>yy</name> &lt; <name>nHeap</name>)
                        &amp;&amp; (<name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name> + 1</expr>]</index></name></expr>]</index></name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>]</index></name>)</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>yy</name>++</expr>;</expr_stmt>
                    }</block></then></if>

                    <if>if <condition>(<expr><name><name>weight</name><index>[<expr><name>tmp</name></expr>]</index></name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>]</index></name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>

                    <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>zz</name> = <name>yy</name></expr>;</expr_stmt>
                }</block></while>

                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>n2</name> =<init> <expr><name><name>heap</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>heap</name><index>[<expr>1</expr>]</index></name> = <name><name>heap</name><index>[<expr><name>nHeap</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nHeap</name>--</expr>;</expr_stmt>

                <expr_stmt><expr><name>yy</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>zz</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>tmp</name> = <name><name>heap</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

                <while>while <condition>(<expr>true</expr>)</condition> <block>{
                    <expr_stmt><expr><name>yy</name> = <name>zz</name> &lt;&lt; 1</expr>;</expr_stmt>

                    <if>if <condition>(<expr><name>yy</name> &gt; <name>nHeap</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>

                    <if>if <condition>(<expr>(<name>yy</name> &lt; <name>nHeap</name>)
                        &amp;&amp; (<name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name> + 1</expr>]</index></name></expr>]</index></name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>]</index></name>)</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>yy</name>++</expr>;</expr_stmt>
                    }</block></then></if>

                    <if>if <condition>(<expr><name><name>weight</name><index>[<expr><name>tmp</name></expr>]</index></name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>]</index></name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>

                    <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name><name>heap</name><index>[<expr><name>yy</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>zz</name> = <name>yy</name></expr>;</expr_stmt>
                }</block></while>

                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nNodes</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>parent</name><index>[<expr><name>n1</name></expr>]</index></name> = <name><name>parent</name><index>[<expr><name>n2</name></expr>]</index></name> = <name>nNodes</name></expr>;</expr_stmt>

                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>weight_n1</name> =<init> <expr><name><name>weight</name><index>[<expr><name>n1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>weight_n2</name> =<init> <expr><name><name>weight</name><index>[<expr><name>n2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>weight</name><index>[<expr><name>nNodes</name></expr>]</index></name> = ((<name>weight_n1</name> &amp; 0xffffff00)
                                  + (<name>weight_n2</name> &amp; 0xffffff00))
                    | (1 + (((<name>weight_n1</name> &amp; 0x000000ff)
                             &gt; (<name>weight_n2</name> &amp; 0x000000ff))
                            ? (<name>weight_n1</name> &amp; 0x000000ff)
                            : (<name>weight_n2</name> &amp; 0x000000ff)))</expr>;</expr_stmt>

                <expr_stmt><expr><name><name>parent</name><index>[<expr><name>nNodes</name></expr>]</index></name> = -1</expr>;</expr_stmt>
                <expr_stmt><expr><name>nHeap</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>nHeap</name></expr>]</index></name> = <name>nNodes</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>tmp</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>zz</name> = <name>nHeap</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tmp</name> = <name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name></expr>;</expr_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>weight_tmp</name> =<init> <expr><name><name>weight</name><index>[<expr><name>tmp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>weight_tmp</name> &lt; <name><name>weight</name><index>[<expr><name><name>heap</name><index>[<expr><name>zz</name> &gt;&gt; 1</expr>]</index></name></expr>]</index></name></expr>)</condition> <block>{
                    <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name><name>heap</name><index>[<expr><name>zz</name> &gt;&gt; 1</expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>zz</name> &gt;&gt;= 1</expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><name><name>heap</name><index>[<expr><name>zz</name></expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>

            }</block></while>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>alphaSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>k</name> =<init> <expr><name>i</name></expr></init></decl>;</decl_stmt>

                <for>for (<init><decl><type><name>int</name></type> <name>parent_k</name></decl>;</init> <condition><expr>(<name>parent_k</name> = <name><name>parent</name><index>[<expr><name>k</name></expr>]</index></name>) &gt;= 0</expr>;</condition><incr/>) <block>{
                    <expr_stmt><expr><name>k</name> = <name>parent_k</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
                }</block></for>

                <expr_stmt><expr><name><name>len</name><index>[<expr><name>i</name> - 1</expr>]</index></name> = (<name>byte</name>) <name>j</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>j</name> &gt; <name>maxLen</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>tooLong</name> = true</expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

            <if>if <condition>(<expr><name>tooLong</name></expr>)</condition><then> <block>{
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>alphaSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name><name>weight</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 8</expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>j</name> = 1 + (<name>j</name> &gt;&gt; 1)</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>weight</name><index>[<expr><name>i</name></expr>]</index></name> = <name>j</name> &lt;&lt; 8</expr>;</expr_stmt>
                }</block></for>
            }</block></then></if>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Index of the last char in the block, so the block size == last + 1.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>last</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Always: in the range 0 .. 9. The current block size is 100000 * this
     * number.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>blockSize100k</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>bsBuff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>bsLive</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CRC</name></type> <name>crc</name> =<init> <expr>new <call><name>CRC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>nInUse</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>nMTF</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>currentChar</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>runLength</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>blockCRC</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>combinedCRC</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>allowableBlockSize</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * All memory intensive stuff.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Data</name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>BlockSort</name></type> <name>blockSorter</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>OutputStream</name></type> <name>out</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Chooses a blocksize based on the given length of the data to compress.
     *
     * @return The blocksize, between {@link #MIN_BLOCKSIZE} and
     *         {@link #MAX_BLOCKSIZE} both inclusive. For a negative
     *         &lt;tt&gt;inputLength&lt;/tt&gt; this method returns &lt;tt&gt;MAX_BLOCKSIZE&lt;/tt&gt;
     *         always.
     *
     * @param inputLength
     *            The length of the data which will be compressed by
     *            &lt;tt&gt;CBZip2OutputStream&lt;/tt&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>chooseBlockSize</name><parameter_list>(<param><decl><type><name>long</name></type> <name>inputLength</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>inputLength</name> &gt; 0) ? (<name>int</name>) <call><name><name>Math</name>
            .<name>min</name></name><argument_list>(<argument><expr>(<name>inputLength</name> / 132000) + 1</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call> : <name>MAX_BLOCKSIZE</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Constructs a new &lt;tt&gt;CBZip2OutputStream&lt;/tt&gt; with a blocksize of 900k.
     *
     * &lt;p&gt;
     * &lt;b&gt;Attention: &lt;/b&gt;The caller is responsible to write the two BZip2 magic
     * bytes &lt;tt&gt;"BZ"&lt;/tt&gt; to the specified stream prior to calling this
     * constructor.
     * &lt;/p&gt;
     *
     * @param out *
     *            the destination stream.
     *
     * @throws IOException
     *             if an I/O error occurs in the specified stream.
     * @throws NullPointerException
     *             if &lt;code&gt;out == null&lt;/code&gt;.
     */</comment>
    <constructor><specifier>public</specifier> <name>CBZip2OutputStream</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>OutputStream</name></type> <name>out</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>MAX_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Constructs a new &lt;tt&gt;CBZip2OutputStream&lt;/tt&gt; with specified blocksize.
     *
     * &lt;p&gt;
     * &lt;b&gt;Attention: &lt;/b&gt;The caller is responsible to write the two BZip2 magic
     * bytes &lt;tt&gt;"BZ"&lt;/tt&gt; to the specified stream prior to calling this
     * constructor.
     * &lt;/p&gt;
     *
     *
     * @param out
     *            the destination stream.
     * @param blockSize
     *            the blockSize as 100k units.
     *
     * @throws IOException
     *             if an I/O error occurs in the specified stream.
     * @throws IllegalArgumentException
     *             if &lt;code&gt;(blockSize &lt; 1) || (blockSize &gt; 9)&lt;/code&gt;.
     * @throws NullPointerException
     *             if &lt;code&gt;out == null&lt;/code&gt;.
     *
     * @see #MIN_BLOCKSIZE
     * @see #MAX_BLOCKSIZE
     */</comment>
    <constructor><specifier>public</specifier> <name>CBZip2OutputStream</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>OutputStream</name></type> <name>out</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>blockSize</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>blockSize</name> &lt; 1</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"blockSize(" + <name>blockSize</name>
                                               + ") &lt; 1"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>blockSize</name> &gt; 9</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"blockSize(" + <name>blockSize</name>
                                               + ") &gt; 9"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <expr_stmt><expr><name><name>this</name>.<name>blockSize100k</name></name> = <name>blockSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>out</name></name> = <name>out</name></expr>;</expr_stmt>

        <comment type="block">/* 20 is just a paranoia constant */</comment>
        <expr_stmt><expr><name><name>this</name>.<name>allowableBlockSize</name></name> = (<name><name>this</name>.<name>blockSize100k</name></name> * <name><name>BZip2Constants</name>.<name>baseBlockSize</name></name>) - 20</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/** {@inheritDoc} */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>write</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>b</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name><name>this</name>.<name>out</name></name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>write0</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"closed"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Writes the current byte to the buffer, run-length encoding it
     * if it has been repeated at least four times (the first step
     * RLEs sequences of four identical bytes).
     *
     * &lt;p&gt;Flushes the current block before writing data if it is
     * full.&lt;/p&gt;
     *
     * &lt;p&gt;"write to the buffer" means adding to data.buffer starting
     * two steps "after" this.last - initially starting at index 1
     * (not 0) - and updating this.last to point to the last index
     * written minus 1.&lt;/p&gt;
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>writeRun</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>lastShadow</name> =<init> <expr><name><name>this</name>.<name>last</name></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>lastShadow</name> &lt; <name><name>this</name>.<name>allowableBlockSize</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>currentCharShadow</name> =<init> <expr><name><name>this</name>.<name>currentChar</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>Data</name></type> <name>dataShadow</name> =<init> <expr><name><name>this</name>.<name>data</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>dataShadow</name>.<name>inUse</name><index>[<expr><name>currentCharShadow</name></expr>]</index></name> = true</expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name></type> <name>ch</name> =<init> <expr>(<name>byte</name>) <name>currentCharShadow</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>runLengthShadow</name> =<init> <expr><name><name>this</name>.<name>runLength</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>this</name>.<name>crc</name>.<name>updateCRC</name></name><argument_list>(<argument><expr><name>currentCharShadow</name></expr></argument>, <argument><expr><name>runLengthShadow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <switch>switch <condition>(<expr><name>runLengthShadow</name></expr>)</condition> <block>{
            <case>case <expr>1</expr>:
                <expr_stmt><expr><name><name>dataShadow</name>.<name>block</name><index>[<expr><name>lastShadow</name> + 2</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>last</name></name> = <name>lastShadow</name> + 1</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>2</expr>:
                <expr_stmt><expr><name><name>dataShadow</name>.<name>block</name><index>[<expr><name>lastShadow</name> + 2</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dataShadow</name>.<name>block</name><index>[<expr><name>lastShadow</name> + 3</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>last</name></name> = <name>lastShadow</name> + 2</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>3</expr>: <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>block</name> =<init> <expr><name><name>dataShadow</name>.<name>block</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>block</name><index>[<expr><name>lastShadow</name> + 2</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>block</name><index>[<expr><name>lastShadow</name> + 3</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>block</name><index>[<expr><name>lastShadow</name> + 4</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>last</name></name> = <name>lastShadow</name> + 3</expr>;</expr_stmt>
            }</block>
                <break>break;</break>

            </case><default>default: <block>{
                <expr_stmt><expr><name>runLengthShadow</name> -= 4</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dataShadow</name>.<name>inUse</name><index>[<expr><name>runLengthShadow</name></expr>]</index></name> = true</expr>;</expr_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>block</name> =<init> <expr><name><name>dataShadow</name>.<name>block</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>block</name><index>[<expr><name>lastShadow</name> + 2</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>block</name><index>[<expr><name>lastShadow</name> + 3</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>block</name><index>[<expr><name>lastShadow</name> + 4</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>block</name><index>[<expr><name>lastShadow</name> + 5</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>block</name><index>[<expr><name>lastShadow</name> + 6</expr>]</index></name> = (<name>byte</name>) <name>runLengthShadow</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>last</name></name> = <name>lastShadow</name> + 5</expr>;</expr_stmt>
            }</block>
                <break>break;</break>

            </default>}</block></switch>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>endBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>initBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>writeRun</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Overridden to close the stream.
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>protected</specifier> <name>void</name></type> <name>finalize</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Throwable</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>super</name>.<name>finalize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>


    <function><type><specifier>public</specifier> <name>void</name></type> <name>finish</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>out</name> != <name>null</name></expr>)</condition><then> <block>{
            <try>try <block>{
                <if>if <condition>(<expr><name><name>this</name>.<name>runLength</name></name> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>writeRun</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name><name>this</name>.<name>currentChar</name></name> = -1</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>endBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>endCompression</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block> <finally>finally <block>{
                <expr_stmt><expr><name><name>this</name>.<name>out</name></name> = <name>null</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>data</name></name> = <name>null</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>blockSorter</name></name> = <name>null</name></expr>;</expr_stmt>
            }</block></finally></try>
        }</block></then></if>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>out</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>OutputStream</name></type> <name>outShadow</name> =<init> <expr><name><name>this</name>.<name>out</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>outShadow</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>flush</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>OutputStream</name></type> <name>outShadow</name> =<init> <expr><name><name>this</name>.<name>out</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>outShadow</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>outShadow</name>.<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>init</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <comment type="line">// write magic: done by caller who created this stream</comment>
        <comment type="line">// this.out.write('B');</comment>
        <comment type="line">// this.out.write('Z');</comment>

        <expr_stmt><expr><name><name>this</name>.<name>data</name></name> = new <call><name>Data</name><argument_list>(<argument><expr><name><name>this</name>.<name>blockSize100k</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>blockSorter</name></name> = new <call><name>BlockSort</name><argument_list>(<argument><expr><name><name>this</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Write `magic' bytes h indicating file-format == huffmanised, followed
         * by a digit indicating blockSize100k.
         */</comment>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>'h'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>'0' + <name><name>this</name>.<name>blockSize100k</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>this</name>.<name>combinedCRC</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>initBlock</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// blockNo++;</comment>
        <expr_stmt><expr><call><name><name>this</name>.<name>crc</name>.<name>initialiseCRC</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>last</name></name> = -1</expr>;</expr_stmt>
        <comment type="line">// ch = 0;</comment>

        <decl_stmt><decl><type><name>boolean</name><index>[]</index></type> <name>inUse</name> =<init> <expr><name><name>this</name>.<name>data</name>.<name>inUse</name></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>256</expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name><name>inUse</name><index>[<expr><name>i</name></expr>]</index></name> = false</expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>endBlock</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>blockCRC</name></name> = <call><name><name>this</name>.<name>crc</name>.<name>getFinalCRC</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>combinedCRC</name></name> = (<name><name>this</name>.<name>combinedCRC</name></name> &lt;&lt; 1) | (<name><name>this</name>.<name>combinedCRC</name></name> &gt;&gt;&gt; 31)</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>combinedCRC</name></name> ^= <name><name>this</name>.<name>blockCRC</name></name></expr>;</expr_stmt>

        <comment type="line">// empty block at end of file</comment>
        <if>if <condition>(<expr><name><name>this</name>.<name>last</name></name> == -1</expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>

        <comment type="block">/* sort the block and establish posn of original string */</comment>
        <expr_stmt><expr><call><name>blockSort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * A 6-byte block header, the value chosen arbitrarily as 0x314159265359
         * :-). A 32 bit value does not really give a strong enough guarantee
         * that the value will not appear by chance in the compressed
         * datastream. Worst-case probability of this event, for a 900k block,
         * is about 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48
         * bits. For a compressed file of size 100Gb -- about 100000 blocks --
         * only a 48-bit marker will do. NB: normal compression/ decompression
         * donot rely on these statistical properties. They are only important
         * when trying to recover blocks from damaged files.
         */</comment>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x31</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x41</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x59</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x26</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x53</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x59</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now the block's CRC, so it is in a known place. */</comment>
        <expr_stmt><expr><call><name>bsPutInt</name><argument_list>(<argument><expr><name><name>this</name>.<name>blockCRC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now a single bit indicating no randomisation. */</comment>
        <expr_stmt><expr><call><name>bsW</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Finally, block's contents proper. */</comment>
        <expr_stmt><expr><call><name>moveToFrontCodeAndSend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>endCompression</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <comment type="block">/*
         * Now another magic 48-bit number, 0x177245385090, to indicate the end
         * of the last block. (sqrt(pi), if you want to know. I did want to use
         * e, but it contains too much repetition -- 27 18 28 18 28 46 -- for me
         * to feel statistically comfortable. Call me paranoid.)
         */</comment>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x17</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x72</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x45</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x38</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x50</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsPutUByte</name><argument_list>(<argument><expr>0x90</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>bsPutInt</name><argument_list>(<argument><expr><name><name>this</name>.<name>combinedCRC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsFinishedWithStream</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the blocksize parameter specified at construction time.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>getBlockSize</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>blockSize100k</name></name></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>write</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>offs</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>offs</name> &lt; 0</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr>"offs(" + <name>offs</name> + ") &lt; 0."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr>"len(" + <name>len</name> + ") &lt; 0."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>offs</name> + <name>len</name> &gt; <name><name>buf</name>.<name>length</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr>"offs(" + <name>offs</name> + ") + len("
                                                + <name>len</name> + ") &gt; buf.length("
                                                + <name><name>buf</name>.<name>length</name></name> + ")."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>this</name>.<name>out</name></name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"stream closed"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <for>for (<init><decl><type><name>int</name></type> <name>hi</name> =<init> <expr><name>offs</name> + <name>len</name></expr></init></decl>;</init> <condition><expr><name>offs</name> &lt; <name>hi</name></expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><call><name>write0</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>offs</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Keeps track of the last bytes written and implicitly performs
     * run-length encoding as the first step of the bzip2 algorithm.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>write0</name><parameter_list>(<param><decl><type><name>int</name></type> <name>b</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name><name>this</name>.<name>currentChar</name></name> != -1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>b</name> &amp;= 0xff</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>this</name>.<name>currentChar</name></name> == <name>b</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>++<name><name>this</name>.<name>runLength</name></name> &gt; 254</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>writeRun</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>this</name>.<name>currentChar</name></name> = -1</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>this</name>.<name>runLength</name></name> = 0</expr>;</expr_stmt>
                }</block></then></if>
                <comment type="line">// else nothing to do</comment>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>writeRun</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>runLength</name></name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>currentChar</name></name> = <name>b</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>this</name>.<name>currentChar</name></name> = <name>b</name> &amp; 0xff</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>runLength</name></name>++</expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>hbAssignCodes</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>code</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>length</name></decl></param>,
                                      <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>minLen</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxLen</name></decl></param>,
                                      <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>alphaSize</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>vec</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>minLen</name></expr></init></decl>;</init> <condition><expr><name>n</name> &lt;= <name>maxLen</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>alphaSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr>(<name><name>length</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xff) == <name>n</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>code</name><index>[<expr><name>i</name></expr>]</index></name> = <name>vec</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>vec</name>++</expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr><name>vec</name> &lt;&lt;= 1</expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>bsFinishedWithStream</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <while>while <condition>(<expr><name><name>this</name>.<name>bsLive</name></name> &gt; 0</expr>)</condition> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>ch</name> =<init> <expr><name><name>this</name>.<name>bsBuff</name></name> &gt;&gt; 24</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>this</name>.<name>out</name>.<name>write</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// write 8-bit</comment>
            <expr_stmt><expr><name><name>this</name>.<name>bsBuff</name></name> &lt;&lt;= 8</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>bsLive</name></name> -= 8</expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>bsW</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>n</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>v</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>OutputStream</name></type> <name>outShadow</name> =<init> <expr><name><name>this</name>.<name>out</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bsLiveShadow</name> =<init> <expr><name><name>this</name>.<name>bsLive</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bsBuffShadow</name> =<init> <expr><name><name>this</name>.<name>bsBuff</name></name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>bsLiveShadow</name> &gt;= 8</expr>)</condition> <block>{
            <expr_stmt><expr><call><name><name>outShadow</name>.<name>write</name></name><argument_list>(<argument><expr><name>bsBuffShadow</name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// write 8-bit</comment>
            <expr_stmt><expr><name>bsBuffShadow</name> &lt;&lt;= 8</expr>;</expr_stmt>
            <expr_stmt><expr><name>bsLiveShadow</name> -= 8</expr>;</expr_stmt>
        }</block></while>

        <expr_stmt><expr><name><name>this</name>.<name>bsBuff</name></name> = <name>bsBuffShadow</name> | (<name>v</name> &lt;&lt; (32 - <name>bsLiveShadow</name> - <name>n</name>))</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>bsLive</name></name> = <name>bsLiveShadow</name> + <name>n</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>bsPutUByte</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>c</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>bsW</name><argument_list>(<argument><expr>8</expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>bsPutInt</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>u</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>bsW</name><argument_list>(<argument><expr>8</expr></argument>, <argument><expr>(<name>u</name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsW</name><argument_list>(<argument><expr>8</expr></argument>, <argument><expr>(<name>u</name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsW</name><argument_list>(<argument><expr>8</expr></argument>, <argument><expr>(<name>u</name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsW</name><argument_list>(<argument><expr>8</expr></argument>, <argument><expr><name>u</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>sendMTFValues</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index><index>[]</index></type> <name>len</name> =<init> <expr><name><name>this</name>.<name>data</name>.<name>sendMTFValues_len</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>alphaSize</name> =<init> <expr><name><name>this</name>.<name>nInUse</name></name> + 2</expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>t</name> =<init> <expr><name>N_GROUPS</name></expr></init></decl>;</init> <condition><expr>--<name>t</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>len_t</name> =<init> <expr><name><name>len</name><index>[<expr><name>t</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>v</name> =<init> <expr><name>alphaSize</name></expr></init></decl>;</init> <condition><expr>--<name>v</name> &gt;= 0</expr>;</condition><incr/>) <block>{
                <expr_stmt><expr><name><name>len_t</name><index>[<expr><name>v</name></expr>]</index></name> = <name>GREATER_ICOST</name></expr>;</expr_stmt>
            }</block></for>
        }</block></for>

        <comment type="block">/* Decide how many coding tables to use */</comment>
        <comment type="line">// assert (this.nMTF &gt; 0) : this.nMTF;</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>nGroups</name> =<init> <expr>(<name><name>this</name>.<name>nMTF</name></name> &lt; 200) ? 2 : (<name><name>this</name>.<name>nMTF</name></name> &lt; 600) ? 3
            : (<name><name>this</name>.<name>nMTF</name></name> &lt; 1200) ? 4 : (<name><name>this</name>.<name>nMTF</name></name> &lt; 2400) ? 5 : 6</expr></init></decl>;</decl_stmt>

        <comment type="block">/* Generate an initial set of coding tables */</comment>
        <expr_stmt><expr><call><name>sendMTFValues0</name><argument_list>(<argument><expr><name>nGroups</name></expr></argument>, <argument><expr><name>alphaSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Iterate up to N_ITERS times to improve the tables.
         */</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>nSelectors</name> =<init> <expr><call><name>sendMTFValues1</name><argument_list>(<argument><expr><name>nGroups</name></expr></argument>, <argument><expr><name>alphaSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Compute MTF values for the selectors. */</comment>
        <expr_stmt><expr><call><name>sendMTFValues2</name><argument_list>(<argument><expr><name>nGroups</name></expr></argument>, <argument><expr><name>nSelectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Assign actual codes for the tables. */</comment>
        <expr_stmt><expr><call><name>sendMTFValues3</name><argument_list>(<argument><expr><name>nGroups</name></expr></argument>, <argument><expr><name>alphaSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Transmit the mapping table. */</comment>
        <expr_stmt><expr><call><name>sendMTFValues4</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now the selectors. */</comment>
        <expr_stmt><expr><call><name>sendMTFValues5</name><argument_list>(<argument><expr><name>nGroups</name></expr></argument>, <argument><expr><name>nSelectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now the coding tables. */</comment>
        <expr_stmt><expr><call><name>sendMTFValues6</name><argument_list>(<argument><expr><name>nGroups</name></expr></argument>, <argument><expr><name>alphaSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* And finally, the block data proper */</comment>
        <expr_stmt><expr><call><name>sendMTFValues7</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>sendMTFValues0</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>nGroups</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>alphaSize</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index><index>[]</index></type> <name>len</name> =<init> <expr><name><name>this</name>.<name>data</name>.<name>sendMTFValues_len</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>mtfFreq</name> =<init> <expr><name><name>this</name>.<name>data</name>.<name>mtfFreq</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>remF</name> =<init> <expr><name><name>this</name>.<name>nMTF</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>gs</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>nPart</name> =<init> <expr><name>nGroups</name></expr></init></decl>;</init> <condition><expr><name>nPart</name> &gt; 0</expr>;</condition> <incr><expr><name>nPart</name>--</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>tFreq</name> =<init> <expr><name>remF</name> / <name>nPart</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>ge</name> =<init> <expr><name>gs</name> - 1</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>aFreq</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><specifier>final</specifier> <name>int</name></type> <name>a</name> =<init> <expr><name>alphaSize</name> - 1</expr></init></decl>;</init> <condition><expr>(<name>aFreq</name> &lt; <name>tFreq</name>) &amp;&amp; (<name>ge</name> &lt; <name>a</name>)</expr>;</condition><incr/>) <block>{
                <expr_stmt><expr><name>aFreq</name> += <name><name>mtfFreq</name><index>[<expr>++<name>ge</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>

            <if>if <condition>(<expr>(<name>ge</name> &gt; <name>gs</name>) &amp;&amp; (<name>nPart</name> != <name>nGroups</name>) &amp;&amp; (<name>nPart</name> != 1)
                &amp;&amp; (((<name>nGroups</name> - <name>nPart</name>) &amp; 1) != 0)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>aFreq</name> -= <name><name>mtfFreq</name><index>[<expr><name>ge</name>--</expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>

            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>len_np</name> =<init> <expr><name><name>len</name><index>[<expr><name>nPart</name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>v</name> =<init> <expr><name>alphaSize</name></expr></init></decl>;</init> <condition><expr>--<name>v</name> &gt;= 0</expr>;</condition><incr/>) <block>{
                <if>if <condition>(<expr>(<name>v</name> &gt;= <name>gs</name>) &amp;&amp; (<name>v</name> &lt;= <name>ge</name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>len_np</name><index>[<expr><name>v</name></expr>]</index></name> = <name>LESSER_ICOST</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name><name>len_np</name><index>[<expr><name>v</name></expr>]</index></name> = <name>GREATER_ICOST</name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>

            <expr_stmt><expr><name>gs</name> = <name>ge</name> + 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>remF</name> -= <name>aFreq</name></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>sendMTFValues1</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>nGroups</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>alphaSize</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>Data</name></type> <name>dataShadow</name> =<init> <expr><name><name>this</name>.<name>data</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index><index>[]</index></type> <name>rfreq</name> =<init> <expr><name><name>dataShadow</name>.<name>sendMTFValues_rfreq</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>fave</name> =<init> <expr><name><name>dataShadow</name>.<name>sendMTFValues_fave</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>short</name><index>[]</index></type> <name>cost</name> =<init> <expr><name><name>dataShadow</name>.<name>sendMTFValues_cost</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name><index>[]</index></type> <name>sfmap</name> =<init> <expr><name><name>dataShadow</name>.<name>sfmap</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>selector</name> =<init> <expr><name><name>dataShadow</name>.<name>selector</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index><index>[]</index></type> <name>len</name> =<init> <expr><name><name>dataShadow</name>.<name>sendMTFValues_len</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>len_0</name> =<init> <expr><name><name>len</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>len_1</name> =<init> <expr><name><name>len</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>len_2</name> =<init> <expr><name><name>len</name><index>[<expr>2</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>len_3</name> =<init> <expr><name><name>len</name><index>[<expr>3</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>len_4</name> =<init> <expr><name><name>len</name><index>[<expr>4</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>len_5</name> =<init> <expr><name><name>len</name><index>[<expr>5</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>nMTFShadow</name> =<init> <expr><name><name>this</name>.<name>nMTF</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>nSelectors</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>iter</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>iter</name> &lt; <name>N_ITERS</name></expr>;</condition> <incr><expr><name>iter</name>++</expr></incr>) <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>t</name> =<init> <expr><name>nGroups</name></expr></init></decl>;</init> <condition><expr>--<name>t</name> &gt;= 0</expr>;</condition><incr/>) <block>{
                <expr_stmt><expr><name><name>fave</name><index>[<expr><name>t</name></expr>]</index></name> = 0</expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>rfreqt</name> =<init> <expr><name><name>rfreq</name><index>[<expr><name>t</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>alphaSize</name></expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
                    <expr_stmt><expr><name><name>rfreqt</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
                }</block></for>
            }</block></for>

            <expr_stmt><expr><name>nSelectors</name> = 0</expr>;</expr_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>gs</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>gs</name> &lt; <name><name>this</name>.<name>nMTF</name></name></expr>;</condition><incr/>) <block>{
                <comment type="block">/* Set group start &amp; end marks. */</comment>

                <comment type="block">/*
                 * Calculate the cost of this group as coded by each of the
                 * coding tables.
                 */</comment>

                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>ge</name> =<init> <expr><call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>gs</name> + <name>G_SIZE</name> - 1</expr></argument>, <argument><expr><name>nMTFShadow</name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>nGroups</name> == <name>N_GROUPS</name></expr>)</condition><then> <block>{
                    <comment type="line">// unrolled version of the else-block</comment>

                    <decl_stmt><decl><type><name>short</name></type> <name>cost0</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>short</name></type> <name>cost1</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>short</name></type> <name>cost2</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>short</name></type> <name>cost3</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>short</name></type> <name>cost4</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>short</name></type> <name>cost5</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

                    <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>gs</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>ge</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>icv</name> =<init> <expr><name><name>sfmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>cost0</name> += <name><name>len_0</name><index>[<expr><name>icv</name></expr>]</index></name> &amp; 0xff</expr>;</expr_stmt>
                        <expr_stmt><expr><name>cost1</name> += <name><name>len_1</name><index>[<expr><name>icv</name></expr>]</index></name> &amp; 0xff</expr>;</expr_stmt>
                        <expr_stmt><expr><name>cost2</name> += <name><name>len_2</name><index>[<expr><name>icv</name></expr>]</index></name> &amp; 0xff</expr>;</expr_stmt>
                        <expr_stmt><expr><name>cost3</name> += <name><name>len_3</name><index>[<expr><name>icv</name></expr>]</index></name> &amp; 0xff</expr>;</expr_stmt>
                        <expr_stmt><expr><name>cost4</name> += <name><name>len_4</name><index>[<expr><name>icv</name></expr>]</index></name> &amp; 0xff</expr>;</expr_stmt>
                        <expr_stmt><expr><name>cost5</name> += <name><name>len_5</name><index>[<expr><name>icv</name></expr>]</index></name> &amp; 0xff</expr>;</expr_stmt>
                    }</block></for>

                    <expr_stmt><expr><name><name>cost</name><index>[<expr>0</expr>]</index></name> = <name>cost0</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cost</name><index>[<expr>1</expr>]</index></name> = <name>cost1</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cost</name><index>[<expr>2</expr>]</index></name> = <name>cost2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cost</name><index>[<expr>3</expr>]</index></name> = <name>cost3</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cost</name><index>[<expr>4</expr>]</index></name> = <name>cost4</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>cost</name><index>[<expr>5</expr>]</index></name> = <name>cost5</name></expr>;</expr_stmt>

                }</block></then> <else>else <block>{
                    <for>for (<init><decl><type><name>int</name></type> <name>t</name> =<init> <expr><name>nGroups</name></expr></init></decl>;</init> <condition><expr>--<name>t</name> &gt;= 0</expr>;</condition><incr/>) <block>{
                        <expr_stmt><expr><name><name>cost</name><index>[<expr><name>t</name></expr>]</index></name> = 0</expr>;</expr_stmt>
                    }</block></for>

                    <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>gs</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>ge</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>icv</name> =<init> <expr><name><name>sfmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                        <for>for (<init><decl><type><name>int</name></type> <name>t</name> =<init> <expr><name>nGroups</name></expr></init></decl>;</init> <condition><expr>--<name>t</name> &gt;= 0</expr>;</condition><incr/>) <block>{
                            <expr_stmt><expr><name><name>cost</name><index>[<expr><name>t</name></expr>]</index></name> += <name><name>len</name><index>[<expr><name>t</name></expr>]</index><index>[<expr><name>icv</name></expr>]</index></name> &amp; 0xff</expr>;</expr_stmt>
                        }</block></for>
                    }</block></for>
                }</block></else></if>

                <comment type="block">/*
                 * Find the coding table which is best for this group, and
                 * record its identity in the selector table.
                 */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>bt</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>t</name> =<init> <expr><name>nGroups</name></expr></init>, <name>bc</name> =<init> <expr>999999999</expr></init></decl>;</init> <condition><expr>--<name>t</name> &gt;= 0</expr>;</condition><incr/>) <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>cost_t</name> =<init> <expr><name><name>cost</name><index>[<expr><name>t</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>cost_t</name> &lt; <name>bc</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>bc</name> = <name>cost_t</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>bt</name> = <name>t</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>

                <expr_stmt><expr><name><name>fave</name><index>[<expr><name>bt</name></expr>]</index></name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>selector</name><index>[<expr><name>nSelectors</name></expr>]</index></name> = (<name>byte</name>) <name>bt</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nSelectors</name>++</expr>;</expr_stmt>

                <comment type="block">/*
                 * Increment the symbol frequencies for the selected table.
                 */</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>rfreq_bt</name> =<init> <expr><name><name>rfreq</name><index>[<expr><name>bt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>gs</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>ge</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name><name>rfreq_bt</name><index>[<expr><name><name>sfmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name>++</expr>;</expr_stmt>
                }</block></for>

                <expr_stmt><expr><name>gs</name> = <name>ge</name> + 1</expr>;</expr_stmt>
            }</block></for>

            <comment type="block">/*
             * Recompute the tables based on the accumulated frequencies.
             */</comment>
            <for>for (<init><decl><type><name>int</name></type> <name>t</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>t</name> &lt; <name>nGroups</name></expr>;</condition> <incr><expr><name>t</name>++</expr></incr>) <block>{
                <expr_stmt><expr><call><name>hbMakeCodeLengths</name><argument_list>(<argument><expr><name><name>len</name><index>[<expr><name>t</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rfreq</name><index>[<expr><name>t</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>this</name>.<name>data</name></name></expr></argument>, <argument><expr><name>alphaSize</name></expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>

        <return>return <expr><name>nSelectors</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>sendMTFValues2</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>nGroups</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>nSelectors</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// assert (nGroups &lt; 8) : nGroups;</comment>

        <decl_stmt><decl><type><specifier>final</specifier> <name>Data</name></type> <name>dataShadow</name> =<init> <expr><name><name>this</name>.<name>data</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>pos</name> =<init> <expr><name><name>dataShadow</name>.<name>sendMTFValues2_pos</name></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>nGroups</name></expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name><name>pos</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>byte</name>) <name>i</name></expr>;</expr_stmt>
        }</block></for>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>nSelectors</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name></type> <name>ll_i</name> =<init> <expr><name><name>dataShadow</name>.<name>selector</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>byte</name></type> <name>tmp</name> =<init> <expr><name><name>pos</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><name>ll_i</name> != <name>tmp</name></expr>)</condition> <block>{
                <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>tmp2</name> =<init> <expr><name>tmp</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>tmp</name> = <name><name>pos</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pos</name><index>[<expr><name>j</name></expr>]</index></name> = <name>tmp2</name></expr>;</expr_stmt>
            }</block></while>

            <expr_stmt><expr><name><name>pos</name><index>[<expr>0</expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dataShadow</name>.<name>selectorMtf</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>byte</name>) <name>j</name></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>sendMTFValues3</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>nGroups</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>alphaSize</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name><index>[]</index><index>[]</index></type> <name>code</name> =<init> <expr><name><name>this</name>.<name>data</name>.<name>sendMTFValues_code</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name><index>[]</index><index>[]</index></type> <name>len</name> =<init> <expr><name><name>this</name>.<name>data</name>.<name>sendMTFValues_len</name></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>t</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>t</name> &lt; <name>nGroups</name></expr>;</condition> <incr><expr><name>t</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>minLen</name> =<init> <expr>32</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>maxLen</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>len_t</name> =<init> <expr><name><name>len</name><index>[<expr><name>t</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>alphaSize</name></expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>l</name> =<init> <expr><name><name>len_t</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xff</expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>l</name> &gt; <name>maxLen</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>maxLen</name> = <name>l</name></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>l</name> &lt; <name>minLen</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>minLen</name> = <name>l</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

            <comment type="line">// assert (maxLen &lt;= 20) : maxLen;</comment>
            <comment type="line">// assert (minLen &gt;= 1) : minLen;</comment>

            <expr_stmt><expr><call><name>hbAssignCodes</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><name>t</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>len</name><index>[<expr><name>t</name></expr>]</index></name></expr></argument>, <argument><expr><name>minLen</name></expr></argument>, <argument><expr><name>maxLen</name></expr></argument>, <argument><expr><name>alphaSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>sendMTFValues4</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name><index>[]</index></type> <name>inUse</name> =<init> <expr><name><name>this</name>.<name>data</name>.<name>inUse</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name><index>[]</index></type> <name>inUse16</name> =<init> <expr><name><name>this</name>.<name>data</name>.<name>sentMTFValues4_inUse16</name></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>16</expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name><name>inUse16</name><index>[<expr><name>i</name></expr>]</index></name> = false</expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>i16</name> =<init> <expr><name>i</name> * 16</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>16</expr></init></decl>;</init> <condition><expr>--<name>j</name> &gt;= 0</expr>;</condition><incr/>) <block>{
                <if>if <condition>(<expr><name><name>inUse</name><index>[<expr><name>i16</name> + <name>j</name></expr>]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>inUse16</name><index>[<expr><name>i</name></expr>]</index></name> = true</expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></for>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 16</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>bsW</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>inUse16</name><index>[<expr><name>i</name></expr>]</index></name> ? 1 : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <decl_stmt><decl><type><specifier>final</specifier> <name>OutputStream</name></type> <name>outShadow</name> =<init> <expr><name><name>this</name>.<name>out</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bsLiveShadow</name> =<init> <expr><name><name>this</name>.<name>bsLive</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bsBuffShadow</name> =<init> <expr><name><name>this</name>.<name>bsBuff</name></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 16</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>inUse16</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>i16</name> =<init> <expr><name>i</name> * 16</expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; 16</expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                    <comment type="line">// inlined: bsW(1, inUse[i16 + j] ? 1 : 0);</comment>
                    <while>while <condition>(<expr><name>bsLiveShadow</name> &gt;= 8</expr>)</condition> <block>{
                        <expr_stmt><expr><call><name><name>outShadow</name>.<name>write</name></name><argument_list>(<argument><expr><name>bsBuffShadow</name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// write 8-bit</comment>
                        <expr_stmt><expr><name>bsBuffShadow</name> &lt;&lt;= 8</expr>;</expr_stmt>
                        <expr_stmt><expr><name>bsLiveShadow</name> -= 8</expr>;</expr_stmt>
                    }</block></while>
                    <if>if <condition>(<expr><name><name>inUse</name><index>[<expr><name>i16</name> + <name>j</name></expr>]</index></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>bsBuffShadow</name> |= 1 &lt;&lt; (32 - <name>bsLiveShadow</name> - 1)</expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>bsLiveShadow</name>++</expr>;</expr_stmt>
                }</block></for>
            }</block></then></if>
        }</block></for>

        <expr_stmt><expr><name><name>this</name>.<name>bsBuff</name></name> = <name>bsBuffShadow</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>bsLive</name></name> = <name>bsLiveShadow</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>sendMTFValues5</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>nGroups</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>nSelectors</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>bsW</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>nGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bsW</name><argument_list>(<argument><expr>15</expr></argument>, <argument><expr><name>nSelectors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>OutputStream</name></type> <name>outShadow</name> =<init> <expr><name><name>this</name>.<name>out</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>selectorMtf</name> =<init> <expr><name><name>this</name>.<name>data</name>.<name>selectorMtf</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>bsLiveShadow</name> =<init> <expr><name><name>this</name>.<name>bsLive</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bsBuffShadow</name> =<init> <expr><name><name>this</name>.<name>bsBuff</name></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>nSelectors</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init>, <name>hj</name> =<init> <expr><name><name>selectorMtf</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xff</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>hj</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <comment type="line">// inlined: bsW(1, 1);</comment>
                <while>while <condition>(<expr><name>bsLiveShadow</name> &gt;= 8</expr>)</condition> <block>{
                    <expr_stmt><expr><call><name><name>outShadow</name>.<name>write</name></name><argument_list>(<argument><expr><name>bsBuffShadow</name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>bsBuffShadow</name> &lt;&lt;= 8</expr>;</expr_stmt>
                    <expr_stmt><expr><name>bsLiveShadow</name> -= 8</expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><name>bsBuffShadow</name> |= 1 &lt;&lt; (32 - <name>bsLiveShadow</name> - 1)</expr>;</expr_stmt>
                <expr_stmt><expr><name>bsLiveShadow</name>++</expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// inlined: bsW(1, 0);</comment>
            <while>while <condition>(<expr><name>bsLiveShadow</name> &gt;= 8</expr>)</condition> <block>{
                <expr_stmt><expr><call><name><name>outShadow</name>.<name>write</name></name><argument_list>(<argument><expr><name>bsBuffShadow</name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>bsBuffShadow</name> &lt;&lt;= 8</expr>;</expr_stmt>
                <expr_stmt><expr><name>bsLiveShadow</name> -= 8</expr>;</expr_stmt>
            }</block></while>
            <comment type="line">// bsBuffShadow |= 0 &lt;&lt; (32 - bsLiveShadow - 1);</comment>
            <expr_stmt><expr><name>bsLiveShadow</name>++</expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><name><name>this</name>.<name>bsBuff</name></name> = <name>bsBuffShadow</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>bsLive</name></name> = <name>bsLiveShadow</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>sendMTFValues6</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>nGroups</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>alphaSize</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index><index>[]</index></type> <name>len</name> =<init> <expr><name><name>this</name>.<name>data</name>.<name>sendMTFValues_len</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>OutputStream</name></type> <name>outShadow</name> =<init> <expr><name><name>this</name>.<name>out</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>bsLiveShadow</name> =<init> <expr><name><name>this</name>.<name>bsLive</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bsBuffShadow</name> =<init> <expr><name><name>this</name>.<name>bsBuff</name></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>t</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>t</name> &lt; <name>nGroups</name></expr>;</condition> <incr><expr><name>t</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>len_t</name> =<init> <expr><name><name>len</name><index>[<expr><name>t</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>curr</name> =<init> <expr><name><name>len_t</name><index>[<expr>0</expr>]</index></name> &amp; 0xff</expr></init></decl>;</decl_stmt>

            <comment type="line">// inlined: bsW(5, curr);</comment>
            <while>while <condition>(<expr><name>bsLiveShadow</name> &gt;= 8</expr>)</condition> <block>{
                <expr_stmt><expr><call><name><name>outShadow</name>.<name>write</name></name><argument_list>(<argument><expr><name>bsBuffShadow</name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// write 8-bit</comment>
                <expr_stmt><expr><name>bsBuffShadow</name> &lt;&lt;= 8</expr>;</expr_stmt>
                <expr_stmt><expr><name>bsLiveShadow</name> -= 8</expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><name>bsBuffShadow</name> |= <name>curr</name> &lt;&lt; (32 - <name>bsLiveShadow</name> - 5)</expr>;</expr_stmt>
            <expr_stmt><expr><name>bsLiveShadow</name> += 5</expr>;</expr_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>alphaSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>lti</name> =<init> <expr><name><name>len_t</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xff</expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>curr</name> &lt; <name>lti</name></expr>)</condition> <block>{
                    <comment type="line">// inlined: bsW(2, 2);</comment>
                    <while>while <condition>(<expr><name>bsLiveShadow</name> &gt;= 8</expr>)</condition> <block>{
                        <expr_stmt><expr><call><name><name>outShadow</name>.<name>write</name></name><argument_list>(<argument><expr><name>bsBuffShadow</name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// write 8-bit</comment>
                        <expr_stmt><expr><name>bsBuffShadow</name> &lt;&lt;= 8</expr>;</expr_stmt>
                        <expr_stmt><expr><name>bsLiveShadow</name> -= 8</expr>;</expr_stmt>
                    }</block></while>
                    <expr_stmt><expr><name>bsBuffShadow</name> |= 2 &lt;&lt; (32 - <name>bsLiveShadow</name> - 2)</expr>;</expr_stmt>
                    <expr_stmt><expr><name>bsLiveShadow</name> += 2</expr>;</expr_stmt>

                    <expr_stmt><expr><name>curr</name>++</expr>;</expr_stmt> <comment type="block">/* 10 */</comment>
                }</block></while>

                <while>while <condition>(<expr><name>curr</name> &gt; <name>lti</name></expr>)</condition> <block>{
                    <comment type="line">// inlined: bsW(2, 3);</comment>
                    <while>while <condition>(<expr><name>bsLiveShadow</name> &gt;= 8</expr>)</condition> <block>{
                        <expr_stmt><expr><call><name><name>outShadow</name>.<name>write</name></name><argument_list>(<argument><expr><name>bsBuffShadow</name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// write 8-bit</comment>
                        <expr_stmt><expr><name>bsBuffShadow</name> &lt;&lt;= 8</expr>;</expr_stmt>
                        <expr_stmt><expr><name>bsLiveShadow</name> -= 8</expr>;</expr_stmt>
                    }</block></while>
                    <expr_stmt><expr><name>bsBuffShadow</name> |= 3 &lt;&lt; (32 - <name>bsLiveShadow</name> - 2)</expr>;</expr_stmt>
                    <expr_stmt><expr><name>bsLiveShadow</name> += 2</expr>;</expr_stmt>

                    <expr_stmt><expr><name>curr</name>--</expr>;</expr_stmt> <comment type="block">/* 11 */</comment>
                }</block></while>

                <comment type="line">// inlined: bsW(1, 0);</comment>
                <while>while <condition>(<expr><name>bsLiveShadow</name> &gt;= 8</expr>)</condition> <block>{
                    <expr_stmt><expr><call><name><name>outShadow</name>.<name>write</name></name><argument_list>(<argument><expr><name>bsBuffShadow</name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// write 8-bit</comment>
                    <expr_stmt><expr><name>bsBuffShadow</name> &lt;&lt;= 8</expr>;</expr_stmt>
                    <expr_stmt><expr><name>bsLiveShadow</name> -= 8</expr>;</expr_stmt>
                }</block></while>
                <comment type="line">// bsBuffShadow |= 0 &lt;&lt; (32 - bsLiveShadow - 1);</comment>
                <expr_stmt><expr><name>bsLiveShadow</name>++</expr>;</expr_stmt>
            }</block></for>
        }</block></for>

        <expr_stmt><expr><name><name>this</name>.<name>bsBuff</name></name> = <name>bsBuffShadow</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>bsLive</name></name> = <name>bsLiveShadow</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>sendMTFValues7</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>Data</name></type> <name>dataShadow</name> =<init> <expr><name><name>this</name>.<name>data</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index><index>[]</index></type> <name>len</name> =<init> <expr><name><name>dataShadow</name>.<name>sendMTFValues_len</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index><index>[]</index></type> <name>code</name> =<init> <expr><name><name>dataShadow</name>.<name>sendMTFValues_code</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>OutputStream</name></type> <name>outShadow</name> =<init> <expr><name><name>this</name>.<name>out</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>selector</name> =<init> <expr><name><name>dataShadow</name>.<name>selector</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name><index>[]</index></type> <name>sfmap</name> =<init> <expr><name><name>dataShadow</name>.<name>sfmap</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>nMTFShadow</name> =<init> <expr><name><name>this</name>.<name>nMTF</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>selCtr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>bsLiveShadow</name> =<init> <expr><name><name>this</name>.<name>bsLive</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bsBuffShadow</name> =<init> <expr><name><name>this</name>.<name>bsBuff</name></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>gs</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>gs</name> &lt; <name>nMTFShadow</name></expr>;</condition><incr/>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>ge</name> =<init> <expr><call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>gs</name> + <name>G_SIZE</name> - 1</expr></argument>, <argument><expr><name>nMTFShadow</name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>selector_selCtr</name> =<init> <expr><name><name>selector</name><index>[<expr><name>selCtr</name></expr>]</index></name> &amp; 0xff</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>code_selCtr</name> =<init> <expr><name><name>code</name><index>[<expr><name>selector_selCtr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>len_selCtr</name> =<init> <expr><name><name>len</name><index>[<expr><name>selector_selCtr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><name>gs</name> &lt;= <name>ge</name></expr>)</condition> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sfmap_i</name> =<init> <expr><name><name>sfmap</name><index>[<expr><name>gs</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <comment type="line">//</comment>
                <comment type="line">// inlined: bsW(len_selCtr[sfmap_i] &amp; 0xff,</comment>
                <comment type="line">// code_selCtr[sfmap_i]);</comment>
                <comment type="line">//</comment>
                <while>while <condition>(<expr><name>bsLiveShadow</name> &gt;= 8</expr>)</condition> <block>{
                    <expr_stmt><expr><call><name><name>outShadow</name>.<name>write</name></name><argument_list>(<argument><expr><name>bsBuffShadow</name> &gt;&gt; 24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>bsBuffShadow</name> &lt;&lt;= 8</expr>;</expr_stmt>
                    <expr_stmt><expr><name>bsLiveShadow</name> -= 8</expr>;</expr_stmt>
                }</block></while>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>n</name> =<init> <expr><name><name>len_selCtr</name><index>[<expr><name>sfmap_i</name></expr>]</index></name> &amp; 0xFF</expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>bsBuffShadow</name> |= <name><name>code_selCtr</name><index>[<expr><name>sfmap_i</name></expr>]</index></name> &lt;&lt; (32 - <name>bsLiveShadow</name> - <name>n</name>)</expr>;</expr_stmt>
                <expr_stmt><expr><name>bsLiveShadow</name> += <name>n</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>gs</name>++</expr>;</expr_stmt>
            }</block></while>

            <expr_stmt><expr><name>gs</name> = <name>ge</name> + 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>selCtr</name>++</expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><name><name>this</name>.<name>bsBuff</name></name> = <name>bsBuffShadow</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>bsLive</name></name> = <name>bsLiveShadow</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>moveToFrontCodeAndSend</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>bsW</name><argument_list>(<argument><expr>24</expr></argument>, <argument><expr><name><name>this</name>.<name>data</name>.<name>origPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>generateMTFValues</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sendMTFValues</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>blockSort</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>blockSorter</name>.<name>blockSort</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * Performs Move-To-Front on the Burrows-Wheeler transformed
     * buffer, storing the MTFed data in data.sfmap in RUNA/RUNB
     * run-length-encoded form.
     *
     * &lt;p&gt;Keeps track of byte frequencies in data.mtfFreq at the same time.&lt;/p&gt;
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>generateMTFValues</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>lastShadow</name> =<init> <expr><name><name>this</name>.<name>last</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Data</name></type> <name>dataShadow</name> =<init> <expr><name><name>this</name>.<name>data</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name><index>[]</index></type> <name>inUse</name> =<init> <expr><name><name>dataShadow</name>.<name>inUse</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>block</name> =<init> <expr><name><name>dataShadow</name>.<name>block</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>fmap</name> =<init> <expr><name><name>dataShadow</name>.<name>fmap</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name><index>[]</index></type> <name>sfmap</name> =<init> <expr><name><name>dataShadow</name>.<name>sfmap</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>mtfFreq</name> =<init> <expr><name><name>dataShadow</name>.<name>mtfFreq</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>unseqToSeq</name> =<init> <expr><name><name>dataShadow</name>.<name>unseqToSeq</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>yy</name> =<init> <expr><name><name>dataShadow</name>.<name>generateMTFValues_yy</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// make maps</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nInUseShadow</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>inUse</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>unseqToSeq</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>byte</name>) <name>nInUseShadow</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nInUseShadow</name>++</expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name><name>this</name>.<name>nInUse</name></name> = <name>nInUseShadow</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>eob</name> =<init> <expr><name>nInUseShadow</name> + 1</expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>eob</name></expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
            <expr_stmt><expr><name><name>mtfFreq</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        }</block></for>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>nInUseShadow</name></expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name><name>yy</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>byte</name>) <name>i</name></expr>;</expr_stmt>
        }</block></for>

        <decl_stmt><decl><type><name>int</name></type> <name>wr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>zPend</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>lastShadow</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name></type> <name>ll_i</name> =<init> <expr><name><name>unseqToSeq</name><index>[<expr><name><name>block</name><index>[<expr><name><name>fmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> &amp; 0xff</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>byte</name></type> <name>tmp</name> =<init> <expr><name><name>yy</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><name>ll_i</name> != <name>tmp</name></expr>)</condition> <block>{
                <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>tmp2</name> =<init> <expr><name>tmp</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>tmp</name> = <name><name>yy</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>yy</name><index>[<expr><name>j</name></expr>]</index></name> = <name>tmp2</name></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><name><name>yy</name><index>[<expr>0</expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>j</name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>zPend</name>++</expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><name>zPend</name> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>zPend</name>--</expr>;</expr_stmt>
                    <while>while <condition>(<expr>true</expr>)</condition> <block>{
                        <if>if <condition>(<expr>(<name>zPend</name> &amp; 1) == 0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>sfmap</name><index>[<expr><name>wr</name></expr>]</index></name> = <name>RUNA</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>wr</name>++</expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>mtfFreq</name><index>[<expr><name>RUNA</name></expr>]</index></name>++</expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><name><name>sfmap</name><index>[<expr><name>wr</name></expr>]</index></name> = <name>RUNB</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>wr</name>++</expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>mtfFreq</name><index>[<expr><name>RUNB</name></expr>]</index></name>++</expr>;</expr_stmt>
                        }</block></else></if>

                        <if>if <condition>(<expr><name>zPend</name> &gt;= 2</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>zPend</name> = (<name>zPend</name> - 2) &gt;&gt; 1</expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <break>break;</break>
                        }</block></else></if>
                    }</block></while>
                    <expr_stmt><expr><name>zPend</name> = 0</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name><name>sfmap</name><index>[<expr><name>wr</name></expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>wr</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mtfFreq</name><index>[<expr><name>j</name> + 1</expr>]</index></name>++</expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

        <if>if <condition>(<expr><name>zPend</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>zPend</name>--</expr>;</expr_stmt>
            <while>while <condition>(<expr>true</expr>)</condition> <block>{
                <if>if <condition>(<expr>(<name>zPend</name> &amp; 1) == 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>sfmap</name><index>[<expr><name>wr</name></expr>]</index></name> = <name>RUNA</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>wr</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>mtfFreq</name><index>[<expr><name>RUNA</name></expr>]</index></name>++</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name><name>sfmap</name><index>[<expr><name>wr</name></expr>]</index></name> = <name>RUNB</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>wr</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>mtfFreq</name><index>[<expr><name>RUNB</name></expr>]</index></name>++</expr>;</expr_stmt>
                }</block></else></if>

                <if>if <condition>(<expr><name>zPend</name> &gt;= 2</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>zPend</name> = (<name>zPend</name> - 2) &gt;&gt; 1</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <break>break;</break>
                }</block></else></if>
            }</block></while>
        }</block></then></if>

        <expr_stmt><expr><name><name>sfmap</name><index>[<expr><name>wr</name></expr>]</index></name> = (<name>char</name>) <name>eob</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mtfFreq</name><index>[<expr><name>eob</name></expr>]</index></name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>nMTF</name></name> = <name>wr</name> + 1</expr>;</expr_stmt>
    }</block></function>

    <class><specifier>static</specifier> <specifier>final</specifier> class <name>Data</name> <super><extends>extends <name>Object</name></extends></super> <block>{

        <comment type="line">// with blockSize 900k</comment>
        <comment type="block">/* maps unsigned byte =&gt; "does it occur in block" */</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name><index>[]</index></type> <name>inUse</name> =<init> <expr>new <name><name>boolean</name><index>[<expr>256</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 256 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>unseqToSeq</name> =<init> <expr>new <name><name>byte</name><index>[<expr>256</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 256 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>mtfFreq</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>MAX_ALPHA_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 1032 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>selector</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>MAX_SELECTORS</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 18002 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>selectorMtf</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>MAX_SELECTORS</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 18002 byte</comment>

        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>generateMTFValues_yy</name> =<init> <expr>new <name><name>byte</name><index>[<expr>256</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 256 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index><index>[]</index></type> <name>sendMTFValues_len</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>N_GROUPS</name></expr>]</index><index>[<expr><name>MAX_ALPHA_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 1548</comment>
        <comment type="line">// byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index><index>[]</index></type> <name>sendMTFValues_rfreq</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>N_GROUPS</name></expr>]</index><index>[<expr><name>MAX_ALPHA_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 6192</comment>
        <comment type="line">// byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>sendMTFValues_fave</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>N_GROUPS</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 24 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>short</name><index>[]</index></type> <name>sendMTFValues_cost</name> =<init> <expr>new <name><name>short</name><index>[<expr><name>N_GROUPS</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 12 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index><index>[]</index></type> <name>sendMTFValues_code</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>N_GROUPS</name></expr>]</index><index>[<expr><name>MAX_ALPHA_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 6192</comment>
        <comment type="line">// byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>sendMTFValues2_pos</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>N_GROUPS</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 6 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name><index>[]</index></type> <name>sentMTFValues4_inUse16</name> =<init> <expr>new <name><name>boolean</name><index>[<expr>16</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 16 byte</comment>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>heap</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>MAX_ALPHA_SIZE</name> + 2</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 1040 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>weight</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>MAX_ALPHA_SIZE</name> * 2</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 2064 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>parent</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>MAX_ALPHA_SIZE</name> * 2</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 2064 byte</comment>

        <comment type="line">// ------------</comment>
        <comment type="line">// 333408 byte</comment>

        <comment type="block">/* holds the RLEd block of original data starting at index 1.
         * After sorting the last byte added to the buffer is at index
         * 0. */</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>block</name></decl>;</decl_stmt> <comment type="line">// 900021 byte</comment>
        <comment type="block">/* maps index in Burrows-Wheeler transformed block =&gt; index of
         * byte in original block */</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>fmap</name></decl>;</decl_stmt> <comment type="line">// 3600000 byte</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name><index>[]</index></type> <name>sfmap</name></decl>;</decl_stmt> <comment type="line">// 3600000 byte</comment>
        <comment type="line">// ------------</comment>
        <comment type="line">// 8433529 byte</comment>
        <comment type="line">// ============</comment>

        <comment type="javadoc">/**
         * Index of original line in Burrows-Wheeler table.
         *
         * &lt;p&gt;This is the index in fmap that points to the last byte
         * of the original data.&lt;/p&gt;
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>origPtr</name></decl>;</decl_stmt>

        <constructor><name>Data</name><parameter_list>(<param><decl><type><name>int</name></type> <name>blockSize100k</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>n</name> =<init> <expr><name>blockSize100k</name> * <name><name>BZip2Constants</name>.<name>baseBlockSize</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>block</name></name> = new <name><name>byte</name><index>[<expr>(<name>n</name> + 1 + <name>NUM_OVERSHOOT_BYTES</name>)</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>fmap</name></name> = new <name><name>int</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>sfmap</name></name> = new <name><name>char</name><index>[<expr>2 * <name>n</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></constructor>

    }</block></class>

}</block></class>
</unit>
