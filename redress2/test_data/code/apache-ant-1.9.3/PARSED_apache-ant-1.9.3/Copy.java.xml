<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\taskdefs\Copy.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashMap</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashSet</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Hashtable</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Task</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>DirectoryScanner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Mapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>FileSet</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>FilterSet</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>FilterChain</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>FilterSetCollection</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Resource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>ResourceCollection</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>ResourceFactory</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>FileProvider</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>FileResource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileNameMapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>IdentityMapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>LinkedHashtable</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>ResourceUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>SourceFileScanner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FlatFileNameMapper</name></name>;</import>

<comment type="javadoc">/**
 * Copies a file or directory to a new file
 * or directory.  Files are only copied if the source file is newer
 * than the destination file, or when the destination file does not
 * exist.  It is possible to explicitly overwrite existing files.&lt;/p&gt;
 *
 * &lt;p&gt;This implementation is based on Arnout Kuiper's initial design
 * document, the following mailing list discussions, and the
 * copyfile/copydir tasks.&lt;/p&gt;
 *
 *
 * @since Ant 1.2
 *
 * @ant.task category="filesystem"
 */</comment>
<class><specifier>public</specifier> class <name>Copy</name> <super><extends>extends <name>Task</name></extends></super> <block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>MSG_WHEN_COPYING_EMPTY_RC_TO_FILE</name> =<init>
        <expr>"Cannot perform operation from directory to file."</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>File</name></type> <name>NULL_FILE_PLACEHOLDER</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr>"/NULL_FILE"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>LINE_SEPARATOR</name> =<init> <expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"line.separator"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// CheckStyle:VisibilityModifier OFF - bc</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>File</name></type> <name>file</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>     <comment type="line">// the source file</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>File</name></type> <name>destFile</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt> <comment type="line">// the destination file</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>File</name></type> <name>destDir</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>  <comment type="line">// the destination directory</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name></type> <name>rcs</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// here to provide API backwards compatibility</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>ResourceCollection</name></argument>&gt;</argument_list></name></type> <name>filesets</name> =<init> <expr><name>rcs</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>enableMultipleMappings</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>filtering</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>preserveLastModified</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>forceOverwrite</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>flatten</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>int</name></type> <name>verbosity</name> =<init> <expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>includeEmpty</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>failonerror</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name><index>[]</index></argument>&gt;</argument_list></name></type> <name>fileCopyMap</name> =<init> <expr>new <call><name><name>LinkedHashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>String</name><index>[]</index></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name><index>[]</index></argument>&gt;</argument_list></name></type> <name>dirCopyMap</name> =<init> <expr>new <call><name><name>LinkedHashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>String</name><index>[]</index></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>File</name></argument>, <argument><name>File</name></argument>&gt;</argument_list></name></type> <name>completeDirMap</name> =<init> <expr>new <call><name><name>LinkedHashtable</name><argument_list>&lt;<argument><name>File</name></argument>, <argument><name>File</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>protected</specifier> <name>Mapper</name></type> <name>mapperElement</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>FileUtils</name></type> <name>fileUtils</name></decl>;</decl_stmt>
    <comment type="line">//CheckStyle:VisibilityModifier ON</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name></type> <name>filterChains</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>FilterSet</name></argument>&gt;</argument_list></name></type> <name>filterSets</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>FilterSet</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>inputEncoding</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>outputEncoding</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>granularity</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>force</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>quiet</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="line">// used to store the single non-file resource to copy when the</comment>
    <comment type="line">// tofile attribute has been used</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Resource</name></type> <name>singleResource</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Copy task constructor.
     */</comment>
    <constructor><specifier>public</specifier> <name>Copy</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>fileUtils</name> = <call><name><name>FileUtils</name>.<name>getFileUtils</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>granularity</name> = <call><name><name>fileUtils</name>.<name>getFileTimestampGranularity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Get the FileUtils for this task.
     * @return the fileutils object.
     */</comment>
    <function><type><specifier>protected</specifier> <name>FileUtils</name></type> <name>getFileUtils</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>fileUtils</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set a single source file to copy.
     * @param file the file to copy.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFile</name><parameter_list>(<param><decl><type><name>File</name></type> <name>file</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>file</name></name> = <name>file</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the destination file.
     * @param destFile the file to copy to.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTofile</name><parameter_list>(<param><decl><type><name>File</name></type> <name>destFile</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>destFile</name></name> = <name>destFile</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the destination directory.
     * @param destDir the destination directory.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTodir</name><parameter_list>(<param><decl><type><name>File</name></type> <name>destDir</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>destDir</name></name> = <name>destDir</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add a FilterChain.
     * @return a filter chain object.
     */</comment>
    <function><type><specifier>public</specifier> <name>FilterChain</name></type> <name>createFilterChain</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>FilterChain</name></type> <name>filterChain</name> =<init> <expr>new <call><name>FilterChain</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>filterChains</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>filterChain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>filterChain</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Add a filterset.
     * @return a filter set object.
     */</comment>
    <function><type><specifier>public</specifier> <name>FilterSet</name></type> <name>createFilterSet</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>FilterSet</name></type> <name>filterSet</name> =<init> <expr>new <call><name>FilterSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>filterSets</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>filterSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>filterSet</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Give the copied files the same last modified time as the original files.
     * @param preserve a boolean string.
     * @deprecated since 1.5.x.
     *             setPreserveLastModified(String) has been deprecated and
     *             replaced with setPreserveLastModified(boolean) to
     *             consistently let the Introspection mechanism work.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setPreserveLastModified</name><parameter_list>(<param><decl><type><name>String</name></type> <name>preserve</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>setPreserveLastModified</name><argument_list>(<argument><expr><call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>preserve</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Give the copied files the same last modified time as the original files.
     * @param preserve if true preserve the modified time; default is false.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setPreserveLastModified</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>preserve</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>preserveLastModified</name> = <name>preserve</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Get whether to give the copied files the same last modified time as
     * the original files.
     * @return the whether destination files will inherit the modification
     *         times of the corresponding source files.
     * @since 1.32, Ant 1.5
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getPreserveLastModified</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>preserveLastModified</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Get the filtersets being applied to this operation.
     *
     * @return a vector of FilterSet objects.
     */</comment>
    <function><type><specifier>protected</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>FilterSet</name></argument>&gt;</argument_list></name></type> <name>getFilterSets</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>filterSets</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Get the filterchains being applied to this operation.
     *
     * @return a vector of FilterChain objects.
     */</comment>
    <function><type><specifier>protected</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name></type> <name>getFilterChains</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>filterChains</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set filtering mode.
     * @param filtering if true enable filtering; default is false.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFiltering</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>filtering</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>filtering</name></name> = <name>filtering</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set overwrite mode regarding existing destination file(s).
     * @param overwrite if true force overwriting of destination file(s)
     *                  even if the destination file(s) are younger than
     *                  the corresponding source file. Default is false.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setOverwrite</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>overwrite</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>forceOverwrite</name></name> = <name>overwrite</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether read-only destinations will be overwritten.
     *
     * &lt;p&gt;Defaults to false&lt;/p&gt;
     *
     * @since Ant 1.8.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setForce</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>f</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>force</name> = <name>f</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether read-only destinations will be overwritten.
     *
     * @since Ant 1.8.2
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getForce</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>force</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set whether files copied from directory trees will be "flattened"
     * into a single directory.  If there are multiple files with
     * the same name in the source directory tree, only the first
     * file will be copied into the "flattened" directory, unless
     * the forceoverwrite attribute is true.
     * @param flatten if true flatten the destination directory. Default
     *                is false.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFlatten</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>flatten</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>flatten</name></name> = <name>flatten</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set verbose mode. Used to force listing of all names of copied files.
     * @param verbose whether to output the names of copied files.
     *                Default is false.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setVerbose</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>verbose</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>verbosity</name></name> = <name>verbose</name> ? <name><name>Project</name>.<name>MSG_INFO</name></name> : <name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set whether to copy empty directories.
     * @param includeEmpty if true copy empty directories. Default is true.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setIncludeEmptyDirs</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>includeEmpty</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>includeEmpty</name></name> = <name>includeEmpty</name></expr>;</expr_stmt>
    }</block></function>

	<comment type="javadoc">/**
	 * Set quiet mode. Used to hide messages when a file or directory to be
	 * copied does not exist.
	 *
	 * @param quiet
	 *            whether or not to display error messages when a file or
	 *            directory does not exist. Default is false.
	 */</comment>
	<function><type><specifier>public</specifier> <name>void</name></type> <name>setQuiet</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>quiet</name></decl></param>)</parameter_list> <block>{
		<expr_stmt><expr><name><name>this</name>.<name>quiet</name></name> = <name>quiet</name></expr>;</expr_stmt>
	}</block></function>

    <comment type="javadoc">/**
     * Set method of handling mappers that return multiple
     * mappings for a given source path.
     * @param enableMultipleMappings If true the task will
     *        copy to all the mappings for a given source path, if
     *        false, only the first file or directory is
     *        processed.
     *        By default, this setting is false to provide backward
     *        compatibility with earlier releases.
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setEnableMultipleMappings</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>enableMultipleMappings</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>enableMultipleMappings</name></name> = <name>enableMultipleMappings</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Get whether multiple mapping is enabled.
     * @return true if multiple mapping is enabled; false otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isEnableMultipleMapping</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>enableMultipleMappings</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set whether to fail when errors are encountered. If false, note errors
     * to the output but keep going. Default is true.
     * @param failonerror true or false.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFailOnError</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>failonerror</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>failonerror</name></name> = <name>failonerror</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add a set of files to copy.
     * @param set a set of files to copy.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addFileset</name><parameter_list>(<param><decl><type><name>FileSet</name></type> <name>set</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add a collection of files to copy.
     * @param res a resource collection to copy.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>ResourceCollection</name></type> <name>res</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>rcs</name>.<name>add</name></name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Define the mapper to map source to destination files.
     * @return a mapper to be configured.
     * @exception BuildException if more than one mapper is defined.
     */</comment>
    <function><type><specifier>public</specifier> <name>Mapper</name></type> <name>createMapper</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>mapperElement</name> != <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Cannot define more than one mapper"</expr></argument>,
                                     <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>mapperElement</name> = new <call><name>Mapper</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>mapperElement</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Add a nested filenamemapper.
     * @param fileNameMapper the mapper to add.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>FileNameMapper</name></type> <name>fileNameMapper</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>createMapper</name><argument_list>()</argument_list></call>.<call><name>add</name><argument_list>(<argument><expr><name>fileNameMapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the character encoding.
     * @param encoding the character encoding.
     * @since 1.32, Ant 1.5
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setEncoding</name><parameter_list>(<param><decl><type><name>String</name></type> <name>encoding</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>inputEncoding</name></name> = <name>encoding</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>outputEncoding</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>outputEncoding</name> = <name>encoding</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Get the character encoding to be used.
     * @return the character encoding, &lt;code&gt;null&lt;/code&gt; if not set.
     *
     * @since 1.32, Ant 1.5
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getEncoding</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>inputEncoding</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set the character encoding for output files.
     * @param encoding the output character encoding.
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setOutputEncoding</name><parameter_list>(<param><decl><type><name>String</name></type> <name>encoding</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>outputEncoding</name></name> = <name>encoding</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Get the character encoding for output files.
     * @return the character encoding for output files,
     * &lt;code&gt;null&lt;/code&gt; if not set.
     *
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getOutputEncoding</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>outputEncoding</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set the number of milliseconds leeway to give before deciding a
     * target is out of date.
     *
     * &lt;p&gt;Default is 1 second, or 2 seconds on DOS systems.&lt;/p&gt;
     * @param granularity the granularity used to decide if a target is out of
     *                    date.
     * @since Ant 1.6.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setGranularity</name><parameter_list>(<param><decl><type><name>long</name></type> <name>granularity</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>granularity</name></name> = <name>granularity</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Perform the copy operation.
     * @exception BuildException if an error occurs.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>File</name></type> <name>savedFile</name> =<init> <expr><name>file</name></expr></init></decl>;</decl_stmt> <comment type="line">// may be altered in validateAttributes</comment>
        <decl_stmt><decl><type><name>File</name></type> <name>savedDestFile</name> =<init> <expr><name>destFile</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>File</name></type> <name>savedDestDir</name> =<init> <expr><name>destDir</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ResourceCollection</name></type> <name>savedRc</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>file</name> == <name>null</name> &amp;&amp; <name>destFile</name> != <name>null</name> &amp;&amp; <call><name><name>rcs</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then> <block>{
            <comment type="line">// will be removed in validateAttributes</comment>
            <expr_stmt><expr><name>savedRc</name> = (<name>ResourceCollection</name>) <call><name><name>rcs</name>.<name>elementAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <try>try <block>{
            <comment type="line">// make sure we don't have an illegal set of options</comment>
            <try>try <block>{
                <expr_stmt><expr><call><name>validateAttributes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>BuildException</name></type> <name>e</name></decl></param>) <block>{
                <if>if <condition>(<expr><name>failonerror</name>
                    || !<call><name>getMessage</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call>
                    .<call><name>equals</name><argument_list>(<argument><expr><name>MSG_WHEN_COPYING_EMPTY_RC_TO_FILE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <throw>throw <expr><name>e</name></expr>;</throw>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Warning: " + <call><name>getMessage</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                }</block></else></if>
            }</block></catch></try>

            <comment type="line">// deal with the single file</comment>
            <expr_stmt><expr><call><name>copySingleFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// deal with the ResourceCollections</comment>

            <comment type="block">/* for historical and performance reasons we have to do
               things in a rather complex way.

               (1) Move is optimized to move directories if a fileset
               has been included completely, therefore FileSets need a
               special treatment.  This is also required to support
               the failOnError semantice (skip filesets with broken
               basedir but handle the remaining collections).

               (2) We carry around a few protected methods that work
               on basedirs and arrays of names.  To optimize stuff, all
               resources with the same basedir get collected in
               separate lists and then each list is handled in one go.
            */</comment>

            <decl_stmt><decl><type><name><name>HashMap</name><argument_list>&lt;<argument><name>File</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>filesByBasedir</name> =<init> <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>File</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>HashMap</name><argument_list>&lt;<argument><name>File</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>dirsByBasedir</name> =<init> <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>File</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>HashSet</name><argument_list>&lt;<argument><name>File</name></argument>&gt;</argument_list></name></type> <name>baseDirs</name> =<init> <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>File</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>nonFileResources</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name> =<init> <expr><call><name><name>rcs</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>ResourceCollection</name></type> <name>rc</name> =<init> <expr><call><name><name>rcs</name>.<name>elementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Step (1) - beware of the ZipFileSet</comment>
                <if>if <condition>(<expr><name>rc</name> <name>instanceof</name> <name>FileSet</name> &amp;&amp; <call><name><name>rc</name>.<name>isFilesystemOnly</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>FileSet</name></type> <name>fs</name> =<init> <expr>(<name>FileSet</name>) <name>rc</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>DirectoryScanner</name></type> <name>ds</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
                    <try>try <block>{
                        <expr_stmt><expr><name>ds</name> = <call><name><name>fs</name>.<name>getDirectoryScanner</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> <catch>catch (<param><decl><type><name>BuildException</name></type> <name>e</name></decl></param>) <block>{
                        <if>if <condition>(<expr><name>failonerror</name>
                            || !<call><name>getMessage</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call>.<call><name>endsWith</name><argument_list>(<argument><expr><name><name>DirectoryScanner</name>
                                                       .<name>DOES_NOT_EXIST_POSTFIX</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <throw>throw <expr><name>e</name></expr>;</throw>
                        }</block></then> <else>else <block>{
                            <if>if <condition>(<expr>!<name>quiet</name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Warning: " + <call><name>getMessage</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if>
                            <continue>continue;</continue>
                        }</block></else></if>
                    }</block></catch></try>
                    <decl_stmt><decl><type><name>File</name></type> <name>fromDir</name> =<init> <expr><call><name><name>fs</name>.<name>getDir</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>srcFiles</name> =<init> <expr><call><name><name>ds</name>.<name>getIncludedFiles</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>srcDirs</name> =<init> <expr><call><name><name>ds</name>.<name>getIncludedDirectories</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<name>flatten</name> &amp;&amp; <name>mapperElement</name> == <name>null</name>
                        &amp;&amp; <call><name><name>ds</name>.<name>isEverythingIncluded</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>fs</name>.<name>hasPatterns</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>completeDirMap</name>.<name>put</name></name><argument_list>(<argument><expr><name>fromDir</name></expr></argument>, <argument><expr><name>destDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>fromDir</name></expr></argument>, <argument><expr><name>srcFiles</name></expr></argument>, <argument><expr><name>filesByBasedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>fromDir</name></expr></argument>, <argument><expr><name>srcDirs</name></expr></argument>, <argument><expr><name>dirsByBasedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>baseDirs</name>.<name>add</name></name><argument_list>(<argument><expr><name>fromDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{ <comment type="line">// not a fileset or contains non-file resources</comment>

                    <if>if <condition>(<expr>!<call><name><name>rc</name>.<name>isFilesystemOnly</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>supportsNonFileResources</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                                   <argument><expr>"Only FileSystem resources are supported."</expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></then></if>

                    <for>for (<init><decl><type><name>Resource</name></type> <name>r</name> :<range> <expr><name>rc</name></expr></range></decl></init>) <block>{
                        <if>if <condition>(<expr>!<call><name><name>r</name>.<name>isExists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>String</name></type> <name>message</name> =<init> <expr>"Warning: Could not find resource "
                                + <call><name><name>r</name>.<name>toLongString</name></name><argument_list>()</argument_list></call> + " to copy."</expr></init></decl>;</decl_stmt>
                            <if>if <condition>(<expr>!<name>failonerror</name></expr>)</condition><then> <block>{
                                <if>if <condition>(<expr>!<name>quiet</name></expr>)</condition><then> <block>{
                                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                }</block></then></if>
                            }</block></then> <else>else <block>{
                                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</throw>
                            }</block></else></if>
                            <continue>continue;</continue>
                        }</block></then></if>

                        <decl_stmt><decl><type><name>File</name></type> <name>baseDir</name> =<init> <expr><name>NULL_FILE_PLACEHOLDER</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><call><name><name>r</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>FileProvider</name></type> <name>fp</name> =<init> <expr><call><name><name>r</name>.<name>as</name></name><argument_list>(<argument><expr><name><name>FileProvider</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>fp</name> != <name>null</name></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>FileResource</name></type> <name>fr</name> =<init> <expr><call><name><name>ResourceUtils</name>.<name>asFileResource</name></name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name>baseDir</name> = <call><name>getKeyFile</name><argument_list>(<argument><expr><call><name><name>fr</name>.<name>getBaseDir</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr><call><name><name>fr</name>.<name>getBaseDir</name></name><argument_list>()</argument_list></call> == <name>null</name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><name>name</name> = <call><name><name>fr</name>.<name>getFile</name></name><argument_list>()</argument_list></call>.<call><name>getAbsolutePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if>
                        }</block></then></if>

                        <comment type="line">// copying of dirs is trivial and can be done</comment>
                        <comment type="line">// for non-file resources as well as for real</comment>
                        <comment type="line">// files.</comment>
                        <if>if <condition>(<expr><call><name><name>r</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call> || <name>fp</name> != <name>null</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
                                <argument><expr><call><name><name>r</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call> ? <name>dirsByBasedir</name>
                                                : <name>filesByBasedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>baseDirs</name>.<name>add</name></name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then> <else>else <block>{ <comment type="line">// a not-directory file resource</comment>
                            <comment type="line">// needs special treatment</comment>
                            <expr_stmt><expr><call><name><name>nonFileResources</name>.<name>add</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                    }</block></for>
                }</block></else></if>
            }</block></for>

            <expr_stmt><expr><call><name>iterateOverBaseDirs</name><argument_list>(<argument><expr><name>baseDirs</name></expr></argument>, <argument><expr><name>dirsByBasedir</name></expr></argument>, <argument><expr><name>filesByBasedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// do all the copy operations now...</comment>
            <try>try <block>{
                <expr_stmt><expr><call><name>doFileOperations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>BuildException</name></type> <name>e</name></decl></param>) <block>{
                <if>if <condition>(<expr>!<name>failonerror</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<name>quiet</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Warning: " + <call><name>getMessage</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then> <else>else <block>{
                    <throw>throw <expr><name>e</name></expr>;</throw>
                }</block></else></if>
            }</block></catch></try>

            <if>if <condition>(<expr><call><name><name>nonFileResources</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0 || <name>singleResource</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Resource</name><index>[]</index></type> <name>nonFiles</name> =<init>
                    <expr>(<name><name>Resource</name><index>[]</index></name>) <call><name><name>nonFileResources</name>.<name>toArray</name></name><argument_list>(<argument><expr>new <name><name>Resource</name><index>[<expr><call><name><name>nonFileResources</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// restrict to out-of-date resources</comment>
                <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>Resource</name></argument>, <argument><name>String</name><index>[]</index></argument>&gt;</argument_list></name></type> <name>map</name> =<init> <expr><call><name>scan</name><argument_list>(<argument><expr><name>nonFiles</name></expr></argument>, <argument><expr><name>destDir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>singleResource</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><name>singleResource</name></expr></argument>,
                            <argument><expr>new <name><name>String</name><index>[]</index></name> <block>{ <expr><call><name><name>destFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr> }</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <try>try <block>{
                    <expr_stmt><expr><call><name>doResourceOperations</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> <catch>catch (<param><decl><type><name>BuildException</name></type> <name>e</name></decl></param>) <block>{
                    <if>if <condition>(<expr>!<name>failonerror</name></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr>!<name>quiet</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Warning: " + <call><name>getMessage</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then> <else>else <block>{
                        <throw>throw <expr><name>e</name></expr>;</throw>
                    }</block></else></if>
                }</block></catch></try>
            }</block></then></if>
        }</block> <finally>finally <block>{
            <comment type="line">// clean up again, so this instance can be used a second</comment>
            <comment type="line">// time</comment>
            <expr_stmt><expr><name>singleResource</name> = <name>null</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>file</name> = <name>savedFile</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>destFile</name> = <name>savedDestFile</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>destDir</name> = <name>savedDestDir</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>savedRc</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>rcs</name>.<name>insertElementAt</name></name><argument_list>(<argument><expr><name>savedRc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>fileCopyMap</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>dirCopyMap</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>completeDirMap</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/************************************************************************
     **  protected and private methods
     ************************************************************************/</comment>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>copySingleFile</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// deal with the single file</comment>
        <if>if <condition>(<expr><name>file</name> != <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>file</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>destFile</name> == <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>destFile</name> = new <call><name>File</name><argument_list>(<argument><expr><name>destDir</name></expr></argument>, <argument><expr><call><name><name>file</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>forceOverwrite</name> || !<call><name><name>destFile</name>.<name>exists</name></name><argument_list>()</argument_list></call>
                    || (<call><name><name>file</name>.<name>lastModified</name></name><argument_list>()</argument_list></call> - <name>granularity</name>
                        &gt; <call><name><name>destFile</name>.<name>lastModified</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>fileCopyMap</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>file</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><call><name><name>destFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>file</name> + " omitted as " + <name>destFile</name>
                        + " is up to date."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>message</name> =<init> <expr>"Warning: Could not find file "
                    + <call><name><name>file</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call> + " to copy."</expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>failonerror</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<name>quiet</name></expr>)</condition><then> <block>{
                      <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then> <else>else <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></else></if>
            }</block></else></if>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>iterateOverBaseDirs</name><parameter_list>(
        <param><decl><type><name><name>HashSet</name><argument_list>&lt;<argument><name>File</name></argument>&gt;</argument_list></name></type> <name>baseDirs</name></decl></param>, <param><decl><type><name><name>HashMap</name><argument_list>&lt;<argument><name>File</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>dirsByBasedir</name></decl></param>, <param><decl><type><name><name>HashMap</name><argument_list>&lt;<argument><name>File</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>filesByBasedir</name></decl></param>)</parameter_list> <block>{

        <for>for (<init><decl><type><name>File</name></type> <name>f</name> :<range> <expr><name>baseDirs</name></expr></range></decl></init>) <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>files</name> =<init> <expr><call><name><name>filesByBasedir</name>.<name>get</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>dirs</name> =<init> <expr><call><name><name>dirsByBasedir</name>.<name>get</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>srcFiles</name> =<init> <expr>new <name><name>String</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>files</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>srcFiles</name> = <call><name><name>files</name>.<name>toArray</name></name><argument_list>(<argument><expr><name>srcFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>srcDirs</name> =<init> <expr>new <name><name>String</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>dirs</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>srcDirs</name> = <call><name><name>dirs</name>.<name>toArray</name></name><argument_list>(<argument><expr><name>srcDirs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>scan</name><argument_list>(<argument><expr><name>f</name> == <name>NULL_FILE_PLACEHOLDER</name> ? <name>null</name> : <name>f</name></expr></argument>, <argument><expr><name>destDir</name></expr></argument>, <argument><expr><name>srcFiles</name></expr></argument>,
                 <argument><expr><name>srcDirs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Ensure we have a consistent and legal set of attributes, and set
     * any internal flags necessary based on different combinations
     * of attributes.
     * @exception BuildException if an error occurs.
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>validateAttributes</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>file</name> == <name>null</name> &amp;&amp; <call><name><name>rcs</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                <argument><expr>"Specify at least one source--a file or a resource collection."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>destFile</name> != <name>null</name> &amp;&amp; <name>destDir</name> != <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                <argument><expr>"Only one of tofile and todir may be set."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>destFile</name> == <name>null</name> &amp;&amp; <name>destDir</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"One of tofile or todir must be set."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>file</name> != <name>null</name> &amp;&amp; <call><name><name>file</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Use a resource collection to copy directories."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>destFile</name> != <name>null</name> &amp;&amp; <call><name><name>rcs</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>rcs</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                    <argument><expr>"Cannot concatenate multiple files into a single file."</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><name>ResourceCollection</name></type> <name>rc</name> =<init> <expr>(<name>ResourceCollection</name>) <call><name><name>rcs</name>.<name>elementAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name><name>rc</name>.<name>isFilesystemOnly</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>supportsNonFileResources</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Only FileSystem resources are"
                                             + " supported."</expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <if>if <condition>(<expr><call><name><name>rc</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>MSG_WHEN_COPYING_EMPTY_RC_TO_FILE</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>rc</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>Resource</name></type> <name>res</name> =<init> <expr><call><name><name>rc</name>.<name>iterator</name></name><argument_list>()</argument_list></call>.<call><name>next</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>FileProvider</name></type> <name>r</name> =<init> <expr><call><name><name>res</name>.<name>as</name></name><argument_list>(<argument><expr><name><name>FileProvider</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>file</name> == <name>null</name></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><name>r</name> != <name>null</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>file</name> = <call><name><name>r</name>.<name>getFile</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><name>singleResource</name> = <name>res</name></expr>;</expr_stmt>
                        }</block></else></if>
                        <expr_stmt><expr><call><name><name>rcs</name>.<name>removeElementAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                            <argument><expr>"Cannot concatenate multiple files into a single file."</expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></else></if>
                }</block></then> <else>else <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                        <argument><expr>"Cannot concatenate multiple files into a single file."</expr></argument>)</argument_list></call></expr>;</throw>
                }</block></else></if></else></if>
            }</block></else></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>destFile</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>destDir</name> = <call><name><name>destFile</name>.<name>getParentFile</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Compares source files to destination files to see if they should be
     * copied.
     *
     * @param fromDir  The source directory.
     * @param toDir    The destination directory.
     * @param files    A list of files to copy.
     * @param dirs     A list of directories to copy.
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>scan</name><parameter_list>(<param><decl><type><name>File</name></type> <name>fromDir</name></decl></param>, <param><decl><type><name>File</name></type> <name>toDir</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>files</name></decl></param>,
                        <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>dirs</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>FileNameMapper</name></type> <name>mapper</name> =<init> <expr><call><name>getMapper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>buildMap</name><argument_list>(<argument><expr><name>fromDir</name></expr></argument>, <argument><expr><name>toDir</name></expr></argument>, <argument><expr><name>files</name></expr></argument>, <argument><expr><name>mapper</name></expr></argument>, <argument><expr><name>fileCopyMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>includeEmpty</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>buildMap</name><argument_list>(<argument><expr><name>fromDir</name></expr></argument>, <argument><expr><name>toDir</name></expr></argument>, <argument><expr><name>dirs</name></expr></argument>, <argument><expr><name>mapper</name></expr></argument>, <argument><expr><name>dirCopyMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Compares source resources to destination files to see if they
     * should be copied.
     *
     * @param fromResources  The source resources.
     * @param toDir          The destination directory.
     *
     * @return a Map with the out-of-date resources as keys and an
     * array of target file names as values.
     *
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>protected</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>Resource</name></argument>, <argument><name>String</name><index>[]</index></argument>&gt;</argument_list></name></type> <name>scan</name><parameter_list>(<param><decl><type><name><name>Resource</name><index>[]</index></name></type> <name>fromResources</name></decl></param>, <param><decl><type><name>File</name></type> <name>toDir</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>buildMap</name><argument_list>(<argument><expr><name>fromResources</name></expr></argument>, <argument><expr><name>toDir</name></expr></argument>, <argument><expr><call><name>getMapper</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Add to a map of files/directories to copy.
     *
     * @param fromDir the source directory.
     * @param toDir   the destination directory.
     * @param names   a list of filenames.
     * @param mapper  a &lt;code&gt;FileNameMapper&lt;/code&gt; value.
     * @param map     a map of source file to array of destination files.
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>buildMap</name><parameter_list>(<param><decl><type><name>File</name></type> <name>fromDir</name></decl></param>, <param><decl><type><name>File</name></type> <name>toDir</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>names</name></decl></param>,
                            <param><decl><type><name>FileNameMapper</name></type> <name>mapper</name></decl></param>, <param><decl><type><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>String</name><index>[]</index></name></argument>&gt;</argument_list></name></type> <name>map</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>toCopy</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>forceOverwrite</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>Vector</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>v</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>names</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><call><name><name>mapper</name>.<name>mapFileName</name></name><argument_list>(<argument><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>v</name>.<name>addElement</name></name><argument_list>(<argument><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr><name>toCopy</name> = new <name><name>String</name><index>[<expr><call><name><name>v</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>v</name>.<name>copyInto</name></name><argument_list>(<argument><expr><name>toCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>SourceFileScanner</name></type> <name>ds</name> =<init> <expr>new <call><name>SourceFileScanner</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>toCopy</name> = <call><name><name>ds</name>.<name>restrict</name></name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>fromDir</name></expr></argument>, <argument><expr><name>toDir</name></expr></argument>, <argument><expr><name>mapper</name></expr></argument>, <argument><expr><name>granularity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>toCopy</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>File</name></type> <name>src</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>fromDir</name></expr></argument>, <argument><expr><name><name>toCopy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>mappedFiles</name> =<init> <expr><call><name><name>mapper</name>.<name>mapFileName</name></name><argument_list>(<argument><expr><name><name>toCopy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<name>enableMultipleMappings</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>src</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr>new <name><name>String</name><index>[]</index></name> <block>{<expr>new <call><name>File</name><argument_list>(<argument><expr><name>toDir</name></expr></argument>, <argument><expr><name><name>mappedFiles</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>.<call><name>getAbsolutePath</name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <comment type="line">// reuse the array created by the mapper</comment>
                <for>for (<init><decl><type><name>int</name></type> <name>k</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name><name>mappedFiles</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name><name>mappedFiles</name><index>[<expr><name>k</name></expr>]</index></name> = new <call><name>File</name><argument_list>(<argument><expr><name>toDir</name></expr></argument>, <argument><expr><name><name>mappedFiles</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call>.<call><name>getAbsolutePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>src</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mappedFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Create a map of resources to copy.
     *
     * @param fromResources  The source resources.
     * @param toDir   the destination directory.
     * @param mapper  a &lt;code&gt;FileNameMapper&lt;/code&gt; value.
     * @return a map of source resource to array of destination files.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>protected</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>Resource</name></argument>, <argument><name>String</name><index>[]</index></argument>&gt;</argument_list></name></type> <name>buildMap</name><parameter_list>(<param><decl><type><name><name>Resource</name><index>[]</index></name></type> <name>fromResources</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>File</name></type> <name>toDir</name></decl></param>,
                           <param><decl><type><name>FileNameMapper</name></type> <name>mapper</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>HashMap</name><argument_list>&lt;<argument><name>Resource</name></argument>, <argument><name>String</name><index>[]</index></argument>&gt;</argument_list></name></type> <name>map</name> =<init> <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>Resource</name></argument>, <argument><name><name>String</name><index>[]</index></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Resource</name><index>[]</index></type> <name>toCopy</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>forceOverwrite</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>Vector</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>v</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>fromResources</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><call><name><name>mapper</name>.<name>mapFileName</name></name><argument_list>(<argument><expr><name><name>fromResources</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>v</name>.<name>addElement</name></name><argument_list>(<argument><expr><name><name>fromResources</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr><name>toCopy</name> = new <name><name>Resource</name><index>[<expr><call><name><name>v</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>v</name>.<name>copyInto</name></name><argument_list>(<argument><expr><name>toCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>toCopy</name> =
                <call><name><name>ResourceUtils</name>.<name>selectOutOfDateSources</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>fromResources</name></expr></argument>,
                                                     <argument><expr><name>mapper</name></expr></argument>,
                                                     <argument><expr>new <class><super><name>ResourceFactory</name></super><argument_list>()</argument_list> <block>{
                           <function><type><specifier>public</specifier> <name>Resource</name></type> <name>getResource</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
                               <return>return <expr>new <call><name>FileResource</name><argument_list>(<argument><expr><name>toDir</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
                           }</block></function>
                                                     }</block></class></expr></argument>,
                                                     <argument><expr><name>granularity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>toCopy</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>mappedFiles</name> =<init> <expr><call><name><name>mapper</name>.<name>mapFileName</name></name><argument_list>(<argument><expr><name><name>toCopy</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name><name>mappedFiles</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>mappedFiles</name><index>[<expr><name>j</name></expr>]</index></name> == <name>null</name></expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Can't copy a resource without a"
                                             + " name if the mapper doesn't"
                                             + " provide one."</expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
            }</block></for>

            <if>if <condition>(<expr>!<name>enableMultipleMappings</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>toCopy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                        <argument><expr>new <name><name>String</name><index>[]</index></name> <block>{<expr>new <call><name>File</name><argument_list>(<argument><expr><name>toDir</name></expr></argument>, <argument><expr><name><name>mappedFiles</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>.<call><name>getAbsolutePath</name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <comment type="line">// reuse the array created by the mapper</comment>
                <for>for (<init><decl><type><name>int</name></type> <name>k</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name><name>mappedFiles</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name><name>mappedFiles</name><index>[<expr><name>k</name></expr>]</index></name> = new <call><name>File</name><argument_list>(<argument><expr><name>toDir</name></expr></argument>, <argument><expr><name><name>mappedFiles</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call>.<call><name>getAbsolutePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>toCopy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>mappedFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Actually does the file (and possibly empty directory) copies.
     * This is a good method for subclasses to override.
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>doFileOperations</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>fileCopyMap</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Copying " + <call><name><name>fileCopyMap</name>.<name>size</name></name><argument_list>()</argument_list></call>
                + " file" + (<call><name><name>fileCopyMap</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1 ? "" : "s")
                + " to " + <call><name><name>destDir</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name><index>[]</index></argument>&gt;</argument_list></name></name></type> <name>e</name> :<range> <expr><call><name><name>fileCopyMap</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>fromFile</name> =<init> <expr><call><name><name>e</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>toFiles</name> =<init> <expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>toFiles</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>toFile</name> =<init> <expr><name><name>toFiles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><call><name><name>fromFile</name>.<name>equals</name></name><argument_list>(<argument><expr><name>toFile</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Skipping self-copy of " + <name>fromFile</name></expr></argument>, <argument><expr><name>verbosity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>
                    <try>try <block>{
                        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Copying " + <name>fromFile</name> + " to " + <name>toFile</name></expr></argument>, <argument><expr><name>verbosity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <decl_stmt><decl><type><name>FilterSetCollection</name></type> <name>executionFilters</name> =<init>
                            <expr>new <call><name>FilterSetCollection</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>filtering</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>executionFilters</name>
                                .<name>addFilterSet</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getGlobalFilterSet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                        <for>for (<init><decl><type><name>FilterSet</name></type> <name>filterSet</name> :<range> <expr><name>filterSets</name></expr></range></decl></init>) <block>{
                            <expr_stmt><expr><call><name><name>executionFilters</name>.<name>addFilterSet</name></name><argument_list>(<argument><expr><name>filterSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></for>
                        <expr_stmt><expr><call><name><name>fileUtils</name>.<name>copyFile</name></name><argument_list>(<argument><expr>new <call><name>File</name><argument_list>(<argument><expr><name>fromFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>File</name><argument_list>(<argument><expr><name>toFile</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>executionFilters</name></expr></argument>,
                                           <argument><expr><name>filterChains</name></expr></argument>, <argument><expr><name>forceOverwrite</name></expr></argument>,
                                           <argument><expr><name>preserveLastModified</name></expr></argument>,
                                           <comment type="block">/* append: */</comment> <argument><expr>false</expr></argument>, <argument><expr><name>inputEncoding</name></expr></argument>,
                                           <argument><expr><name>outputEncoding</name></expr></argument>, <argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>getForce</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ioe</name></decl></param>) <block>{
                        <decl_stmt><decl><type><name>String</name></type> <name>msg</name> =<init> <expr>"Failed to copy " + <name>fromFile</name> + " to " + <name>toFile</name>
                            + " due to " + <call><name>getDueTo</name><argument_list>(<argument><expr><name>ioe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>File</name></type> <name>targetFile</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>toFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name><name>targetFile</name>.<name>exists</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>targetFile</name>.<name>delete</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>msg</name> += " and I couldn't delete the corrupt " + <name>toFile</name></expr>;</expr_stmt>
                        }</block></then></if>
                        <if>if <condition>(<expr><name>failonerror</name></expr>)</condition><then> <block>{
                            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ioe</name></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                        }</block></then></if>
                        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></catch></try>
                }</block></for>
            }</block></for>
        }</block></then></if>
        <if>if <condition>(<expr><name>includeEmpty</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>createCount</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>String</name><index>[]</index></type> <name>dirs</name> :<range> <expr><call><name><name>dirCopyMap</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>dirs</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>File</name></type> <name>d</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<call><name><name>d</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr>!<call><name><name>d</name>.<name>mkdirs</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Unable to create directory "
                                + <call><name><name>d</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><name>createCount</name>++</expr>;</expr_stmt>
                        }</block></else></if>
                    }</block></then></if>
                }</block></for>
            }</block></for>
            <if>if <condition>(<expr><name>createCount</name> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Copied " + <call><name><name>dirCopyMap</name>.<name>size</name></name><argument_list>()</argument_list></call>
                    + " empty director"
                    + (<call><name><name>dirCopyMap</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1 ? "y" : "ies")
                    + " to " + <name>createCount</name>
                    + " empty director"
                    + (<name>createCount</name> == 1 ? "y" : "ies") + " under "
                    + <call><name><name>destDir</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Actually does the resource copies.
     * This is a good method for subclasses to override.
     * @param map a map of source resource to array of destination files.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>doResourceOperations</name><parameter_list>(<param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>Resource</name></argument>, <argument><name><name>String</name><index>[]</index></name></argument>&gt;</argument_list></name></type> <name>map</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>map</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Copying " + <call><name><name>map</name>.<name>size</name></name><argument_list>()</argument_list></call>
                + " resource" + (<call><name><name>map</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1 ? "" : "s")
                + " to " + <call><name><name>destDir</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Resource</name></argument>, <argument><name>String</name><index>[]</index></argument>&gt;</argument_list></name></name></type> <name>e</name> :<range> <expr><call><name><name>map</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                <decl_stmt><decl><type><name>Resource</name></type> <name>fromResource</name> =<init> <expr><call><name><name>e</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>String</name></type> <name>toFile</name> :<range> <expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                    <try>try <block>{
                        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Copying " + <name>fromResource</name> + " to " + <name>toFile</name></expr></argument>,
                            <argument><expr><name>verbosity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <decl_stmt><decl><type><name>FilterSetCollection</name></type> <name>executionFilters</name> =<init> <expr>new <call><name>FilterSetCollection</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>filtering</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>executionFilters</name>
                                .<name>addFilterSet</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getGlobalFilterSet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                        <for>for (<init><decl><type><name>FilterSet</name></type> <name>filterSet</name> :<range> <expr><name>filterSets</name></expr></range></decl></init>) <block>{
                            <expr_stmt><expr><call><name><name>executionFilters</name>.<name>addFilterSet</name></name><argument_list>(<argument><expr><name>filterSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></for>
                        <expr_stmt><expr><call><name><name>ResourceUtils</name>.<name>copyResource</name></name><argument_list>(<argument><expr><name>fromResource</name></expr></argument>,
                                                   <argument><expr>new <call><name>FileResource</name><argument_list>(<argument><expr><name>destDir</name></expr></argument>,
                                                                    <argument><expr><name>toFile</name></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr><name>executionFilters</name></expr></argument>,
                                                   <argument><expr><name>filterChains</name></expr></argument>,
                                                   <argument><expr><name>forceOverwrite</name></expr></argument>,
                                                   <argument><expr><name>preserveLastModified</name></expr></argument>,
                                                   <comment type="block">/* append: */</comment> <argument><expr>false</expr></argument>,
                                                   <argument><expr><name>inputEncoding</name></expr></argument>,
                                                   <argument><expr><name>outputEncoding</name></expr></argument>,
                                                   <argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>,
                                                   <argument><expr><call><name>getForce</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ioe</name></decl></param>) <block>{
                        <decl_stmt><decl><type><name>String</name></type> <name>msg</name> =<init> <expr>"Failed to copy " + <name>fromResource</name>
                            + " to " + <name>toFile</name>
                            + " due to " + <call><name>getDueTo</name><argument_list>(<argument><expr><name>ioe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>File</name></type> <name>targetFile</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>toFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name><name>targetFile</name>.<name>exists</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>targetFile</name>.<name>delete</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>msg</name> += " and I couldn't delete the corrupt " + <name>toFile</name></expr>;</expr_stmt>
                        }</block></then></if>
                        <if>if <condition>(<expr><name>failonerror</name></expr>)</condition><then> <block>{
                            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ioe</name></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                        }</block></then></if>
                        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></catch></try>
                }</block></for>
            }</block></for>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Whether this task can deal with non-file resources.
     *
     * &lt;p&gt;&amp;lt;copy&amp;gt; can while &amp;lt;move&amp;gt; can't since we don't
     * know how to remove non-file resources.&lt;/p&gt;
     *
     * &lt;p&gt;This implementation returns true only if this task is
     * &amp;lt;copy&amp;gt;.  Any subclass of this class that also wants to
     * support non-file resources needs to override this method.  We
     * need to do so for backwards compatibility reasons since we
     * can't expect subclasses to support resources.&lt;/p&gt;
     * @return true if this task supports non file resources.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>protected</specifier> <name>boolean</name></type> <name>supportsNonFileResources</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>getClass</name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name><name>Copy</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Adds the given strings to a list contained in the given map.
     * The file is the key into the map.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>File</name></type> <name>baseDir</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>names</name></decl></param>, <param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>File</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>names</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>baseDir</name> = <call><name>getKeyFile</name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>l</name> =<init> <expr><call><name><name>m</name>.<name>get</name></name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>l</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>l</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>names</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>m</name>.<name>put</name></name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>l</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>java</name>.<name>util</name>.<name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Adds the given string to a list contained in the given map.
     * The file is the key into the map.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>File</name></type> <name>baseDir</name></decl></param>, <param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>File</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>m</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>name</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>, <argument><expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><name>name</name></expr>}</block></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Either returns its argument or a plaeholder if the argument is null.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>File</name></type> <name>getKeyFile</name><parameter_list>(<param><decl><type><name>File</name></type> <name>f</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>f</name> == <name>null</name> ? <name>NULL_FILE_PLACEHOLDER</name> : <name>f</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * returns the mapper to use based on nested elements or the
     * flatten attribute.
     */</comment>
    <function><type><specifier>private</specifier> <name>FileNameMapper</name></type> <name>getMapper</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>FileNameMapper</name></type> <name>mapper</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>mapperElement</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mapper</name> = <call><name><name>mapperElement</name>.<name>getImplementation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>flatten</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mapper</name> = new <call><name>FlatFileNameMapper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>mapper</name> = new <call><name>IdentityMapper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <return>return <expr><name>mapper</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Handle getMessage() for exceptions.
     * @param ex the exception to handle
     * @return ex.getMessage() if ex.getMessage() is not null
     *         otherwise return ex.toString()
     */</comment>
    <function><type><specifier>private</specifier> <name>String</name></type> <name>getMessage</name><parameter_list>(<param><decl><type><name>Exception</name></type> <name>ex</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>ex</name>.<name>getMessage</name></name><argument_list>()</argument_list></call> == <name>null</name> ? <call><name><name>ex</name>.<name>toString</name></name><argument_list>()</argument_list></call> : <call><name><name>ex</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns a reason for failure based on
     * the exception thrown.
     * If the exception is not IOException output the class name,
     * output the message
     * if the exception is MalformedInput add a little note.
     */</comment>
    <function><type><specifier>private</specifier> <name>String</name></type> <name>getDueTo</name><parameter_list>(<param><decl><type><name>Exception</name></type> <name>ex</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>baseIOException</name> =<init> <expr><call><name><name>ex</name>.<name>getClass</name></name><argument_list>()</argument_list></call> == <name><name>IOException</name>.<name><name/></name></name>class</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>message</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>baseIOException</name> || <call><name><name>ex</name>.<name>getMessage</name></name><argument_list>()</argument_list></call> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>message</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>ex</name>.<name>getClass</name></name><argument_list>()</argument_list></call>.<call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>ex</name>.<name>getMessage</name></name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name>baseIOException</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>message</name>.<name>append</name></name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>message</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>ex</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>ex</name>.<name>getClass</name></name><argument_list>()</argument_list></call>.<call><name>getName</name><argument_list>()</argument_list></call>.<call><name>indexOf</name><argument_list>(<argument><expr>"MalformedInput"</expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>message</name>.<name>append</name></name><argument_list>(<argument><expr><name>LINE_SEPARATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>message</name>.<name>append</name></name><argument_list>(
                <argument><expr>"This is normally due to the input file containing invalid"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name><name>message</name>.<name>append</name></name><argument_list>(<argument><expr><name>LINE_SEPARATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>message</name>.<name>append</name></name><argument_list>(<argument><expr>"bytes for the character encoding used : "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>message</name>.<name>append</name></name><argument_list>(
                <argument><expr>(<name>inputEncoding</name> == <name>null</name>
                 ? <call><name><name>fileUtils</name>.<name>getDefaultEncoding</name></name><argument_list>()</argument_list></call> : <name>inputEncoding</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>message</name>.<name>append</name></name><argument_list>(<argument><expr><name>LINE_SEPARATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><call><name><name>message</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>
}</block></class>
</unit>
