<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\taskdefs\optional\Native2Ascii.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>optional</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>DirectoryScanner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>MatchingTask</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>optional</name>.<name>native2ascii</name>.<name>Native2AsciiAdapter</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>optional</name>.<name>native2ascii</name>.<name>Native2AsciiAdapterFactory</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Mapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Path</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileNameMapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>IdentityMapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>SourceFileScanner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>facade</name>.<name>FacadeTaskHelper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>facade</name>.<name>ImplementationSpecificArgument</name></name>;</import>

<comment type="javadoc">/**
 * Converts files from native encodings to ASCII.
 *
 * @since Ant 1.2
 */</comment>
<class><specifier>public</specifier> class <name>Native2Ascii</name> <super><extends>extends <name>MatchingTask</name></extends></super> <block>{

    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>reverse</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>  <comment type="line">// convert from ascii back to native</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>encoding</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>   <comment type="line">// encoding to convert to/from</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>srcDir</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>       <comment type="line">// Where to find input files</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>destDir</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>      <comment type="line">// Where to put output files</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>extension</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>  <comment type="line">// Extension of output files if different</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <name>Mapper</name></type> <name>mapper</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>FacadeTaskHelper</name></type> <name>facade</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Native2AsciiAdapter</name></type> <name>nestedAdapter</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** No args constructor */</comment>
    <constructor><specifier>public</specifier> <name>Native2Ascii</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>facade</name> = new <call><name>FacadeTaskHelper</name><argument_list>(<argument><expr><call><name><name>Native2AsciiAdapterFactory</name>.<name>getDefault</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Flag the conversion to run in the reverse sense,
     * that is Ascii to Native encoding.
     *
     * @param reverse True if the conversion is to be reversed,
     *                otherwise false;
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setReverse</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>reverse</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>reverse</name></name> = <name>reverse</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * The value of the reverse attribute.
     * @return the reverse attribute.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getReverse</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>reverse</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set the encoding to translate to/from.
     * If unset, the default encoding for the JVM is used.
     *
     * @param encoding String containing the name of the Native
     *                 encoding to convert from or to.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setEncoding</name><parameter_list>(<param><decl><type><name>String</name></type> <name>encoding</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>encoding</name></name> = <name>encoding</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * The value of the encoding attribute.
     * @return the encoding attribute.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getEncoding</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>encoding</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set the source directory in which to find files to convert.
     *
     * @param srcDir directory to find input file in.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setSrc</name><parameter_list>(<param><decl><type><name>File</name></type> <name>srcDir</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>srcDir</name></name> = <name>srcDir</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Set the destination directory to place converted files into.
     *
     * @param destDir directory to place output file into.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDest</name><parameter_list>(<param><decl><type><name>File</name></type> <name>destDir</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>destDir</name></name> = <name>destDir</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the extension which converted files should have.
     * If unset, files will not be renamed.
     *
     * @param ext File extension to use for converted files.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setExt</name><parameter_list>(<param><decl><type><name>String</name></type> <name>ext</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>extension</name></name> = <name>ext</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Choose the implementation for this particular task.
     * @param impl the name of the implementation
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setImplementation</name><parameter_list>(<param><decl><type><name>String</name></type> <name>impl</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr>"default".<call><name>equals</name><argument_list>(<argument><expr><name>impl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>facade</name>.<name>setImplementation</name></name><argument_list>(<argument><expr><call><name><name>Native2AsciiAdapterFactory</name>.<name>getDefault</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>facade</name>.<name>setImplementation</name></name><argument_list>(<argument><expr><name>impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Defines the FileNameMapper to use (nested mapper element).
     *
     * @return the mapper to use for file name translations.
     *
     * @throws BuildException if more than one mapper is defined.
     */</comment>
    <function><type><specifier>public</specifier> <name>Mapper</name></type> <name>createMapper</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>mapper</name> != <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Cannot define more than one mapper"</expr></argument>,
                                     <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>mapper</name> = new <call><name>Mapper</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>mapper</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * A nested filenamemapper
     * @param fileNameMapper the mapper to add
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>FileNameMapper</name></type> <name>fileNameMapper</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>createMapper</name><argument_list>()</argument_list></call>.<call><name>add</name><argument_list>(<argument><expr><name>fileNameMapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds an implementation specific command-line argument.
     * @return a ImplementationSpecificArgument to be configured
     *
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>ImplementationSpecificArgument</name></type> <name>createArg</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>ImplementationSpecificArgument</name></type> <name>arg</name> =<init>
            <expr>new <call><name>ImplementationSpecificArgument</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>facade</name>.<name>addImplementationArgument</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>arg</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * The classpath to use when loading the native2ascii
     * implementation if it is not a built-in one.
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>Path</name></type> <name>createImplementationClasspath</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>facade</name>.<name>getImplementationClasspath</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set the adapter explicitly.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>Native2AsciiAdapter</name></type> <name>adapter</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>nestedAdapter</name> != <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Can't have more than one native2ascii"
                                     + " adapter"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>nestedAdapter</name> = <name>adapter</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Execute the task
     *
     * @throws BuildException is there is a problem in the task execution.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{

        <decl_stmt><decl><type><name>DirectoryScanner</name></type> <name>scanner</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt> <comment type="line">// Scanner to find our inputs</comment>
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>files</name></decl>;</decl_stmt>                  <comment type="line">// list of files to process</comment>

        <comment type="line">// default srcDir to basedir</comment>
        <if>if <condition>(<expr><name>srcDir</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>srcDir</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>resolveFile</name><argument_list>(<argument><expr>"."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// Require destDir</comment>
        <if>if <condition>(<expr><name>destDir</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"The dest attribute must be set."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="line">// if src and dest dirs are the same, require the extension</comment>
        <comment type="line">// to be set, so we don't stomp every file.  One could still</comment>
        <comment type="line">// include a file with the same extension, but ....</comment>
        <if>if <condition>(<expr><call><name><name>srcDir</name>.<name>equals</name></name><argument_list>(<argument><expr><name>destDir</name></expr></argument>)</argument_list></call> &amp;&amp; <name>extension</name> == <name>null</name> &amp;&amp; <name>mapper</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"The ext attribute or a mapper must be set if"
                                     + " src and dest dirs are the same."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <decl_stmt><decl><type><name>FileNameMapper</name></type> <name>m</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>mapper</name> == <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>extension</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>m</name> = new <call><name>IdentityMapper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>m</name> = new <call><name>ExtMapper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>m</name> = <call><name><name>mapper</name>.<name>getImplementation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><name>scanner</name> = <call><name>getDirectoryScanner</name><argument_list>(<argument><expr><name>srcDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>files</name> = <call><name><name>scanner</name>.<name>getIncludedFiles</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>SourceFileScanner</name></type> <name>sfs</name> =<init> <expr>new <call><name>SourceFileScanner</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>files</name> = <call><name><name>sfs</name>.<name>restrict</name></name><argument_list>(<argument><expr><name>files</name></expr></argument>, <argument><expr><name>srcDir</name></expr></argument>, <argument><expr><name>destDir</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> =<init> <expr><name><name>files</name>.<name>length</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>String</name></type> <name>message</name> =<init> <expr>"Converting " + <name>count</name> + " file"
            + (<name>count</name> != 1 ? "s" : "") + " from "</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>message</name> + <name>srcDir</name> + " to " + <name>destDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>files</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>m</name>.<name>mapFileName</name></name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Convert a single file.
     *
     * @param srcName name of the input file.
     * @param destName name of the input file.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>convert</name><parameter_list>(<param><decl><type><name>String</name></type> <name>srcName</name></decl></param>, <param><decl><type><name>String</name></type> <name>destName</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>File</name></type> <name>srcFile</name></decl>;</decl_stmt>                         <comment type="line">// File to convert</comment>
        <decl_stmt><decl><type><name>File</name></type> <name>destFile</name></decl>;</decl_stmt>                        <comment type="line">// where to put the results</comment>

        <comment type="line">// Build the full file names</comment>
        <expr_stmt><expr><name>srcFile</name> = new <call><name>File</name><argument_list>(<argument><expr><name>srcDir</name></expr></argument>, <argument><expr><name>srcName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>destFile</name> = new <call><name>File</name><argument_list>(<argument><expr><name>destDir</name></expr></argument>, <argument><expr><name>destName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Make sure we're not about to clobber something</comment>
        <if>if <condition>(<expr><call><name><name>srcFile</name>.<name>equals</name></name><argument_list>(<argument><expr><name>destFile</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"file " + <name>srcFile</name>
                                     + " would overwrite its self"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="line">// Make intermediate directories if needed</comment>
        <comment type="line">// TODO JDK 1.1 doesn't have File.getParentFile,</comment>
        <decl_stmt><decl><type><name>String</name></type> <name>parentName</name> =<init> <expr><call><name><name>destFile</name>.<name>getParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>parentName</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>File</name></type> <name>parentFile</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>parentName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr>(!<call><name><name>parentFile</name>.<name>exists</name></name><argument_list>()</argument_list></call>) &amp;&amp; (!<call><name><name>parentFile</name>.<name>mkdirs</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"cannot create parent directory "
                                         + <name>parentName</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"converting " + <name>srcName</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Native2AsciiAdapter</name></type> <name>ad</name> =<init>
            <expr><name>nestedAdapter</name> != <name>null</name> ? <name>nestedAdapter</name> :
            <call><name><name>Native2AsciiAdapterFactory</name>.<name>getAdapter</name></name><argument_list>(<argument><expr><call><name><name>facade</name>.<name>getImplementation</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                  <argument><expr><name>this</name></expr></argument>,
                                                  <argument><expr><call><name>createImplementationClasspath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>ad</name>.<name>convert</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>srcFile</name></expr></argument>, <argument><expr><name>destFile</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"conversion failed"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the (implementation specific) settings given as nested
     * arg elements.
     * @return the arguments.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getCurrentArgs</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>facade</name>.<name>getArgs</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <class><specifier>private</specifier> class <name>ExtMapper</name> <super><implements>implements <name>FileNameMapper</name></implements></super> <block>{

        <function><type><specifier>public</specifier> <name>void</name></type> <name>setFrom</name><parameter_list>(<param><decl><type><name>String</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
        }</block></function>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setTo</name><parameter_list>(<param><decl><type><name>String</name></type> <name>s</name></decl></param>)</parameter_list> <block>{
        }</block></function>

        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>mapFileName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>fileName</name></decl></param>)</parameter_list> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>lastDot</name> =<init> <expr><call><name><name>fileName</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>lastDot</name> &gt;= 0</expr>)</condition><then> <block>{
                <return>return <expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><call><name><name>fileName</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>lastDot</name></expr></argument>)</argument_list></call>
                                         + <name>extension</name></expr>}</block></expr>;</return>
            }</block></then> <else>else <block>{
                <return>return <expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><name>fileName</name> + <name>extension</name></expr>}</block></expr>;</return>
            }</block></else></if>
        }</block></function>
    }</block></class>
}</block></class>
</unit>
