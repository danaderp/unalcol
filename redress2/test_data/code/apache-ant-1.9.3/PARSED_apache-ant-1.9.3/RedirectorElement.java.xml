<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\types\RedirectorElement.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Arrays</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Stack</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>Redirector</name></name>;</import>

<comment type="javadoc">/**
 * Element representation of a &lt;code&gt;Redirector&lt;/code&gt;.
 * @since Ant 1.6.2
 */</comment>
<class><specifier>public</specifier> class <name>RedirectorElement</name> <super><extends>extends <name>DataType</name></extends></super> <block>{

    <comment type="javadoc">/**
     * Whether the input mapper was set via &lt;code&gt;setOutput&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>usingInput</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether the output mapper was set via &lt;code&gt;setOutput&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>usingOutput</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether the error mapper was set via &lt;code&gt;setError&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>usingError</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Indicates if standard error should be logged to Ant's log system
     * rather than the output. This has no effect if standard error is
     * redirected to a file or property.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Boolean</name></type> <name>logError</name></decl>;</decl_stmt>

    <comment type="javadoc">/** The name of the property into which output is to be stored */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>outputProperty</name></decl>;</decl_stmt>

    <comment type="javadoc">/** The name of the property into which error output is to be stored */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>errorProperty</name></decl>;</decl_stmt>

    <comment type="javadoc">/** String from which input is taken */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>inputString</name></decl>;</decl_stmt>

    <comment type="javadoc">/** Flag which indicates if error and output files are to be appended. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Boolean</name></type> <name>append</name></decl>;</decl_stmt>

    <comment type="javadoc">/** Flag which indicates that output should be always sent to the log */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Boolean</name></type> <name>alwaysLog</name></decl>;</decl_stmt>

    <comment type="javadoc">/** Flag which indicates whether files should be created even if empty. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Boolean</name></type> <name>createEmptyFiles</name></decl>;</decl_stmt>

    <comment type="javadoc">/** Input file mapper. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Mapper</name></type> <name>inputMapper</name></decl>;</decl_stmt>

    <comment type="javadoc">/** Output file mapper. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Mapper</name></type> <name>outputMapper</name></decl>;</decl_stmt>

    <comment type="javadoc">/** Error file mapper. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Mapper</name></type> <name>errorMapper</name></decl>;</decl_stmt>

    <comment type="javadoc">/** input filter chains. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name></type> <name>inputFilterChains</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** output filter chains. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name></type> <name>outputFilterChains</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** error filter chains. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name></type> <name>errorFilterChains</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** The output encoding */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>outputEncoding</name></decl>;</decl_stmt>

    <comment type="javadoc">/** The error encoding */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>errorEncoding</name></decl>;</decl_stmt>

    <comment type="javadoc">/** The input encoding */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>inputEncoding</name></decl>;</decl_stmt>

    <comment type="javadoc">/** whether to log the inputstring */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Boolean</name></type> <name>logInputString</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Add the input file mapper.
     * @param inputMapper   &lt;code&gt;Mapper&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addConfiguredInputMapper</name><parameter_list>(<param><decl><type><name>Mapper</name></type> <name>inputMapper</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>noChildrenAllowed</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>this</name>.<name>inputMapper</name></name> != <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>usingInput</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"attribute \"input\""
                    + " cannot coexist with a nested &lt;inputmapper&gt;"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then> <else>else <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Cannot have &gt; 1 &lt;inputmapper&gt;"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></else></if>
        }</block></then></if>
        <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>inputMapper</name></name> = <name>inputMapper</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add the output file mapper.
     * @param outputMapper   &lt;code&gt;Mapper&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addConfiguredOutputMapper</name><parameter_list>(<param><decl><type><name>Mapper</name></type> <name>outputMapper</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>noChildrenAllowed</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>this</name>.<name>outputMapper</name></name> != <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>usingOutput</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"attribute \"output\""
                    + " cannot coexist with a nested &lt;outputmapper&gt;"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then> <else>else <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Cannot have &gt; 1 &lt;outputmapper&gt;"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></else></if>
        }</block></then></if>
        <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>outputMapper</name></name> = <name>outputMapper</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add the error file mapper.
     * @param errorMapper   &lt;code&gt;Mapper&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addConfiguredErrorMapper</name><parameter_list>(<param><decl><type><name>Mapper</name></type> <name>errorMapper</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>noChildrenAllowed</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>this</name>.<name>errorMapper</name></name> != <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>usingError</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"attribute \"error\""
                    + " cannot coexist with a nested &lt;errormapper&gt;"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then> <else>else <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Cannot have &gt; 1 &lt;errormapper&gt;"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></else></if>
        }</block></then></if>
        <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>errorMapper</name></name> = <name>errorMapper</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Make this instance in effect a reference to another instance.
     *
     * &lt;p&gt;You must not set another attribute or nest elements inside
     * this element if you make it a reference.&lt;/p&gt;
     * @param r the reference to use.
     * @throws BuildException on error.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setRefid</name><parameter_list>(<param><decl><type><name>Reference</name></type> <name>r</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>usingInput</name>
            || <name>usingOutput</name>
            || <name>usingError</name>
            || <name>inputString</name> != <name>null</name>
            || <name>logError</name> != <name>null</name>
            || <name>append</name> != <name>null</name>
            || <name>createEmptyFiles</name> != <name>null</name>
            || <name>inputEncoding</name> != <name>null</name>
            || <name>outputEncoding</name> != <name>null</name>
            || <name>errorEncoding</name> != <name>null</name>
            || <name>outputProperty</name> != <name>null</name>
            || <name>errorProperty</name> != <name>null</name>
            || <name>logInputString</name> != <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>super</name>.<name>setRefid</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the input to use for the task.
     * @param input the file from which input is read.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setInput</name><parameter_list>(<param><decl><type><name>File</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>inputString</name> != <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"The \"input\" and \"inputstring\" "
                + "attributes cannot both be specified"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>usingInput</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>inputMapper</name> = <call><name>createMergeMapper</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the string to use as input
     * @param inputString the string which is used as the input source
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setInputString</name><parameter_list>(<param><decl><type><name>String</name></type> <name>inputString</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>usingInput</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"The \"input\" and \"inputstring\" "
                + "attributes cannot both be specified"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>inputString</name></name> = <name>inputString</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set whether to include the value of the input string in log messages.
     * Defaults to true.
     * @param logInputString true or false.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setLogInputString</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>logInputString</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>logInputString</name></name> = <name>logInputString</name> ? <name><name>Boolean</name>.<name>TRUE</name></name> : <name><name>Boolean</name>.<name>FALSE</name></name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * File the output of the process is redirected to. If error is not
     * redirected, it too will appear in the output.
     *
     * @param out the file to which output stream is written.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setOutput</name><parameter_list>(<param><decl><type><name>File</name></type> <name>out</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>out</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"output file specified as null"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>usingOutput</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>outputMapper</name> = <call><name>createMergeMapper</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the output encoding.
     * @param outputEncoding   &lt;code&gt;String&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setOutputEncoding</name><parameter_list>(<param><decl><type><name>String</name></type> <name>outputEncoding</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>outputEncoding</name></name> = <name>outputEncoding</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the error encoding.
     *
     * @param errorEncoding   &lt;code&gt;String&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setErrorEncoding</name><parameter_list>(<param><decl><type><name>String</name></type> <name>errorEncoding</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>errorEncoding</name></name> = <name>errorEncoding</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the input encoding.
     * @param inputEncoding   &lt;code&gt;String&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setInputEncoding</name><parameter_list>(<param><decl><type><name>String</name></type> <name>inputEncoding</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>inputEncoding</name></name> = <name>inputEncoding</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Controls whether error output of exec is logged. This is only useful
     * when output is being redirected and error output is desired in the
     * Ant log.
     * @param logError if true the standard error is sent to the Ant log system
     *        and not sent to output.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setLogError</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>logError</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>logError</name></name> = ((<name>logError</name>) ? <name><name>Boolean</name>.<name>TRUE</name></name> : <name><name>Boolean</name>.<name>FALSE</name></name>)</expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the file to which standard error is to be redirected.
     * @param error the file to which error is to be written.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setError</name><parameter_list>(<param><decl><type><name>File</name></type> <name>error</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>error</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"error file specified as null"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>usingError</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>errorMapper</name> = <call><name>createMergeMapper</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Property name whose value should be set to the output of
     * the process.
     * @param outputProperty the name of the property to be set with the
     *        task's output.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setOutputProperty</name><parameter_list>(<param><decl><type><name>String</name></type> <name>outputProperty</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>outputProperty</name></name> = <name>outputProperty</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether output should be appended to or overwrite an existing file.
     * Defaults to false.
     * @param append if true output and error streams are appended to their
     *        respective files, if specified.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setAppend</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>append</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>append</name></name> = ((<name>append</name>) ? <name><name>Boolean</name>.<name>TRUE</name></name> : <name><name>Boolean</name>.<name>FALSE</name></name>)</expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * If true, (error and non-error) output will be "teed", redirected
     * as specified while being sent to Ant's logging mechanism as if no
     * redirection had taken place.  Defaults to false.
     * @param alwaysLog &lt;code&gt;boolean&lt;/code&gt;
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setAlwaysLog</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>alwaysLog</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>alwaysLog</name></name> = ((<name>alwaysLog</name>) ? <name><name>Boolean</name>.<name>TRUE</name></name> : <name><name>Boolean</name>.<name>FALSE</name></name>)</expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether output and error files should be created even when empty.
     * Defaults to true.
     * @param createEmptyFiles &lt;code&gt;boolean&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCreateEmptyFiles</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>createEmptyFiles</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>createEmptyFiles</name></name> = ((<name>createEmptyFiles</name>)
            ? <name><name>Boolean</name>.<name>TRUE</name></name> : <name><name>Boolean</name>.<name>FALSE</name></name>)</expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Property name whose value should be set to the error of
     * the process.
     * @param errorProperty the name of the property to be set
     *        with the error output.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setErrorProperty</name><parameter_list>(<param><decl><type><name>String</name></type> <name>errorProperty</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>errorProperty</name></name> = <name>errorProperty</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Create a nested input &lt;code&gt;FilterChain&lt;/code&gt;.
     * @return &lt;code&gt;FilterChain&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>FilterChain</name></type> <name>createInputFilterChain</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>noChildrenAllowed</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>FilterChain</name></type> <name>result</name> =<init> <expr>new <call><name>FilterChain</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>result</name>.<name>setProject</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>inputFilterChains</name>.<name>add</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Create a nested output &lt;code&gt;FilterChain&lt;/code&gt;.
     * @return &lt;code&gt;FilterChain&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>FilterChain</name></type> <name>createOutputFilterChain</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>noChildrenAllowed</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>FilterChain</name></type> <name>result</name> =<init> <expr>new <call><name>FilterChain</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>result</name>.<name>setProject</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>outputFilterChains</name>.<name>add</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Create a nested error &lt;code&gt;FilterChain&lt;/code&gt;.
     * @return &lt;code&gt;FilterChain&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>FilterChain</name></type> <name>createErrorFilterChain</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>noChildrenAllowed</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>FilterChain</name></type> <name>result</name> =<init> <expr>new <call><name>FilterChain</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>result</name>.<name>setProject</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>errorFilterChains</name>.<name>add</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Configure the specified &lt;code&gt;Redirector&lt;/code&gt;.
     * @param redirector   &lt;code&gt;Redirector&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>configure</name><parameter_list>(<param><decl><type><name>Redirector</name></type> <name>redirector</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>configure</name><argument_list>(<argument><expr><name>redirector</name></expr></argument>, <argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Configure the specified &lt;code&gt;Redirector&lt;/code&gt;
     * for the specified sourcefile.
     * @param redirector   &lt;code&gt;Redirector&lt;/code&gt;.
     * @param sourcefile   &lt;code&gt;String&lt;/code&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>configure</name><parameter_list>(<param><decl><type><name>Redirector</name></type> <name>redirector</name></decl></param>, <param><decl><type><name>String</name></type> <name>sourcefile</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>getRef</name><argument_list>()</argument_list></call>.<call><name>configure</name><argument_list>(<argument><expr><name>redirector</name></expr></argument>, <argument><expr><name>sourcefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>dieOnCircularReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>alwaysLog</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setAlwaysLog</name></name><argument_list>(<argument><expr><call><name><name>alwaysLog</name>.<name>booleanValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>logError</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setLogError</name></name><argument_list>(<argument><expr><call><name><name>logError</name>.<name>booleanValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>append</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setAppend</name></name><argument_list>(<argument><expr><call><name><name>append</name>.<name>booleanValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>createEmptyFiles</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setCreateEmptyFiles</name></name><argument_list>(<argument><expr><call><name><name>createEmptyFiles</name>.<name>booleanValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>outputProperty</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setOutputProperty</name></name><argument_list>(<argument><expr><name>outputProperty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>errorProperty</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setErrorProperty</name></name><argument_list>(<argument><expr><name>errorProperty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>inputString</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setInputString</name></name><argument_list>(<argument><expr><name>inputString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>logInputString</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setLogInputString</name></name><argument_list>(<argument><expr><call><name><name>logInputString</name>.<name>booleanValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>inputMapper</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>inputTargets</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <expr_stmt><expr><name>inputTargets</name> =
                    <call><name><name>inputMapper</name>.<name>getImplementation</name></name><argument_list>()</argument_list></call>.<call><name>mapFileName</name><argument_list>(<argument><expr><name>sourcefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>NullPointerException</name></type> <name>enPeaEx</name></decl></param>) <block>{
                <if>if <condition>(<expr><name>sourcefile</name> != <name>null</name></expr>)</condition><then> <block>{
                    <throw>throw <expr><name>enPeaEx</name></expr>;</throw>
                }</block></then></if>
            }</block></catch></try>
            <if>if <condition>(<expr><name>inputTargets</name> != <name>null</name> &amp;&amp; <name><name>inputTargets</name>.<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>redirector</name>.<name>setInput</name></name><argument_list>(<argument><expr><call><name>toFileArray</name><argument_list>(<argument><expr><name>inputTargets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>outputMapper</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>outputTargets</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <expr_stmt><expr><name>outputTargets</name> =
                    <call><name><name>outputMapper</name>.<name>getImplementation</name></name><argument_list>()</argument_list></call>.<call><name>mapFileName</name><argument_list>(<argument><expr><name>sourcefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>NullPointerException</name></type> <name>enPeaEx</name></decl></param>) <block>{
                <if>if <condition>(<expr><name>sourcefile</name> != <name>null</name></expr>)</condition><then> <block>{
                    <throw>throw <expr><name>enPeaEx</name></expr>;</throw>
                }</block></then></if>
            }</block></catch></try>
            <if>if <condition>(<expr><name>outputTargets</name> != <name>null</name> &amp;&amp; <name><name>outputTargets</name>.<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>redirector</name>.<name>setOutput</name></name><argument_list>(<argument><expr><call><name>toFileArray</name><argument_list>(<argument><expr><name>outputTargets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>errorMapper</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>errorTargets</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <expr_stmt><expr><name>errorTargets</name> =
                    <call><name><name>errorMapper</name>.<name>getImplementation</name></name><argument_list>()</argument_list></call>.<call><name>mapFileName</name><argument_list>(<argument><expr><name>sourcefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>NullPointerException</name></type> <name>enPeaEx</name></decl></param>) <block>{
                <if>if <condition>(<expr><name>sourcefile</name> != <name>null</name></expr>)</condition><then> <block>{
                    <throw>throw <expr><name>enPeaEx</name></expr>;</throw>
                }</block></then></if>
            }</block></catch></try>
            <if>if <condition>(<expr><name>errorTargets</name> != <name>null</name> &amp;&amp; <name><name>errorTargets</name>.<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>redirector</name>.<name>setError</name></name><argument_list>(<argument><expr><call><name>toFileArray</name><argument_list>(<argument><expr><name>errorTargets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>inputFilterChains</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setInputFilterChains</name></name><argument_list>(<argument><expr><name>inputFilterChains</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>outputFilterChains</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setOutputFilterChains</name></name><argument_list>(<argument><expr><name>outputFilterChains</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>errorFilterChains</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setErrorFilterChains</name></name><argument_list>(<argument><expr><name>errorFilterChains</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>inputEncoding</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setInputEncoding</name></name><argument_list>(<argument><expr><name>inputEncoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>outputEncoding</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setOutputEncoding</name></name><argument_list>(<argument><expr><name>outputEncoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>errorEncoding</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>redirector</name>.<name>setErrorEncoding</name></name><argument_list>(<argument><expr><name>errorEncoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Create a merge mapper pointing to the specified destination file.
     * @param destfile   &lt;code&gt;File&lt;/code&gt;
     * @return &lt;code&gt;Mapper&lt;/code&gt;.
     */</comment>
    <function><type><specifier>protected</specifier> <name>Mapper</name></type> <name>createMergeMapper</name><parameter_list>(<param><decl><type><name>File</name></type> <name>destfile</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Mapper</name></type> <name>result</name> =<init> <expr>new <call><name>Mapper</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>result</name>.<name>setClassname</name></name><argument_list>(
            <argument><expr><name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>MergingMapper</name>.<name><name/></name></name>class.<call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>result</name>.<name>setTo</name></name><argument_list>(<argument><expr><call><name><name>destfile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Return a &lt;code&gt;File[]&lt;/code&gt; from the specified set of filenames.
     * @param name   &lt;code&gt;String[]&lt;/code&gt;
     * @return &lt;code&gt;File[]&lt;/code&gt;.
     */</comment>
    <function><type><specifier>protected</specifier> <name>File</name><index>[]</index></type> <name>toFileArray</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>name</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>name</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr><name>null</name></expr>;</return>
        }</block></then></if>
        <comment type="line">//remove any null elements</comment>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>File</name></argument>&gt;</argument_list></name></type> <name>list</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>File</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>name</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>name</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>list</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>resolveFile</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr>(<name><name>File</name><index>[]</index></name>) (<call><name><name>list</name>.<name>toArray</name></name><argument_list>(<argument><expr>new <name><name>File</name><index>[<expr><call><name><name>list</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Overrides the version of DataType to recurse on all DataType
     * child elements that may have been added.
     * @param stk the stack of data types to use (recursively).
     * @param p   the project to use to dereference the references.
     * @throws BuildException on error.
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>dieOnCircularReference</name><parameter_list>(<param><decl><type><name><name>Stack</name><argument_list>&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>stk</name></decl></param>, <param><decl><type><name>Project</name></type> <name>p</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><call><name>isChecked</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>super</name>.<name>dieOnCircularReference</name></name><argument_list>(<argument><expr><name>stk</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>Mapper</name><index>[]</index></type> <name>m</name> =<init> <expr>new <name><name>Mapper</name><index>[]</index></name> <block>{<expr><name>inputMapper</name></expr>, <expr><name>outputMapper</name></expr>, <expr><name>errorMapper</name></expr>}</block></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>m</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index></name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>stk</name>.<name>push</name></name><argument_list>(<argument><expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>dieOnCircularReference</name><argument_list>(<argument><expr><name>stk</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>stk</name>.<name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
            <decl_stmt><decl><type><annotation>@<name>SuppressWarnings</name><argument_list>("unchecked")</argument_list></annotation>
            <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>?</name> <extends>extends <name><name>List</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name></extends></argument>&gt;</argument_list></name></type> <name>filterChainLists</name> =<init> <expr><name><name>Arrays</name>
                    .<name><name/></name></name>&lt;<name><name>List</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name>&gt; <call><name>asList</name><argument_list>(<argument><expr><name>inputFilterChains</name></expr></argument>, <argument><expr><name>outputFilterChains</name></expr></argument>,
                            <argument><expr><name>errorFilterChains</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>List</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name></type> <name>filterChains</name> :<range> <expr><name>filterChainLists</name></expr></range></decl></init>) <block>{
                <if>if <condition>(<expr><name>filterChains</name> != <name>null</name></expr>)</condition><then> <block>{
                    <for>for (<init><decl><type><name>FilterChain</name></type> <name>fc</name> :<range> <expr><name>filterChains</name></expr></range></decl></init>) <block>{
                        <expr_stmt><expr><call><name>pushAndInvokeCircularReferenceCheck</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>stk</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Perform the check for circular references, returning the
     * referenced RedirectorElement.
     * @return the referenced RedirectorElement.
     */</comment>
    <function><type><specifier>private</specifier> <name>RedirectorElement</name></type> <name>getRef</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr>(<name>RedirectorElement</name>) <call><name>getCheckedRef</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

}</block></class>
</unit>
