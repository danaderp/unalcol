<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\types\PropertySet.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name></name>;</package>

<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Enumeration</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashMap</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Iterator</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashSet</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name>.<name>Entry</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Set</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Stack</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>TreeMap</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Hashtable</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Properties</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>MappedResource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>PropertyResource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileNameMapper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>regexp</name>.<name>RegexpMatcher</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>regexp</name>.<name>RegexpMatcherFactory</name></name>;</import>

<comment type="javadoc">/**
 * A set of properties.
 *
 * @since Ant 1.6
 */</comment>
<class><specifier>public</specifier> class <name>PropertySet</name> <super><extends>extends <name>DataType</name></extends> <implements>implements <name>ResourceCollection</name></implements></super> <block>{

    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>dynamic</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>negate</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>cachedNames</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>PropertyRef</name></argument>&gt;</argument_list></name></type> <name>ptyRefs</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>PropertyRef</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>PropertySet</name></argument>&gt;</argument_list></name></type> <name>setRefs</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>PropertySet</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Mapper</name></type> <name>mapper</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This is a nested class containing a reference to some properties
     * and optionally a source of properties.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>PropertyRef</name> <block>{

        <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>count</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>regex</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>prefix</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>builtin</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Set the name.
         * @param name a &lt;code&gt;String&lt;/code&gt; value.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>assertValid</name><argument_list>(<argument><expr>"name"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>name</name></name> = <name>name</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Set the regular expression to use to filter the properties.
         * @param regex a regular expression.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setRegex</name><parameter_list>(<param><decl><type><name>String</name></type> <name>regex</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>assertValid</name><argument_list>(<argument><expr>"regex"</expr></argument>, <argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>regex</name></name> = <name>regex</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Set the prefix to use.
         * @param prefix a &lt;code&gt;String&lt;/code&gt; value.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setPrefix</name><parameter_list>(<param><decl><type><name>String</name></type> <name>prefix</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>assertValid</name><argument_list>(<argument><expr>"prefix"</expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>prefix</name></name> = <name>prefix</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Builtin property names - all, system or commandline.
         * @param b an enumerated &lt;code&gt;BuildinPropertySetName&lt;/code&gt; value.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setBuiltin</name><parameter_list>(<param><decl><type><name>BuiltinPropertySetName</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>pBuiltIn</name> =<init> <expr><call><name><name>b</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assertValid</name><argument_list>(<argument><expr>"builtin"</expr></argument>, <argument><expr><name>pBuiltIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>builtin</name></name> = <name>pBuiltIn</name></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>assertValid</name><parameter_list>(<param><decl><type><name>String</name></type> <name>attr</name></decl></param>, <param><decl><type><name>String</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr><name>value</name> == <name>null</name> || <call><name><name>value</name>.<name>length</name></name><argument_list>()</argument_list></call> &lt; 1</expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Invalid attribute: " + <name>attr</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>

            <if>if <condition>(<expr>++<name>count</name> != 1</expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Attributes name, regex, and "
                    + "prefix are mutually exclusive"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></function>

        <comment type="javadoc">/**
         * A debug toString().
         * @return a string version of this object.
         */</comment>
        <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>"name=" + <name>name</name> + ", regex=" + <name>regex</name> + ", prefix=" + <name>prefix</name>
                + ", builtin=" + <name>builtin</name></expr>;</return>
        }</block></function>

    }</block></class> <comment type="line">//end nested class</comment>

    <comment type="javadoc">/**
     * Allow properties of a particular name in the set.
     * @param name the property name to allow.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>appendName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>PropertyRef</name></type> <name>r</name> =<init> <expr>new <call><name>PropertyRef</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>r</name>.<name>setName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addPropertyref</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Allow properties whose names match a regex in the set.
     * @param regex the regular expression to use.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>appendRegex</name><parameter_list>(<param><decl><type><name>String</name></type> <name>regex</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>PropertyRef</name></type> <name>r</name> =<init> <expr>new <call><name>PropertyRef</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>r</name>.<name>setRegex</name></name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addPropertyref</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Allow properties whose names start with a prefix in the set.
     * @param prefix the prefix to use.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>appendPrefix</name><parameter_list>(<param><decl><type><name>String</name></type> <name>prefix</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>PropertyRef</name></type> <name>r</name> =<init> <expr>new <call><name>PropertyRef</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>r</name>.<name>setPrefix</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addPropertyref</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Allow builtin (all, system or commandline) properties in the set.
     * @param b the type of builtin properties.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>appendBuiltin</name><parameter_list>(<param><decl><type><name>BuiltinPropertySetName</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>PropertyRef</name></type> <name>r</name> =<init> <expr>new <call><name>PropertyRef</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>r</name>.<name>setBuiltin</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addPropertyref</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set a mapper to change property names.
     * @param type mapper type.
     * @param from source pattern.
     * @param to output pattern.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMapper</name><parameter_list>(<param><decl><type><name>String</name></type> <name>type</name></decl></param>, <param><decl><type><name>String</name></type> <name>from</name></decl></param>, <param><decl><type><name>String</name></type> <name>to</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Mapper</name></type> <name>m</name> =<init> <expr><call><name>createMapper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Mapper</name>.<name>MapperType</name></name></type> <name>mapperType</name> =<init> <expr>new <call><name><name>Mapper</name>.<name>MapperType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mapperType</name>.<name>setValue</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>m</name>.<name>setType</name></name><argument_list>(<argument><expr><name>mapperType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>m</name>.<name>setFrom</name></name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>m</name>.<name>setTo</name></name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add a property reference (nested element) to the references to be used.
     * @param ref a property reference.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addPropertyref</name><parameter_list>(<param><decl><type><name>PropertyRef</name></type> <name>ref</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>assertNotReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ptyRefs</name>.<name>add</name></name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add another property set to this set.
     * @param ref another property set.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addPropertyset</name><parameter_list>(<param><decl><type><name>PropertySet</name></type> <name>ref</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>assertNotReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>setRefs</name>.<name>add</name></name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Create a mapper to map the property names.
     * @return a mapper to be configured.
     */</comment>
    <function><type><specifier>public</specifier> <name>Mapper</name></type> <name>createMapper</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>assertNotReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>mapper</name> != <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Too many &lt;mapper&gt;s!"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>mapper</name> = new <call><name>Mapper</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>mapper</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Add a nested FileNameMapper.
     * @param fileNameMapper the mapper to add.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>FileNameMapper</name></type> <name>fileNameMapper</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>createMapper</name><argument_list>()</argument_list></call>.<call><name>add</name><argument_list>(<argument><expr><name>fileNameMapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set whether to reevaluate the set everytime the set is used.
     * Default is true.
     *
     * @param dynamic if true, reevaluate the property set each time
     *                the set is used. if false cache the property set
     *                the first time and use the cached set on subsequent
     *                occasions.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDynamic</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>dynamic</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>assertNotReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>dynamic</name></name> = <name>dynamic</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set whether to negate results.
     * If "true", all properties not selected by nested elements will be returned.
     *  Default is "false".
     * @param negate if true, negate the selection criteria.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setNegate</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>negate</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>assertNotReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>negate</name></name> = <name>negate</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Get the dynamic attribute.
     * @return true if the property set is to be evaluated each time it is used.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getDynamic</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>getRef</name><argument_list>()</argument_list></call>.<name>dynamic</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>dieOnCircularReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>dynamic</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Get the mapper attribute.
     * @return the mapper attribute.
     */</comment>
    <function><type><specifier>public</specifier> <name>Mapper</name></type> <name>getMapper</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>getRef</name><argument_list>()</argument_list></call>.<name>mapper</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>dieOnCircularReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>mapper</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Convert the system properties to a hashtable.
     * Use propertynames to get the list of properties (including
     * default ones).
     */</comment>
    <function><type><specifier>private</specifier> <name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>getAllSystemProperties</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type>  <name>ret</name> =<init> <expr>new <call><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Enumeration</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>e</name> =<init> <expr><call><name><name>System</name>.<name>getProperties</name></name><argument_list>()</argument_list></call>.<call><name>propertyNames</name><argument_list>()</argument_list></call></expr></init></decl>;</init>
             <condition><expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>) <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr>(<name>String</name>) <call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ret</name>.<name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>System</name>.<name>getProperties</name></name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>ret</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * This is the operation to get the existing or recalculated properties.
     * @return the properties for this propertyset.
     */</comment>
    <function><type><specifier>public</specifier> <name>Properties</name></type> <name>getProperties</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>Properties</name></type> <name>result</name> =<init> <expr>new <call><name>Properties</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>result</name>.<name>putAll</name></name><argument_list>(<argument><expr><call><name>getPropertyMap</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     *
     * @return Map
     * @since 1.9.0
     */</comment>
    <function><type><specifier>private</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>getPropertyMap</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>getRef</name><argument_list>()</argument_list></call>.<call><name>getPropertyMap</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>dieOnCircularReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Mapper</name></type> <name>myMapper</name> =<init> <expr><call><name>getMapper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>FileNameMapper</name></type> <name>m</name> =<init> <expr><name>myMapper</name> == <name>null</name> ? <name>null</name> : <call><name><name>myMapper</name>.<name>getImplementation</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>effectiveProperties</name> =<init> <expr><call><name>getEffectiveProperties</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>propertyNames</name> =<init> <expr><call><name>getPropertyNames</name><argument_list>(<argument><expr><name>effectiveProperties</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>result</name> =<init> <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">//iterate through the names, get the matching values</comment>
        <for>for (<init><decl><type><name>String</name></type> <name>name</name> :<range> <expr><name>propertyNames</name></expr></range></decl></init>) <block>{
            <decl_stmt><decl><type><name>Object</name></type> <name>value</name> =<init> <expr><call><name><name>effectiveProperties</name>.<name>get</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// TODO should we include null properties?</comment>
            <comment type="line">// TODO should we query the PropertyHelper for property value to grab potentially shadowed values?</comment>
            <if>if <condition>(<expr><name>value</name> != <name>null</name></expr>)</condition><then> <block>{
                <comment type="line">// may be null if a system property has been added</comment>
                <comment type="line">// after the project instance has been initialized</comment>
                <if>if <condition>(<expr><name>m</name> != <name>null</name></expr>)</condition><then> <block>{
                    <comment type="line">//map the names</comment>
                    <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>newname</name> =<init> <expr><call><name><name>m</name>.<name>mapFileName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>newname</name> != <name>null</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>name</name> = <name><name>newname</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>result</name>.<name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>

    }</block></function>

    <function><type><specifier>private</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>getEffectiveProperties</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>Project</name></type> <name>prj</name> =<init> <expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>result</name> =<init> <expr><name>prj</name> == <name>null</name> ? <call><name>getAllSystemProperties</name><argument_list>()</argument_list></call> : <call><name><name>prj</name>.<name>getProperties</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">//quick &amp; dirty, to make nested mapped p-sets work:</comment>
        <for>for (<init><decl><type><name>PropertySet</name></type> <name>set</name> :<range> <expr><name>setRefs</name></expr></range></decl></init>) <block>{
            <expr_stmt><expr><call><name><name>result</name>.<name>putAll</name></name><argument_list>(<argument><expr><call><name><name>set</name>.<name>getPropertyMap</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getPropertyNames</name><parameter_list>(<param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>props</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>names</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>getDynamic</name><argument_list>()</argument_list></call> || <name>cachedNames</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>names</name> = new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addPropertyNames</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>props</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Add this PropertySet's nested PropertySets' property names.</comment>
            <for>for (<init><decl><type><name>PropertySet</name></type> <name>set</name> :<range> <expr><name>setRefs</name></expr></range></decl></init>) <block>{
                <expr_stmt><expr><call><name><name>names</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>set</name>.<name>getPropertyMap</name></name><argument_list>()</argument_list></call>.<call><name>keySet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <if>if <condition>(<expr><name>negate</name></expr>)</condition><then> <block>{
                <comment type="line">//make a copy...</comment>
                <decl_stmt><decl><type><name><name>HashSet</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>complement</name> =<init> <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>props</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>complement</name>.<name>removeAll</name></name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>names</name> = <name>complement</name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>getDynamic</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>cachedNames</name> = <name>names</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>names</name> = <name>cachedNames</name></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>names</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * @param  names the output Set to fill with the property names
     *         matching this PropertySet selection criteria.
     * @param  props the current Project properties, passed in to
     *         avoid needless duplication of the Hashtable during recursion.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>addPropertyNames</name><parameter_list>(<param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>names</name></decl></param>, <param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>props</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>getRef</name><argument_list>()</argument_list></call>.<call><name>addPropertyNames</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>props</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>dieOnCircularReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Add this PropertySet's property names.</comment>
        <for>for (<init><decl><type><name>PropertyRef</name></type> <name>r</name> :<range> <expr><name>ptyRefs</name></expr></range></decl></init>) <block>{
            <if>if <condition>(<expr><name><name>r</name>.<name>name</name></name> != <name>null</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name><name>props</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>r</name>.<name>name</name></name></expr></argument>)</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>names</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>r</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>r</name>.<name>prefix</name></name> != <name>null</name></expr>)</condition><then> <block>{
                <for>for (<init><decl><type><name>String</name></type> <name>name</name> :<range> <expr><call><name><name>props</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                    <if>if <condition>(<expr><call><name><name>name</name>.<name>startsWith</name></name><argument_list>(<argument><expr><name><name>r</name>.<name>prefix</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>names</name>.<name>add</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>r</name>.<name>regex</name></name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>RegexpMatcherFactory</name></type> <name>matchMaker</name> =<init> <expr>new <call><name>RegexpMatcherFactory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>RegexpMatcher</name></type> <name>matcher</name> =<init> <expr><call><name><name>matchMaker</name>.<name>newRegexpMatcher</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>matcher</name>.<name>setPattern</name></name><argument_list>(<argument><expr><name><name>r</name>.<name>regex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for (<init><decl><type><name>String</name></type> <name>name</name> :<range> <expr><call><name><name>props</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                    <if>if <condition>(<expr><call><name><name>matcher</name>.<name>matches</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>names</name>.<name>add</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>r</name>.<name>builtin</name></name> != <name>null</name></expr>)</condition><then> <block>{

                <if>if <condition>(<expr><call><name><name>r</name>.<name>builtin</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>BuiltinPropertySetName</name>.<name>ALL</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>names</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>props</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>r</name>.<name>builtin</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>BuiltinPropertySetName</name>.<name>SYSTEM</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>names</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name>getAllSystemProperties</name><argument_list>()</argument_list></call>.<call><name>keySet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>r</name>.<name>builtin</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>BuiltinPropertySetName</name>
                                              .<name>COMMANDLINE</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>names</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getUserProperties</name><argument_list>()</argument_list></call>.<call><name>keySet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Impossible: Invalid builtin "
                                             + "attribute!"</expr></argument>)</argument_list></call></expr>;</throw>
                }</block></else></if></else></if></else></if>
            }</block></then> <else>else <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Impossible: Invalid PropertyRef!"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></else></if></else></if></else></if></else></if>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Performs the check for circular references and returns the
     * referenced PropertySet.
     * @return the referenced PropertySet.
     */</comment>
    <function><type><specifier>protected</specifier> <name>PropertySet</name></type> <name>getRef</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr>(<name>PropertySet</name>) <call><name>getCheckedRef</name><argument_list>(<argument><expr><name><name>PropertySet</name>.<name><name/></name></name>class</expr></argument>, <argument><expr>"propertyset"</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the value of the refid attribute.
     *
     * @param  r the reference this datatype should point to.
     * @throws BuildException if another attribute was set, since
     *         refid and all other attributes are mutually exclusive.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>setRefid</name><parameter_list>(<param><decl><type><name>Reference</name></type> <name>r</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr>!<name>noAttributeSet</name></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>super</name>.<name>setRefid</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Ensures this data type is not a reference.
     *
     * &lt;p&gt;Calling this method as the first line of every bean method of
     * this data type (setXyz, addXyz, createXyz) ensure proper handling
     * of the refid attribute.&lt;/p&gt;
     *
     * @throws BuildException if the refid attribute was already set, since
     *         refid and all other attributes are mutually exclusive.
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>final</specifier> <name>void</name></type> <name>assertNotReference</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr><call><name>tooManyAttributes</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>noAttributeSet</name> = false</expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Flag which tracks whether any attribute has been set; used by
     * {@link #assertNotReference()} and {@link #setRefid(Reference)}.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>noAttributeSet</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Used for propertyref's builtin attribute.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>BuiltinPropertySetName</name> <super><extends>extends <name>EnumeratedAttribute</name></extends></super> <block>{
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ALL</name> =<init> <expr>"all"</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>SYSTEM</name> =<init> <expr>"system"</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>COMMANDLINE</name> =<init> <expr>"commandline"</expr></init></decl>;</decl_stmt>
        <comment type="javadoc">/** {@inheritDoc}. */</comment>
        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getValues</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><name>ALL</name></expr>, <expr><name>SYSTEM</name></expr>, <expr><name>COMMANDLINE</name></expr>}</block></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * A debug toString.
     * This gets a comma separated list of key=value pairs for
     * the properties in the set.
     * The output order is sorted according to the keys' &lt;i&gt;natural order&lt;/i&gt;.
     * @return a string rep of this object.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>getRef</name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>dieOnCircularReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>b</name> =<init> <expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>TreeMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>sorted</name> =<init> <expr>new <call><name><name>TreeMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPropertyMap</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>e</name> :<range> <expr><call><name><name>sorted</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
            <if>if <condition>(<expr><call><name><name>b</name>.<name>length</name></name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>b</name>.<name>append</name></name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>b</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>b</name>.<name>append</name></name><argument_list>(<argument><expr>"="</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>b</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>b</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Fulfill the ResourceCollection interface.
     * @return an Iterator of Resources.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>iterator</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>getRef</name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>dieOnCircularReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>names</name> =<init> <expr><call><name>getPropertyNames</name><argument_list>(<argument><expr><call><name>getEffectiveProperties</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Mapper</name></type> <name>myMapper</name> =<init> <expr><call><name>getMapper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>FileNameMapper</name></type> <name>m</name> =<init> <expr><name>myMapper</name> == <name>null</name> ? <name>null</name> : <call><name><name>myMapper</name>.<name>getImplementation</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>iter</name> =<init> <expr><call><name><name>names</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <return>return <expr>new <class><super><name><name>Iterator</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
            <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasNext</name><parameter_list>()</parameter_list> <block>{
                <return>return <expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</return>
            }</block></function>
            <function><type><specifier>public</specifier> <name>Resource</name></type> <name>next</name><parameter_list>()</parameter_list> <block>{
                <decl_stmt><decl><type><name>PropertyResource</name></type> <name>p</name> =<init> <expr>new <call><name>PropertyResource</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <return>return <expr><name>m</name> == <name>null</name> ? (<name>Resource</name>) <name>p</name> : new <call><name>MappedResource</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></function>
            <function><type><specifier>public</specifier> <name>void</name></type> <name>remove</name><parameter_list>()</parameter_list> <block>{
                <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
            }</block></function>
        }</block></class></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Fulfill the ResourceCollection contract.
     * @return the size of this ResourceCollection.
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>size</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name>isReference</name><argument_list>()</argument_list></call> ? <call><name>getRef</name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> : <call><name>getProperties</name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Fulfill the ResourceCollection contract.
     * @return whether this is a filesystem-only resource collection.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isFilesystemOnly</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><call><name>getRef</name><argument_list>()</argument_list></call>.<call><name>isFilesystemOnly</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>dieOnCircularReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <function><type><specifier>protected</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>dieOnCircularReference</name><parameter_list>(<param><decl><type><name><name>Stack</name><argument_list>&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>stk</name></decl></param>, <param><decl><type><name>Project</name></type> <name>p</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><call><name>isChecked</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>isReference</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>super</name>.<name>dieOnCircularReference</name></name><argument_list>(<argument><expr><name>stk</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>mapper</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>pushAndInvokeCircularReferenceCheck</name><argument_list>(<argument><expr><name>mapper</name></expr></argument>, <argument><expr><name>stk</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <for>for (<init><decl><type><name>PropertySet</name></type> <name>propertySet</name> :<range> <expr><name>setRefs</name></expr></range></decl></init>) <block>{
                <expr_stmt><expr><call><name>pushAndInvokeCircularReferenceCheck</name><argument_list>(<argument><expr><name>propertySet</name></expr></argument>, <argument><expr><name>stk</name></expr></argument>,
                                                    <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name>setChecked</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

}</block></class>
</unit>
