<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\util\ClasspathUtils.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name></name>;</package>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>AntClassLoader</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>ProjectComponent</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>MagicNames</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Path</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Reference</name></name>;</import>

<comment type="line">// CheckStyle:HideUtilityClassConstructorCheck OFF - bc</comment>

<comment type="javadoc">/**
 * Offers some helper methods on the Path structure in ant.
 *
 * &lt;p&gt;The basic idea behind this utility class is to use it from inside the
 * different Ant objects (and user defined objects) that need classLoading
 * for their operation.
 * Normally those would have a setClasspathRef() {for the @classpathref}
 * and/or a createClasspath() {for the nested &amp;lt;classpath&amp;gt;}
 * Typically one would have in your Ant Task or DataType&lt;/p&gt;
 *
 * &lt;pre&gt;&lt;code&gt;
 * ClasspathUtils.Delegate cpDelegate;
 *
 * public void init() {
 *     this.cpDelegate = ClasspathUtils.getDelegate(this);
 *     super.init();
 * }
 *
 * public void setClasspathRef(Reference r) {
 *     this.cpDelegate.setClasspathRef(r);
 * }
 *
 * public Path createClasspath() {
 *     return this.cpDelegate.createClasspath();
 * }
 *
 * public void setClassname(String fqcn) {
 *     this.cpDelegate.setClassname(fqcn);
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;At execution time, when you actually need the classloading
 * you can just:&lt;/p&gt;
 *
 * &lt;pre&gt;&lt;code&gt;
 *     Object o = this.cpDelegate.newInstance();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * @since Ant 1.6
 */</comment>
<class><specifier>public</specifier> class <name>ClasspathUtils</name> <block>{

    <comment type="javadoc">/**
     * Name of the magic property that controls classloader reuse in Ant 1.4.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>REUSE_LOADER_REF</name> =<init> <expr><name><name>MagicNames</name>.<name>REFID_CLASSPATH_REUSE_LOADER</name></name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Convenience overloaded version of {@link
     * #getClassLoaderForPath(Project, Reference, boolean)}.
     *
     * &lt;p&gt;Assumes the logical 'false' for the reverseLoader.&lt;/p&gt;
     *
     * @param p the project
     * @param ref the reference
     * @return The class loader
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ClassLoader</name></type> <name>getClassLoaderForPath</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>p</name></decl></param>, <param><decl><type><name>Reference</name></type> <name>ref</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>getClassLoaderForPath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Convenience overloaded version of {@link #getClassLoaderForPath(Project, Path,
     * String, boolean)}.
     *
     * &lt;p&gt;Delegates to the other one after extracting the referenced
     * Path from the Project. This checks also that the passed
     * Reference is pointing to a Path all right.&lt;/p&gt;
     * @param p current Ant project
     * @param ref Reference to Path structure
     * @param reverseLoader if set to true this new loader will take
     * precedence over its parent (which is contra the regular
     * classloader behaviour)
     * @return The class loader
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ClassLoader</name></type> <name>getClassLoaderForPath</name><parameter_list>(
        <param><decl><type><name>Project</name></type> <name>p</name></decl></param>, <param><decl><type><name>Reference</name></type> <name>ref</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>reverseLoader</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>pathId</name> =<init> <expr><call><name><name>ref</name>.<name>getRefId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Object</name></type> <name>path</name> =<init> <expr><call><name><name>p</name>.<name>getReference</name></name><argument_list>(<argument><expr><name>pathId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!(<name>path</name> <name>instanceof</name> <name>Path</name>)</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"The specified classpathref " + <name>pathId</name>
                    + " does not reference a Path."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>String</name></type> <name>loaderId</name> =<init> <expr><name><name>MagicNames</name>.<name>REFID_CLASSPATH_LOADER_PREFIX</name></name> + <name>pathId</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>getClassLoaderForPath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>Path</name>) <name>path</name></expr></argument>, <argument><expr><name>loaderId</name></expr></argument>, <argument><expr><name>reverseLoader</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Convenience overloaded version of {@link
     * #getClassLoaderForPath(Project, Path, String, boolean)}.
     *
     * &lt;p&gt;Assumes the logical 'false' for the reverseLoader.&lt;/p&gt;
     *
     * @param p current Ant project
     * @param path the path
     * @param loaderId the loader id string
     * @return The class loader
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ClassLoader</name></type> <name>getClassLoaderForPath</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>p</name></decl></param>, <param><decl><type><name>Path</name></type> <name>path</name></decl></param>, <param><decl><type><name>String</name></type> <name>loaderId</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>getClassLoaderForPath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>loaderId</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Convenience overloaded version of {@link
     * #getClassLoaderForPath(Project, Path, String, boolean, boolean)}.
     *
     * &lt;p&gt;Sets value for 'reuseLoader' to true if the magic property
     * has been set.&lt;/p&gt;
     *
     * @param p the project
     * @param path the path
     * @param loaderId the loader id string
     * @param reverseLoader if set to true this new loader will take
     * precedence over its parent (which is contra the regular
     * classloader behaviour)
     * @return The class loader
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ClassLoader</name></type> <name>getClassLoaderForPath</name><parameter_list>(
            <param><decl><type><name>Project</name></type> <name>p</name></decl></param>, <param><decl><type><name>Path</name></type> <name>path</name></decl></param>, <param><decl><type><name>String</name></type> <name>loaderId</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>reverseLoader</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>getClassLoaderForPath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>loaderId</name></expr></argument>, <argument><expr><name>reverseLoader</name></expr></argument>, <argument><expr><call><name>isMagicPropertySet</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets a classloader that loads classes from the classpath
     * defined in the path argument.
     *
     * &lt;p&gt;Based on the setting of the magic property
     * 'ant.reuse.loader' this will try to reuse the previously
     * created loader with that id, and of course store it there upon
     * creation.&lt;/p&gt;
     * @param p             Ant Project where the handled components are living in.
     * @param path          Path object to be used as classpath for this classloader
     * @param loaderId      identification for this Loader,
     * @param reverseLoader if set to true this new loader will take
     *                      precedence over its parent (which is contra the regular
     *                      classloader behaviour)
     * @param reuseLoader   if true reuse the loader if it is found
     * @return              ClassLoader that uses the Path as its classpath.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ClassLoader</name></type> <name>getClassLoaderForPath</name><parameter_list>(
            <param><decl><type><name>Project</name></type> <name>p</name></decl></param>, <param><decl><type><name>Path</name></type> <name>path</name></decl></param>, <param><decl><type><name>String</name></type> <name>loaderId</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>reverseLoader</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>reuseLoader</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>ClassLoader</name></type> <name>cl</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// magic property</comment>
        <if>if <condition>(<expr><name>loaderId</name> != <name>null</name> &amp;&amp; <name>reuseLoader</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>Object</name></type> <name>reusedLoader</name> =<init> <expr><call><name><name>p</name>.<name>getReference</name></name><argument_list>(<argument><expr><name>loaderId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>reusedLoader</name> != <name>null</name> &amp;&amp; !(<name>reusedLoader</name> <name>instanceof</name> <name>ClassLoader</name>)</expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"The specified loader id " + <name>loaderId</name>
                        + " does not reference a class loader"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <expr_stmt><expr><name>cl</name> = (<name>ClassLoader</name>) <name>reusedLoader</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>cl</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cl</name> = <call><name>getUniqueClassLoaderForPath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>reverseLoader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>loaderId</name> != <name>null</name> &amp;&amp; <name>reuseLoader</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>p</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>loaderId</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <return>return <expr><name>cl</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets a fresh, different, previously unused classloader that uses the
     * passed path as its classpath.
     *
     * &lt;p&gt;This method completely ignores the ant.reuse.loader magic
     * property and should be used with caution.&lt;/p&gt;
     * @param p             Ant Project where the handled components are living in.
     * @param path          the classpath for this loader
     * @param reverseLoader if set to true this new loader will take
     *                      precedence over its parent (which is contra the regular
     *                      classloader behaviour)
     * @return The fresh, different, previously unused class loader.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ClassLoader</name></type> <name>getUniqueClassLoaderForPath</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>p</name></decl></param>, <param><decl><type><name>Path</name></type> <name>path</name></decl></param>,
            <param><decl><type><name>boolean</name></type> <name>reverseLoader</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>AntClassLoader</name></type> <name>acl</name> =<init> <expr><call><name><name>p</name>.<name>createClassLoader</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>reverseLoader</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>acl</name>.<name>setParentFirst</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>acl</name>.<name>addJavaLibraries</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>acl</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a fresh object instance of the specified classname.
     *
     * &lt;p&gt; This uses the userDefinedLoader to load the specified class,
     * and then makes an instance using the default no-argument constructor.
     * &lt;/p&gt;
     *
     * @param className the full qualified class name to load.
     * @param userDefinedLoader the classloader to use.
     * @return The fresh object instance
     * @throws BuildException when loading or instantiation failed.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Object</name></type> <name>newInstance</name><parameter_list>(<param><decl><type><name>String</name></type> <name>className</name></decl></param>, <param><decl><type><name>ClassLoader</name></type> <name>userDefinedLoader</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>newInstance</name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr><name>userDefinedLoader</name></expr></argument>, <argument><expr><name><name>Object</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a fresh object instance of the specified classname.
     *
     * &lt;p&gt; This uses the userDefinedLoader to load the specified class,
     * and then makes an instance using the default no-argument constructor.
     * &lt;/p&gt;
     *
     * @param className the full qualified class name to load.
     * @param userDefinedLoader the classloader to use.
     * @param expectedType the Class that the result should be assignment
     * compatible with. (No ClassCastException will be thrown in case
     * the result of this method is casted to the expectedType)
     * @return The fresh object instance
     * @throws BuildException when loading or instantiation failed.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Object</name></type> <name>newInstance</name><parameter_list>(<param><decl><type><name>String</name></type> <name>className</name></decl></param>, <param><decl><type><name>ClassLoader</name></type> <name>userDefinedLoader</name></decl></param>,
            <param><decl><type><name>Class</name></type> <name>expectedType</name></decl></param>)</parameter_list> <block>{
        <try>try <block>{
            <decl_stmt><decl><type><name>Class</name></type> <name>clazz</name> =<init> <expr><call><name><name>Class</name>.<name>forName</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr><name>userDefinedLoader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Object</name></type> <name>o</name> =<init> <expr><call><name><name>clazz</name>.<name>newInstance</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>expectedType</name>.<name>isInstance</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Class of unexpected Type: " + <name>className</name> + " expected :"
                        + <name>expectedType</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <return>return <expr><name>o</name></expr>;</return>
        }</block> <catch>catch (<param><decl><type><name>ClassNotFoundException</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Class not found: " + <name>className</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>InstantiationException</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Could not instantiate " + <name>className</name>
                    + ". Specified class should have a no " + "argument constructor."</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>IllegalAccessException</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Could not instantiate " + <name>className</name>
                    + ". Specified class should have a " + "public constructor."</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>LinkageError</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Class " + <name>className</name>
                    + " could not be loaded because of an invalid dependency."</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <comment type="javadoc">/**
     * Obtains a delegate that helps out with classic classpath configuration.
     *
     * @param component your projectComponent that needs the assistence
     * @return the helper, delegate.
     * @see ClasspathUtils.Delegate
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Delegate</name></type> <name>getDelegate</name><parameter_list>(<param><decl><type><name>ProjectComponent</name></type> <name>component</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>new <call><name>Delegate</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Checks for the magic property that enables class loader reuse
     * for &lt;taskdef&gt; and &lt;typedef&gt; in Ant 1.5 and earlier.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isMagicPropertySet</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>p</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>p</name>.<name>getProperty</name></name><argument_list>(<argument><expr><name>REUSE_LOADER_REF</name></expr></argument>)</argument_list></call> != <name>null</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Delegate that helps out any specific ProjectComponent that needs
     * dynamic classloading.
     *
     * &lt;p&gt;Ant ProjectComponents that need a to be able to dynamically load
     * Classes and instantiate them often expose the following ant syntax
     * sugar: &lt;/p&gt;
     *
     * &lt;ul&gt;&lt;li&gt; nested &amp;lt;classpath&amp;gt; &lt;/li&gt;
     * &lt;li&gt; attribute @classpathref &lt;/li&gt;
     * &lt;li&gt; attribute @classname &lt;/li&gt;&lt;/ul&gt;
     *
     * &lt;p&gt; This class functions as a delegate handling the configuration
     * issues for this recurring pattern.  Its usage pattern, as the name
     * suggests, is delegation rather than inheritance. &lt;/p&gt;
     *
     * @since Ant 1.6
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>Delegate</name> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ProjectComponent</name></type> <name>component</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>Path</name></type> <name>classpath</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>classpathId</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>className</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>loaderId</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>reverseLoader</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Construct a Delegate
         * @param component the ProjectComponent this delegate is for.
         */</comment>
        <constructor><name>Delegate</name><parameter_list>(<param><decl><type><name>ProjectComponent</name></type> <name>component</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>component</name></name> = <name>component</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * This method is a Delegate method handling the @classpath attribute.
         *
         * &lt;p&gt;This attribute can set a path to add to the classpath.&lt;/p&gt;
         *
         * @param classpath the path to use for the classpath.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setClasspath</name><parameter_list>(<param><decl><type><name>Path</name></type> <name>classpath</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr><name><name>this</name>.<name>classpath</name></name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>this</name>.<name>classpath</name></name> = <name>classpath</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>this</name>.<name>classpath</name>.<name>append</name></name><argument_list>(<argument><expr><name>classpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></function>

        <comment type="javadoc">/**
         * Delegate method handling the &amp;lt;classpath&amp;gt; tag.
         *
         * &lt;p&gt;This nested path-like structure can set a path to add to the
         * classpath.&lt;/p&gt;
         *
         * @return the created path.
         */</comment>
        <function><type><specifier>public</specifier> <name>Path</name></type> <name>createClasspath</name><parameter_list>()</parameter_list> <block>{
            <if>if <condition>(<expr><name><name>this</name>.<name>classpath</name></name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>this</name>.<name>classpath</name></name> = new <call><name>Path</name><argument_list>(<argument><expr><call><name><name>component</name>.<name>getProject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><call><name><name>this</name>.<name>classpath</name>.<name>createPath</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Delegate method handling the @classname attribute.
         *
         * &lt;p&gt;This attribute sets the full qualified class name of the class
         * to load and instantiate.&lt;/p&gt;
         *
         * @param fcqn the name of the class to load.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setClassname</name><parameter_list>(<param><decl><type><name>String</name></type> <name>fcqn</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>className</name></name> = <name>fcqn</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Delegate method handling the @classpathref attribute.
         *
         * &lt;p&gt;This attribute can add a referenced path-like structure to the
         * classpath.&lt;/p&gt;
         *
         * @param r the reference to the classpath.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setClasspathref</name><parameter_list>(<param><decl><type><name>Reference</name></type> <name>r</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>classpathId</name></name> = <call><name><name>r</name>.<name>getRefId</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>createClasspath</name><argument_list>()</argument_list></call>.<call><name>setRefid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Delegate method handling the @reverseLoader attribute.
         *
         * &lt;p&gt;This attribute can set a boolean indicating that the used
         * classloader should NOT follow the classical parent-first scheme.
         * &lt;/p&gt;
         *
         * &lt;p&gt;By default this is supposed to be false.&lt;/p&gt;
         *
         * &lt;p&gt;Caution: this behaviour is contradictory to the normal way
         * classloaders work.  Do not let your ProjectComponent use it if
         * you are not really sure.&lt;/p&gt;
         *
         * @param reverseLoader if true reverse the order of looking up a class.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setReverseLoader</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>reverseLoader</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>reverseLoader</name></name> = <name>reverseLoader</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Sets the loaderRef.
         * @param r the reference to the loader.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setLoaderRef</name><parameter_list>(<param><decl><type><name>Reference</name></type> <name>r</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>loaderId</name></name> = <call><name><name>r</name>.<name>getRefId</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <comment type="javadoc">/**
         * Finds or creates the classloader for this object.
         * @return The class loader.
         */</comment>
        <function><type><specifier>public</specifier> <name>ClassLoader</name></type> <name>getClassLoader</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name>getClassLoaderForPath</name><argument_list>(<argument><expr><call><name>getContextProject</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>classpath</name></expr></argument>, <argument><expr><call><name>getClassLoadId</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><name>reverseLoader</name></expr></argument>, <argument><expr><name>loaderId</name> != <name>null</name> || <call><name>isMagicPropertySet</name><argument_list>(<argument><expr><call><name>getContextProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * The project of the ProjectComponent we are working for.
         */</comment>
        <function><type><specifier>private</specifier> <name>Project</name></type> <name>getContextProject</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name><name>component</name>.<name>getProject</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Computes the loaderId based on the configuration of the component.
         * @return a loader identifier.
         */</comment>
        <function><type><specifier>public</specifier> <name>String</name></type> <name>getClassLoadId</name><parameter_list>()</parameter_list> <block>{
            <if>if <condition>(<expr><name>loaderId</name> == <name>null</name> &amp;&amp; <name>classpathId</name> != <name>null</name></expr>)</condition><then> <block>{
                <return>return <expr><name><name>MagicNames</name>.<name>REFID_CLASSPATH_LOADER_PREFIX</name></name> + <name>classpathId</name></expr>;</return>
            }</block></then> <else>else <block>{
                <return>return <expr><name>loaderId</name></expr>;</return>
            }</block></else></if>
        }</block></function>

        <comment type="javadoc">/**
         * Helper method obtaining a fresh instance of the class specified
         * in the @classname and using the specified classpath.
         *
         * @return the fresh instantiated object.
         */</comment>
        <function><type><specifier>public</specifier> <name>Object</name></type> <name>newInstance</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name><name>ClasspathUtils</name>.<name>newInstance</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>className</name></name></expr></argument>, <argument><expr><call><name>getClassLoader</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * The classpath.
         * @return the classpath.
         */</comment>
        <function><type><specifier>public</specifier> <name>Path</name></type> <name>getClasspath</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>classpath</name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Get the reverseLoader setting.
         * @return true if looking up in reverse order.
         */</comment>
        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isReverseLoader</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>reverseLoader</name></expr>;</return>
        }</block></function>

        <comment type="line">//TODO no methods yet for getClassname</comment>
        <comment type="line">//TODO no method for newInstance using a reverse-classloader</comment>
    }</block></class>
}</block></class>
</unit>
