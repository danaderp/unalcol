<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\taskdefs\Concat.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>Reader</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>Writer</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileReader</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>InputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>StringReader</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>BufferedReader</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileInputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>InputStreamReader</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Arrays</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Collections</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Iterator</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Task</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>ProjectComponent</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>filters</name>.<name>util</name>.<name>ChainReaderHelper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Path</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>FileSet</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>FileList</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>FilterChain</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Resource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>ResourceCollection</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>FileResource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>Intersect</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>LogOutputResource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>Restrict</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>Resources</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>StringResource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>selectors</name>.<name>Not</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>selectors</name>.<name>Exists</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>selectors</name>.<name>ResourceSelector</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>selectors</name>.<name>SelectorUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>ConcatResourceInputStream</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>ReaderInputStream</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>ResourceUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>StringUtils</name></name>;</import>

<comment type="javadoc">/**
 * This class contains the 'concat' task, used to concatenate a series
 * of files into a single stream. The destination of this stream may
 * be the system console, or a file. The following is a sample
 * invocation:
 *
 * &lt;pre&gt;
 * &amp;lt;concat destfile=&amp;quot;${build.dir}/index.xml&amp;quot;
 *   append=&amp;quot;false&amp;quot;&amp;gt;
 *
 *   &amp;lt;fileset dir=&amp;quot;${xml.root.dir}&amp;quot;
 *     includes=&amp;quot;*.xml&amp;quot; /&amp;gt;
 *
 * &amp;lt;/concat&amp;gt;
 * &lt;/pre&gt;
 *
 */</comment>
<class><specifier>public</specifier> class <name>Concat</name> <super><extends>extends <name>Task</name></extends> <implements>implements <name>ResourceCollection</name></implements></super> <block>{

    <comment type="line">// The size of buffers to be used</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BUFFER_SIZE</name> =<init> <expr>8192</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>FileUtils</name></type> <name>FILE_UTILS</name> =<init> <expr><call><name><name>FileUtils</name>.<name>getFileUtils</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ResourceSelector</name></type> <name>EXISTS</name> =<init> <expr>new <call><name>Exists</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ResourceSelector</name></type> <name>NOT_EXISTS</name> =<init> <expr>new <call><name>Not</name><argument_list>(<argument><expr><name>EXISTS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * sub element points to a file or contains text
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>TextElement</name> <super><extends>extends <name>ProjectComponent</name></extends></super> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type>   <name>value</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type>  <name>trimLeading</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type>  <name>trim</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type>  <name>filtering</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type>   <name>encoding</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * whether to filter the text in this element
         * or not.
         *
         * @param filtering true if the text should be filtered.
         *                  the default value is true.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setFiltering</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>filtering</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>filtering</name></name> = <name>filtering</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/** return the filtering attribute */</comment>
        <function><type><specifier>private</specifier> <name>boolean</name></type> <name>getFiltering</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>filtering</name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * The encoding of the text element
         *
         * @param encoding the name of the charset used to encode
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setEncoding</name><parameter_list>(<param><decl><type><name>String</name></type> <name>encoding</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>encoding</name></name> = <name>encoding</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * set the text using a file
         * @param file the file to use
         * @throws BuildException if the file does not exist, or cannot be
         *                        read
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setFile</name><parameter_list>(<param><decl><type><name>File</name></type> <name>file</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
            <comment type="line">// non-existing files are not allowed</comment>
            <if>if <condition>(<expr>!<call><name><name>file</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"File " + <name>file</name> + " does not exist."</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>

            <decl_stmt><decl><type><name>BufferedReader</name></type> <name>reader</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <if>if <condition>(<expr><name><name>this</name>.<name>encoding</name></name> == <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>reader</name> = new <call><name>BufferedReader</name><argument_list>(<argument><expr>new <call><name>FileReader</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>reader</name> = new <call><name>BufferedReader</name><argument_list>(
                        <argument><expr>new <call><name>InputStreamReader</name><argument_list>(<argument><expr>new <call><name>FileInputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name><name>this</name>.<name>encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><name>value</name> = <call><name><name>FileUtils</name>.<name>safeReadFully</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ex</name></decl></param>) <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch> <finally>finally <block>{
                <expr_stmt><expr><call><name><name>FileUtils</name>.<name>close</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></finally></try>
        }</block></function>

        <comment type="javadoc">/**
         * set the text using inline
         * @param value the text to place inline
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>addText</name><parameter_list>(<param><decl><type><name>String</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>value</name></name> += <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>replaceProperties</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * s:^\s*:: on each line of input
         * @param strip if true do the trim
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setTrimLeading</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>strip</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>trimLeading</name></name> = <name>strip</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * whether to call text.trim()
         * @param trim if true trim the text
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setTrim</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>trim</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>trim</name></name> = <name>trim</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * @return the text, after possible trimming
         */</comment>
        <function><type><specifier>public</specifier> <name>String</name></type> <name>getValue</name><parameter_list>()</parameter_list> <block>{
            <if>if <condition>(<expr><name>value</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>value</name> = ""</expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>value</name>.<name>trim</name></name><argument_list>()</argument_list></call>.<call><name>length</name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>value</name> = ""</expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>trimLeading</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>char</name><index>[]</index></type> <name>current</name> =<init> <expr><call><name><name>value</name>.<name>toCharArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StringBuffer</name></type> <name>b</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>(<argument><expr><name><name>current</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>boolean</name></type> <name>startOfLine</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>pos</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>pos</name> &lt; <name><name>current</name>.<name>length</name></name></expr>)</condition> <block>{
                    <decl_stmt><decl><type><name>char</name></type> <name>ch</name> =<init> <expr><name><name>current</name><index>[<expr><name>pos</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>startOfLine</name></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><name>ch</name> == ' ' || <name>ch</name> == '\t'</expr>)</condition><then> <block>{
                            <continue>continue;</continue>
                        }</block></then></if>
                        <expr_stmt><expr><name>startOfLine</name> = false</expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><call><name><name>b</name>.<name>append</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>ch</name> == '\n' || <name>ch</name> == '\r'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>startOfLine</name> = true</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></while>
                <expr_stmt><expr><name>value</name> = <call><name><name>b</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>trim</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>value</name> = <call><name><name>value</name>.<name>trim</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>value</name></expr>;</return>
        }</block></function>
    }</block></class>

    <class type="interface"><specifier>private</specifier> interface <name><name>ReaderFactory</name><argument_list>&lt;<argument><name>S</name></argument>&gt;</argument_list></name> <block>{
        <function_decl><type><name>Reader</name></type> <name>getReader</name><parameter_list>(<param><decl><type><name>S</name></type> <name>s</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>;</function_decl>
    }</block></class>

    <comment type="javadoc">/**
     * This class reads from each of the source files in turn.
     * The concatentated result can then be filtered as
     * a single stream.
     */</comment>
    <class><specifier>private</specifier> <specifier>final</specifier> class <name><name>MultiReader</name><argument_list>&lt;<argument><name>S</name></argument>&gt;</argument_list></name> <super><extends>extends <name>Reader</name></extends></super> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <name>Reader</name></type> <name>reader</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type>    <name>lastPos</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>char</name><index>[]</index></type> <name>lastChars</name> =<init> <expr>new <name><name>char</name><index>[<expr><call><name><name>eolString</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>needAddSeparator</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name>S</name></argument>&gt;</argument_list></name></type> <name>readerSources</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name><name>ReaderFactory</name><argument_list>&lt;<argument><name>S</name></argument>&gt;</argument_list></name></type> <name>factory</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>MultiReader</name><parameter_list>(<param><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>S</name></argument>&gt;</argument_list></name></type> <name>readerSources</name></decl></param>, <param><decl><type><name><name>ReaderFactory</name><argument_list>&lt;<argument><name>S</name></argument>&gt;</argument_list></name></type> <name>factory</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>readerSources</name></name> = <name>readerSources</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>factory</name></name> = <name>factory</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>private</specifier> <name>Reader</name></type> <name>getReader</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
            <if>if <condition>(<expr><name>reader</name> == <name>null</name> &amp;&amp; <call><name><name>readerSources</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>reader</name> = <call><name><name>factory</name>.<name>getReader</name></name><argument_list>(<argument><expr><call><name><name>readerSources</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>Arrays</name>.<name>fill</name></name><argument_list>(<argument><expr><name>lastChars</name></expr></argument>, <argument><expr>(<name>char</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>reader</name></expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>nextReader</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
            <expr_stmt><expr><call><name>close</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>reader</name> = <name>null</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Read a character from the current reader object. Advance
         * to the next if the reader is finished.
         * @return the character read, -1 for EOF on the last reader.
         * @exception IOException - possibly thrown by the read for a reader
         *            object.
         */</comment>
        <function><type><specifier>public</specifier> <name>int</name></type> <name>read</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
            <if>if <condition>(<expr><name>needAddSeparator</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>ret</name> =<init> <expr><call><name><name>eolString</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>lastPos</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>lastPos</name> &gt;= <call><name><name>eolString</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>lastPos</name> = 0</expr>;</expr_stmt>
                    <expr_stmt><expr><name>needAddSeparator</name> = false</expr>;</expr_stmt>
                }</block></then></if>
                <return>return <expr><name>ret</name></expr>;</return>
            }</block></then></if>
            <while>while <condition>(<expr><call><name>getReader</name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>ch</name> =<init> <expr><call><name>getReader</name><argument_list>()</argument_list></call>.<call><name>read</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>ch</name> == -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>nextReader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name>isFixLastLine</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>isMissingEndOfLine</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>needAddSeparator</name> = true</expr>;</expr_stmt>
                        <expr_stmt><expr><name>lastPos</name> = 0</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>addLastChar</name><argument_list>(<argument><expr>(<name>char</name>) <name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>ch</name></expr>;</return>
                }</block></else></if>
            }</block></while>
            <return>return <expr>-1</expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Read into the buffer &lt;code&gt;cbuf&lt;/code&gt;.
         * @param cbuf The array to be read into.
         * @param off The offset.
         * @param len The length to read.
         * @exception IOException - possibly thrown by the reads to the
         *            reader objects.
         */</comment>
        <function><type><specifier>public</specifier> <name>int</name></type> <name>read</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>cbuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>off</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{

            <decl_stmt><decl><type><name>int</name></type> <name>amountRead</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name>getReader</name><argument_list>()</argument_list></call> != <name>null</name> || <name>needAddSeparator</name></expr>)</condition> <block>{
                <if>if <condition>(<expr><name>needAddSeparator</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>cbuf</name><index>[<expr><name>off</name></expr>]</index></name> = <call><name><name>eolString</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>lastPos</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>lastPos</name> &gt;= <call><name><name>eolString</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>lastPos</name> = 0</expr>;</expr_stmt>
                        <expr_stmt><expr><name>needAddSeparator</name> = false</expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>len</name>--</expr>;</expr_stmt>
                    <expr_stmt><expr><name>off</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name>amountRead</name>++</expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
                        <return>return <expr><name>amountRead</name></expr>;</return>
                    }</block></then></if>
                    <continue>continue;</continue>
                }</block></then></if>
                <decl_stmt><decl><type><name>int</name></type> <name>nRead</name> =<init> <expr><call><name>getReader</name><argument_list>()</argument_list></call>.<call><name>read</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>nRead</name> == -1 || <name>nRead</name> == 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>nextReader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name>isFixLastLine</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>isMissingEndOfLine</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>needAddSeparator</name> = true</expr>;</expr_stmt>
                        <expr_stmt><expr><name>lastPos</name> = 0</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr><call><name>isFixLastLine</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>nRead</name></expr></init></decl>;</init>
                                 <condition><expr><name>i</name> &gt; (<name>nRead</name> - <name><name>lastChars</name>.<name>length</name></name>)</expr>;</condition>
                                 <incr><expr>--<name>i</name></expr></incr>) <block>{
                            <if>if <condition>(<expr><name>i</name> &lt;= 0</expr>)</condition><then> <block>{
                                <break>break;</break>
                            }</block></then></if>
                            <expr_stmt><expr><call><name>addLastChar</name><argument_list>(<argument><expr><name><name>cbuf</name><index>[<expr><name>off</name> + <name>i</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></for>
                    }</block></then></if>
                    <expr_stmt><expr><name>len</name> -= <name>nRead</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>off</name> += <name>nRead</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>amountRead</name> += <name>nRead</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
                        <return>return <expr><name>amountRead</name></expr>;</return>
                    }</block></then></if>
                }</block></else></if>
            }</block></while>
            <if>if <condition>(<expr><name>amountRead</name> == 0</expr>)</condition><then> <block>{
                <return>return <expr>-1</expr>;</return>
            }</block></then> <else>else <block>{
                <return>return <expr><name>amountRead</name></expr>;</return>
            }</block></else></if>
        }</block></function>

        <comment type="javadoc">/**
         * Close the current reader
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
            <if>if <condition>(<expr><name>reader</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>reader</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></function>

        <comment type="javadoc">/**
         * if checking for end of line at end of file
         * add a character to the lastchars buffer
         */</comment>
        <function><type><specifier>private</specifier> <name>void</name></type> <name>addLastChar</name><parameter_list>(<param><decl><type><name>char</name></type> <name>ch</name></decl></param>)</parameter_list> <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name><name>lastChars</name>.<name>length</name></name> - 2</expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
                <expr_stmt><expr><name><name>lastChars</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>lastChars</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><name><name>lastChars</name><index>[<expr><name><name>lastChars</name>.<name>length</name></name> - 1</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * return true if the lastchars buffer does
         * not contain the lineseparator
         */</comment>
        <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isMissingEndOfLine</name><parameter_list>()</parameter_list> <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>lastChars</name>.<name>length</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>lastChars</name><index>[<expr><name>i</name></expr>]</index></name> != <call><name><name>eolString</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr>true</expr>;</return>
                }</block></then></if>
            }</block></for>
            <return>return <expr>false</expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isFixLastLine</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>fixLastLine</name> &amp;&amp; <name>textBuffer</name> == <name>null</name></expr>;</return>
        }</block></function>
    }</block></class>

    <class><specifier>private</specifier> <specifier>final</specifier> class <name>ConcatResource</name> <super><extends>extends <name>Resource</name></extends></super> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <name>ResourceCollection</name></type> <name>c</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>ConcatResource</name><parameter_list>(<param><decl><type><name>ResourceCollection</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>c</name></name> = <name>c</name></expr>;</expr_stmt>
        }</block></constructor>
        <function><type><specifier>public</specifier> <name>InputStream</name></type> <name>getInputStream</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
            <if>if <condition>(<expr><name>binary</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>ConcatResourceInputStream</name></type> <name>result</name> =<init> <expr>new <call><name>ConcatResourceInputStream</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>result</name>.<name>setManagingComponent</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>result</name></expr>;</return>
            }</block></then></if>
            <decl_stmt><decl><type><name>Reader</name></type> <name>resourceReader</name> =<init> <expr><call><name>getFilteredReader</name><argument_list>(
                    <argument><expr>new <call><name><name>MultiReader</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>c</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>resourceReaderFactory</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Reader</name></type> <name>rdr</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>header</name> == <name>null</name> &amp;&amp; <name>footer</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rdr</name> = <name>resourceReader</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>readerCount</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>header</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>readerCount</name>++</expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>footer</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>readerCount</name>++</expr>;</expr_stmt>
                }</block></then></if>
                <decl_stmt><decl><type><name>Reader</name><index>[]</index></type> <name>readers</name> =<init> <expr>new <name><name>Reader</name><index>[<expr><name>readerCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>pos</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>header</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>readers</name><index>[<expr><name>pos</name></expr>]</index></name> = new <call><name>StringReader</name><argument_list>(<argument><expr><call><name><name>header</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name><name>header</name>.<name>getFiltering</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>readers</name><index>[<expr><name>pos</name></expr>]</index></name> = <call><name>getFilteredReader</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>pos</name>++</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name><name>readers</name><index>[<expr><name>pos</name>++</expr>]</index></name> = <name>resourceReader</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>footer</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>readers</name><index>[<expr><name>pos</name></expr>]</index></name> = new <call><name>StringReader</name><argument_list>(<argument><expr><call><name><name>footer</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name><name>footer</name>.<name>getFiltering</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>readers</name><index>[<expr><name>pos</name></expr>]</index></name> = <call><name>getFilteredReader</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>rdr</name> = new <call><name><name>MultiReader</name><argument_list>&lt;<argument><name>Reader</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name>readers</name></expr></argument>)</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><name>identityReaderFactory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <return>return <expr><name>outputEncoding</name> == <name>null</name> ? new <call><name>ReaderInputStream</name><argument_list>(<argument><expr><name>rdr</name></expr></argument>)</argument_list></call>
                    : new <call><name>ReaderInputStream</name><argument_list>(<argument><expr><name>rdr</name></expr></argument>, <argument><expr><name>outputEncoding</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><specifier>public</specifier> <name>String</name></type> <name>getName</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>resourceName</name> == <name>null</name>
                    ? "concat (" + <call><name><name>String</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> + ")" : <name>resourceName</name></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="line">// Attributes.</comment>

    <comment type="javadoc">/**
     * The destination of the stream. If &lt;code&gt;null&lt;/code&gt;, the system
     * console is used.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Resource</name></type> <name>dest</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether or not the stream should be appended if the destination file
     * exists.
     * Defaults to &lt;code&gt;false&lt;/code&gt;.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>append</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Stores the input file encoding.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>encoding</name></decl>;</decl_stmt>

    <comment type="javadoc">/** Stores the output file encoding. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>outputEncoding</name></decl>;</decl_stmt>

    <comment type="javadoc">/** Stores the binary attribute */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>binary</name></decl>;</decl_stmt>

    <comment type="line">// Child elements.</comment>

    <comment type="javadoc">/**
     * This buffer stores the text within the 'concat' element.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>StringBuffer</name></type> <name>textBuffer</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Stores a collection of file sets and/or file lists, used to
     * select multiple files for concatenation.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Resources</name></type> <name>rc</name></decl>;</decl_stmt>

    <comment type="javadoc">/** for filtering the concatenated */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name></type> <name>filterChains</name></decl>;</decl_stmt>
    <comment type="javadoc">/** ignore dates on input files */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>forceOverwrite</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** overwrite read-only files */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>force</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** String to place at the start of the concatented stream */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>TextElement</name></type> <name>footer</name></decl>;</decl_stmt>
    <comment type="javadoc">/** String to place at the end of the concatented stream */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>TextElement</name></type> <name>header</name></decl>;</decl_stmt>
    <comment type="javadoc">/** add missing line.separator to files **/</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>fixLastLine</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** endofline for fixlast line */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>eolString</name></decl>;</decl_stmt>
    <comment type="javadoc">/** outputwriter */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Writer</name></type> <name>outputWriter</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** whether to not create dest if no source files are
     * available */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>ignoreEmpty</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <comment type="javadoc">/** exposed resource name */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>resourceName</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name><name>ReaderFactory</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>resourceReaderFactory</name> =<init> <expr>new <class><super><name><name>ReaderFactory</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
        <function><type><specifier>public</specifier> <name>Reader</name></type> <name>getReader</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>o</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name>InputStream</name></type> <name>is</name> =<init> <expr><call><name><name>o</name>.<name>getInputStream</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>BufferedReader</name><argument_list>(<argument><expr><name>encoding</name> == <name>null</name>
                ? new <call><name>InputStreamReader</name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call>
                : new <call><name>InputStreamReader</name><argument_list>(<argument><expr><name>is</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name><name>ReaderFactory</name><argument_list>&lt;<argument><name>Reader</name></argument>&gt;</argument_list></name></type> <name>identityReaderFactory</name> =<init> <expr>new <class><super><name><name>ReaderFactory</name><argument_list>&lt;<argument><name>Reader</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
        <function><type><specifier>public</specifier> <name>Reader</name></type> <name>getReader</name><parameter_list>(<param><decl><type><name>Reader</name></type> <name>o</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><name>o</name></expr>;</return>
        }</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Construct a new Concat task.
     */</comment>
    <constructor><specifier>public</specifier> <name>Concat</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Reset state to default.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>reset</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>append</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>forceOverwrite</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>dest</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>encoding</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>outputEncoding</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>fixLastLine</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>filterChains</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>footer</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>header</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>binary</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>outputWriter</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>textBuffer</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>eolString</name> = <name><name>StringUtils</name>.<name>LINE_SEP</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <name>null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ignoreEmpty</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>force</name> = false</expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// Attribute setters.</comment>

    <comment type="javadoc">/**
     * Sets the destination file, or uses the console if not specified.
     * @param destinationFile the destination file
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDestfile</name><parameter_list>(<param><decl><type><name>File</name></type> <name>destinationFile</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>setDest</name><argument_list>(<argument><expr>new <call><name>FileResource</name><argument_list>(<argument><expr><name>destinationFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the resource to write to.
     * @param dest the Resource to write to.
     * @since Ant 1.8
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDest</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>dest</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>dest</name></name> = <name>dest</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the behavior when the destination exists. If set to
     * &lt;code&gt;true&lt;/code&gt; the task will append the stream data an
     * {@link Appendable} resource; otherwise existing content will be
     * overwritten. Defaults to &lt;code&gt;false&lt;/code&gt;.
     * @param append if true append output.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setAppend</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>append</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>append</name></name> = <name>append</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the character encoding
     * @param encoding the encoding of the input stream and unless
     *        outputencoding is set, the outputstream.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setEncoding</name><parameter_list>(<param><decl><type><name>String</name></type> <name>encoding</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>encoding</name></name> = <name>encoding</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>outputEncoding</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>outputEncoding</name> = <name>encoding</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the character encoding for outputting
     * @param outputEncoding the encoding for the output file
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setOutputEncoding</name><parameter_list>(<param><decl><type><name>String</name></type> <name>outputEncoding</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>outputEncoding</name></name> = <name>outputEncoding</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Force overwrite existing destination file
     * @param forceOverwrite if true always overwrite, otherwise only
     *              overwrite if the output file is older any of the
     *              input files.
     * @since Ant 1.6
     * @deprecated use #setOverwrite instead
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setForce</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>forceOverwrite</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>forceOverwrite</name></name> = <name>forceOverwrite</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Force overwrite existing destination file
     * @param forceOverwrite if true always overwrite, otherwise only
     *              overwrite if the output file is older any of the
     *              input files.
     * @since Ant 1.8.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setOverwrite</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>forceOverwrite</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>setForce</name><argument_list>(<argument><expr><name>forceOverwrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether read-only destinations will be overwritten.
     *
     * &lt;p&gt;Defaults to false&lt;/p&gt;
     *
     * @since Ant 1.8.2
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setForceReadOnly</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>f</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>force</name> = <name>f</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the behavior when no source resource files are available. If set to
     * &lt;code&gt;false&lt;/code&gt; the destination file will always be created.
     * Defaults to &lt;code&gt;true&lt;/code&gt;.
     * @param ignoreEmpty if false honour destinationfile creation.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setIgnoreEmpty</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>ignoreEmpty</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>ignoreEmpty</name></name> = <name>ignoreEmpty</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the name that will be reported by the exposed {@link Resource}.
     * @param resourceName to set
     * @since Ant 1.8.3
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setResourceName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>resourceName</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>resourceName</name></name> = <name>resourceName</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// Nested element creators.</comment>

    <comment type="javadoc">/**
     * Path of files to concatenate.
     * @return the path used for concatenating
     * @since Ant 1.6
     */</comment>
     <function><type><specifier>public</specifier> <name>Path</name></type> <name>createPath</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>Path</name></type> <name>path</name> =<init> <expr>new <call><name>Path</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>path</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set of files to concatenate.
     * @param set the set of files
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addFileset</name><parameter_list>(<param><decl><type><name>FileSet</name></type> <name>set</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * List of files to concatenate.
     * @param list the list of files
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addFilelist</name><parameter_list>(<param><decl><type><name>FileList</name></type> <name>list</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add an arbitrary ResourceCollection.
     * @param c the ResourceCollection to add.
     * @since Ant 1.7
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>ResourceCollection</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
        <synchronized>synchronized (<expr><name>this</name></expr>) <block>{
            <if>if <condition>(<expr><name>rc</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rc</name> = new <call><name>Resources</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rc</name>.<name>setProject</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rc</name>.<name>setCache</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></synchronized>
        <expr_stmt><expr><call><name><name>rc</name>.<name>add</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a FilterChain.
     * @param filterChain a filterchain to filter the concatenated input
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addFilterChain</name><parameter_list>(<param><decl><type><name>FilterChain</name></type> <name>filterChain</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>filterChains</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>filterChains</name> = new <call><name><name>Vector</name><argument_list>&lt;<argument><name>FilterChain</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>filterChains</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>filterChain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * This method adds text which appears in the 'concat' element.
     * @param text the text to be concated.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addText</name><parameter_list>(<param><decl><type><name>String</name></type> <name>text</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>textBuffer</name> == <name>null</name></expr>)</condition><then> <block>{
            <comment type="line">// Initialize to the size of the first text fragment, with</comment>
            <comment type="line">// the hopes that it's the only one.</comment>
            <expr_stmt><expr><name>textBuffer</name> = new <call><name>StringBuffer</name><argument_list>(<argument><expr><call><name><name>text</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// Append the fragment -- we defer property replacement until</comment>
        <comment type="line">// later just in case we get a partial property in a fragment.</comment>
        <expr_stmt><expr><call><name><name>textBuffer</name>.<name>append</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add a header to the concatenated output
     * @param headerToAdd the header
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addHeader</name><parameter_list>(<param><decl><type><name>TextElement</name></type> <name>headerToAdd</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>header</name></name> = <name>headerToAdd</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Add a footer to the concatenated output
     * @param footerToAdd the footer
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addFooter</name><parameter_list>(<param><decl><type><name>TextElement</name></type> <name>footerToAdd</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>footer</name></name> = <name>footerToAdd</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Append line.separator to files that do not end
     * with a line.separator, default false.
     * @param fixLastLine if true make sure each input file has
     *                    new line on the concatenated stream
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFixLastLine</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>fixLastLine</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>fixLastLine</name></name> = <name>fixLastLine</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Specify the end of line to find and to add if
     * not present at end of each input file. This attribute
     * is used in conjunction with fixlastline.
     * @param crlf the type of new line to add -
     *              cr, mac, lf, unix, crlf, or dos
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setEol</name><parameter_list>(<param><decl><type><name><name>FixCRLF</name>.<name>CrLf</name></name></type> <name>crlf</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>s</name> =<init> <expr><call><name><name>crlf</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>s</name>.<name>equals</name></name><argument_list>(<argument><expr>"cr"</expr></argument>)</argument_list></call> || <call><name><name>s</name>.<name>equals</name></name><argument_list>(<argument><expr>"mac"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>eolString</name> = "\r"</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name><name>s</name>.<name>equals</name></name><argument_list>(<argument><expr>"lf"</expr></argument>)</argument_list></call> || <call><name><name>s</name>.<name>equals</name></name><argument_list>(<argument><expr>"unix"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>eolString</name> = "\n"</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name><name>s</name>.<name>equals</name></name><argument_list>(<argument><expr>"crlf"</expr></argument>)</argument_list></call> || <call><name><name>s</name>.<name>equals</name></name><argument_list>(<argument><expr>"dos"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>eolString</name> = "\r\n"</expr>;</expr_stmt>
        }</block></then></if></else></if></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Set the output writer. This is to allow
     * concat to be used as a nested element.
     * @param outputWriter the output writer.
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setWriter</name><parameter_list>(<param><decl><type><name>Writer</name></type> <name>outputWriter</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>outputWriter</name></name> = <name>outputWriter</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Set the binary attribute. If true, concat will concatenate the files
     * byte for byte. This mode does not allow any filtering or other
     * modifications to the input streams. The default value is false.
     * @since Ant 1.6.2
     * @param binary if true, enable binary mode.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setBinary</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>binary</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>binary</name></name> = <name>binary</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Execute the concat task.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>validate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>binary</name> &amp;&amp; <name>dest</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                <argument><expr>"dest|destfile attribute is required for binary concatenation"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>ResourceCollection</name></type> <name>c</name> =<init> <expr><call><name>getResources</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>isUpToDate</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>dest</name> + " is up-to-date."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>c</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0 &amp;&amp; <name>ignoreEmpty</name></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <try>try <block>{
            <comment type="line">//most of these are defaulted because the concat-as-a-resource code hijacks a lot:</comment>
            <expr_stmt><expr><call><name><name>ResourceUtils</name>.<name>copyResource</name></name><argument_list>(<argument><expr>new <call><name>ConcatResource</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dest</name> == <name>null</name>
                                       ? new <call><name>LogOutputResource</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call>
                                       : <name>dest</name></expr></argument>,
                                       <argument><expr><name>null</name></expr></argument>, <argument><expr><name>null</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>false</expr></argument>, <argument><expr><name>append</name></expr></argument>, <argument><expr><name>null</name></expr></argument>,
                                       <argument><expr><name>null</name></expr></argument>, <argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"error concatenating content to " + <name>dest</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <comment type="javadoc">/**
     * Implement ResourceCollection.
     * @return Iterator&lt;Resource&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name>Resource</name></argument>&gt;</argument_list></name></type> <name>iterator</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>validate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>Collections</name>.<name><name/></name></name>&lt;<name>Resource</name>&gt;<call><name>singletonList</name><argument_list>(<argument><expr>new <call><name>ConcatResource</name><argument_list>(<argument><expr><call><name>getResources</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Implement ResourceCollection.
     * @return 1.
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>size</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Implement ResourceCollection.
     * @return false.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isFilesystemOnly</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Validate configuration options.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>validate</name><parameter_list>()</parameter_list> <block>{

        <comment type="line">// treat empty nested text as no text</comment>
        <expr_stmt><expr><call><name>sanitizeText</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// if binary check if incompatible attributes are used</comment>
        <if>if <condition>(<expr><name>binary</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>textBuffer</name> != <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                    <argument><expr>"Nested text is incompatible with binary concatenation"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <if>if <condition>(<expr><name>encoding</name> != <name>null</name> || <name>outputEncoding</name> != <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                    <argument><expr>"Setting input or output encoding is incompatible with binary"
                    + " concatenation"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <if>if <condition>(<expr><name>filterChains</name> != <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                    <argument><expr>"Setting filters is incompatible with binary concatenation"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <if>if <condition>(<expr><name>fixLastLine</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                    <argument><expr>"Setting fixlastline is incompatible with binary concatenation"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <if>if <condition>(<expr><name>header</name> != <name>null</name> || <name>footer</name> != <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                    <argument><expr>"Nested header or footer is incompatible with binary concatenation"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>dest</name> != <name>null</name> &amp;&amp; <name>outputWriter</name> != <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                <argument><expr>"Cannot specify both a destination resource and an output writer"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <comment type="line">// Sanity check our inputs.</comment>
        <if>if <condition>(<expr><name>rc</name> == <name>null</name> &amp;&amp; <name>textBuffer</name> == <name>null</name></expr>)</condition><then> <block>{
            <comment type="line">// Nothing to concatenate!</comment>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                <argument><expr>"At least one resource must be provided, or some text."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>rc</name> != <name>null</name> &amp;&amp; <name>textBuffer</name> != <name>null</name></expr>)</condition><then> <block>{
            <comment type="line">// If using resources, disallow inline text. This is similar to</comment>
            <comment type="line">// using GNU 'cat' with file arguments--stdin is simply ignored.</comment>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(
                <argument><expr>"Cannot include inline text when using resources."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Get the resources to concatenate.
     */</comment>
    <function><type><specifier>private</specifier> <name>ResourceCollection</name></type> <name>getResources</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>rc</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr>new <call><name>StringResource</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>textBuffer</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>dest</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>Intersect</name></type> <name>checkDestNotInSources</name> =<init> <expr>new <call><name>Intersect</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>checkDestNotInSources</name>.<name>setProject</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>checkDestNotInSources</name>.<name>add</name></name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>checkDestNotInSources</name>.<name>add</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>checkDestNotInSources</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Destination resource " + <name>dest</name>
                        + " was specified as an input resource."</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></then></if>
        <decl_stmt><decl><type><name>Restrict</name></type> <name>noexistRc</name> =<init> <expr>new <call><name>Restrict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>noexistRc</name>.<name>add</name></name><argument_list>(<argument><expr><name>NOT_EXISTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>noexistRc</name>.<name>add</name></name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>Resource</name></type> <name>r</name> :<range> <expr><name>noexistRc</name></expr></range></decl></init>) <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>r</name> + " does not exist."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <decl_stmt><decl><type><name>Restrict</name></type> <name>result</name> =<init> <expr>new <call><name>Restrict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>result</name>.<name>add</name></name><argument_list>(<argument><expr><name>EXISTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>result</name>.<name>add</name></name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isUpToDate</name><parameter_list>(<param><decl><type><name>ResourceCollection</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>dest</name> == <name>null</name> || <name>forceOverwrite</name></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <for>for (<init><decl><type><name>Resource</name></type> <name>r</name> :<range> <expr><name>c</name></expr></range></decl></init>) <block>{
            <if>if <condition>(<expr><call><name><name>SelectorUtils</name>.<name>isOutOfDate</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><call><name><name>FILE_UTILS</name>.<name>getFileTimestampGranularity</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Treat empty nested text as no text.
     *
     * &lt;p&gt;Depending on the XML parser, addText may have been called
     * for &amp;quot;ignorable whitespace&amp;quot; as well.&lt;/p&gt;
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>sanitizeText</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>textBuffer</name> != <name>null</name> &amp;&amp; "".<call><name>equals</name><argument_list>(<argument><expr><call><name><name>textBuffer</name>.<name>toString</name></name><argument_list>()</argument_list></call>.<call><name>trim</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>textBuffer</name> = <name>null</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>Reader</name></type> <name>getFilteredReader</name><parameter_list>(<param><decl><type><name>Reader</name></type> <name>r</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>filterChains</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr><name>r</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>ChainReaderHelper</name></type> <name>helper</name> =<init> <expr>new <call><name>ChainReaderHelper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>helper</name>.<name>setBufferSize</name></name><argument_list>(<argument><expr><name>BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>helper</name>.<name>setPrimaryReader</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>helper</name>.<name>setFilterChains</name></name><argument_list>(<argument><expr><name>filterChains</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>helper</name>.<name>setProject</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//used to be a BufferedReader here, but we should be buffering lower:</comment>
        <return>return <expr><call><name><name>helper</name>.<name>getAssembledReader</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

}</block></class>
</unit>
