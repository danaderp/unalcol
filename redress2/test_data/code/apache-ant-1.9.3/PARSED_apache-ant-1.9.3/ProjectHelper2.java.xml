<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\helper\ProjectHelper2.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>helper</name></name>;</package>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>ExtensionPoint</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Location</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>MagicNames</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>ProjectHelper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>RuntimeConfigurable</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Target</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Task</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>UnknownElement</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Resource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>FileProvider</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>URLProvider</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>JAXPUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name>.<name>ZipFile</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>Attributes</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>InputSource</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>Locator</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>SAXException</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>SAXParseException</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>XMLReader</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>helpers</name>.<name>DefaultHandler</name></name>;</import>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileInputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>FileNotFoundException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>InputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>UnsupportedEncodingException</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>URL</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashMap</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Hashtable</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Stack</name></name>;</import>

<comment type="javadoc">/**
 * Sax2 based project reader
 *
 */</comment>
<class><specifier>public</specifier> class <name>ProjectHelper2</name> <super><extends>extends <name>ProjectHelper</name></extends></super> <block>{

    <comment type="javadoc">/** Reference holding the (ordered) target Vector */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>REFID_TARGETS</name> =<init> <expr>"ant.targets"</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Stateless */</comment>

    <comment type="line">// singletons - since all state is in the context</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>AntHandler</name></type> <name>elementHandler</name> =<init> <expr>new <call><name>ElementHandler</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>AntHandler</name></type> <name>targetHandler</name> =<init> <expr>new <call><name>TargetHandler</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>AntHandler</name></type> <name>mainHandler</name> =<init> <expr>new <call><name>MainHandler</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>AntHandler</name></type> <name>projectHandler</name> =<init> <expr>new <call><name>ProjectHandler</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** Specific to ProjectHelper2 so not a true Ant "magic name:" */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>REFID_CONTEXT</name> =<init> <expr>"ant.parsing.context"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * helper for path -&gt; URI and URI -&gt; path conversions.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>FileUtils</name></type> <name>FILE_UTILS</name> =<init> <expr><call><name><name>FileUtils</name>.<name>getFileUtils</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether this instance of ProjectHelper can parse an Antlib
     * descriptor given by the URL and return its content as an
     * UnknownElement ready to be turned into an Antlib task.
     *
     * &lt;p&gt;This implementation returns true.&lt;/p&gt;
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>canParseAntlibDescriptor</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>resource</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Parse the given URL as an antlib descriptor and return the
     * content as something that can be turned into an Antlib task.
     *
     * &lt;p&gt;simply delegates to {@link #parseUnknownElement
     * parseUnknownElement} if the resource provides an URL and throws
     * an exception otherwise.&lt;/p&gt;
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>UnknownElement</name></type> <name>parseAntlibDescriptor</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>containingProject</name></decl></param>,
                                                <param><decl><type><name>Resource</name></type> <name>resource</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>URLProvider</name></type> <name>up</name> =<init> <expr><call><name><name>resource</name>.<name>as</name></name><argument_list>(<argument><expr><name><name>URLProvider</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>up</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Unsupported resource type: " + <name>resource</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name>parseUnknownElement</name><argument_list>(<argument><expr><name>containingProject</name></expr></argument>, <argument><expr><call><name><name>up</name>.<name>getURL</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Parse an unknown element from a url
     *
     * @param project the current project
     * @param source  the url containing the task
     * @return a configured task
     * @exception BuildException if an error occurs
     */</comment>
    <function><type><specifier>public</specifier> <name>UnknownElement</name></type> <name>parseUnknownElement</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>URL</name></type> <name>source</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>Target</name></type> <name>dummyTarget</name> =<init> <expr>new <call><name>Target</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>dummyTarget</name>.<name>setProject</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>AntXMLContext</name></type> <name>context</name> =<init> <expr>new <call><name>AntXMLContext</name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>context</name>.<name>addTarget</name></name><argument_list>(<argument><expr><name>dummyTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>context</name>.<name>setImplicitTarget</name></name><argument_list>(<argument><expr><name>dummyTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>parse</name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr>new <call><name>RootHandler</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>elementHandler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Task</name><index>[]</index></type> <name>tasks</name> =<init> <expr><call><name><name>dummyTarget</name>.<name>getTasks</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>tasks</name>.<name>length</name></name> != 1</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"No tasks defined"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr>(<name>UnknownElement</name>) <name><name>tasks</name><index>[<expr>0</expr>]</index></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Parse a source xml input.
     *
     * @param project the current project
     * @param source  the xml source
     * @exception BuildException if an error occurs
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>parse</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>Object</name></type> <name>source</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>getImportStack</name><argument_list>()</argument_list></call>.<call><name>addElement</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>AntXMLContext</name></type> <name>context</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>context</name> = (<name>AntXMLContext</name>) <call><name><name>project</name>.<name>getReference</name></name><argument_list>(<argument><expr><name>REFID_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>context</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>context</name> = new <call><name>AntXMLContext</name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>project</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>REFID_CONTEXT</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>project</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>REFID_TARGETS</name></expr></argument>, <argument><expr><call><name><name>context</name>.<name>getTargets</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>getImportStack</name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
            <comment type="line">// we are in an imported file.</comment>
            <expr_stmt><expr><call><name><name>context</name>.<name>setIgnoreProjectTag</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Target</name></type> <name>currentTarget</name> =<init> <expr><call><name><name>context</name>.<name>getCurrentTarget</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Target</name></type> <name>currentImplicit</name> =<init> <expr><call><name><name>context</name>.<name>getImplicitTarget</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Target</name></argument>&gt;</argument_list></name></type>    <name>currentTargets</name> =<init> <expr><call><name><name>context</name>.<name>getCurrentTargets</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <decl_stmt><decl><type><name>Target</name></type> <name>newCurrent</name> =<init> <expr>new <call><name>Target</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>newCurrent</name>.<name>setProject</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>newCurrent</name>.<name>setName</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>context</name>.<name>setCurrentTarget</name></name><argument_list>(<argument><expr><name>newCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>context</name>.<name>setCurrentTargets</name></name><argument_list>(<argument><expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Target</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>context</name>.<name>setImplicitTarget</name></name><argument_list>(<argument><expr><name>newCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>parse</name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr>new <call><name>RootHandler</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>mainHandler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>newCurrent</name>.<name>execute</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block> <finally>finally <block>{
                <expr_stmt><expr><call><name><name>context</name>.<name>setCurrentTarget</name></name><argument_list>(<argument><expr><name>currentTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>context</name>.<name>setImplicitTarget</name></name><argument_list>(<argument><expr><name>currentImplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>context</name>.<name>setCurrentTargets</name></name><argument_list>(<argument><expr><name>currentTargets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></finally></try>
        }</block></then> <else>else <block>{
            <comment type="line">// top level file</comment>
            <expr_stmt><expr><call><name><name>context</name>.<name>setCurrentTargets</name></name><argument_list>(<argument><expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Target</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>parse</name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr>new <call><name>RootHandler</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>mainHandler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Execute the top-level target</comment>
            <expr_stmt><expr><call><name><name>context</name>.<name>getImplicitTarget</name></name><argument_list>()</argument_list></call>.<call><name>execute</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// resolve extensionOf attributes</comment>
            <expr_stmt><expr><call><name>resolveExtensionOfAttributes</name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Parses the project file, configuring the project as it goes.
     *
     * @param project the current project
     * @param source  the xml source
     * @param handler the root handler to use (contains the current context)
     * @exception BuildException if the configuration is invalid or cannot
     *                           be read
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>parse</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>Object</name></type> <name>source</name></decl></param>, <param><decl><type><name>RootHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{

        <decl_stmt><decl><type><name>AntXMLContext</name></type> <name>context</name> =<init> <expr><name><name>handler</name>.<name>context</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>File</name></type> <name>buildFile</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>URL</name></type>  <name>url</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>buildFileName</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>source</name> <name>instanceof</name> <name>File</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>buildFile</name> = (<name>File</name>) <name>source</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>source</name> <name>instanceof</name> <name>URL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>url</name> = (<name>URL</name>) <name>source</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>source</name> <name>instanceof</name> <name>Resource</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>FileProvider</name></type> <name>fp</name> =<init>
                <expr>((<name>Resource</name>) <name>source</name>).<call><name>as</name><argument_list>(<argument><expr><name><name>FileProvider</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>fp</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>buildFile</name> = <call><name><name>fp</name>.<name>getFile</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><name>URLProvider</name></type> <name>up</name> =<init>
                    <expr>((<name>Resource</name>) <name>source</name>).<call><name>as</name><argument_list>(<argument><expr><name><name>URLProvider</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>up</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>url</name> = <call><name><name>up</name>.<name>getURL</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></then></if></else></if></else></if>
        <if>if <condition>(<expr><name>buildFile</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>buildFile</name> = <call><name><name>FILE_UTILS</name>.<name>normalize</name></name><argument_list>(<argument><expr><call><name><name>buildFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>context</name>.<name>setBuildFile</name></name><argument_list>(<argument><expr><name>buildFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buildFileName</name> = <call><name><name>buildFile</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>url</name> != <name>null</name></expr>)</condition><then> <block>{
            <try>try <block>{
                <expr_stmt><expr><call><name><name>context</name>.<name>setBuildFile</name></name><argument_list>(<argument><expr>(<name>File</name>) <name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>context</name>.<name>setBuildFile</name></name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name><name>java</name>.<name>net</name>.<name>MalformedURLException</name></name></type> <name>ex</name></decl></param>) <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
            <expr_stmt><expr><name>buildFileName</name> = <call><name><name>url</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Source " + <call><name><name>source</name>.<name>getClass</name></name><argument_list>()</argument_list></call>.<call><name>getName</name><argument_list>()</argument_list></call>
                                     + " not supported by this plugin"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></else></if></else></if>
        <decl_stmt><decl><type><name>InputStream</name></type> <name>inputStream</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>InputSource</name></type> <name>inputSource</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZipFile</name></type> <name>zf</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

        <try>try <block>{
            <comment type="javadoc">/**
             * SAX 2 style parser used to parse the given file.
             */</comment>
            <decl_stmt><decl><type><name>XMLReader</name></type> <name>parser</name> =<init> <expr><call><name><name>JAXPUtils</name>.<name>getNamespaceXMLReader</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>String</name></type> <name>uri</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>buildFile</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>uri</name> = <call><name><name>FILE_UTILS</name>.<name>toURI</name></name><argument_list>(<argument><expr><call><name><name>buildFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>inputStream</name> = new <call><name>FileInputStream</name><argument_list>(<argument><expr><name>buildFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>uri</name> = <call><name><name>url</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>pling</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>uri</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"jar:file"</expr></argument>)</argument_list></call>
                    &amp;&amp; (<name>pling</name> = <call><name><name>uri</name>.<name>indexOf</name></name><argument_list>(<argument><expr>"!/"</expr></argument>)</argument_list></call>) &gt; -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>zf</name> = new <call><name>ZipFile</name><argument_list>(<argument><expr><call><name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>launch</name>.<name>Locator</name>
                                     .<name>fromJarURI</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"UTF-8"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inputStream</name> =
                        <call><name><name>zf</name>.<name>getInputStream</name></name><argument_list>(<argument><expr><call><name><name>zf</name>.<name>getEntry</name></name><argument_list>(<argument><expr><call><name><name>uri</name>.<name>substring</name></name><argument_list>(<argument><expr><name>pling</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>inputStream</name> = <call><name><name>url</name>.<name>openStream</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if>

            <expr_stmt><expr><name>inputSource</name> = new <call><name>InputSource</name><argument_list>(<argument><expr><name>inputStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>uri</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>inputSource</name>.<name>setSystemId</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr>"parsing buildfile " + <name>buildFileName</name> + " with URI = "
                        + <name>uri</name> + (<name>zf</name> != <name>null</name> ? " from a zip file" : "")</expr></argument>,
                        <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>DefaultHandler</name></type> <name>hb</name> =<init> <expr><name>handler</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>parser</name>.<name>setContentHandler</name></name><argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name>.<name>setEntityResolver</name></name><argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name>.<name>setErrorHandler</name></name><argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name>.<name>setDTDHandler</name></name><argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>parser</name>.<name>parse</name></name><argument_list>(<argument><expr><name>inputSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>SAXParseException</name></type> <name>exc</name></decl></param>) <block>{
            <decl_stmt><decl><type><name>Location</name></type> <name>location</name> =<init> <expr>new <call><name>Location</name><argument_list>(<argument><expr><call><name><name>exc</name>.<name>getSystemId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>exc</name>.<name>getLineNumber</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>exc</name>
                                             .<name>getColumnNumber</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Throwable</name></type> <name>t</name> =<init> <expr><call><name><name>exc</name>.<name>getException</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>t</name> <name>instanceof</name> <name>BuildException</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>BuildException</name></type> <name>be</name> =<init> <expr>(<name>BuildException</name>) <name>t</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>be</name>.<name>getLocation</name></name><argument_list>()</argument_list></call> == <name><name>Location</name>.<name>UNKNOWN_LOCATION</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>be</name>.<name>setLocation</name></name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <throw>throw <expr><name>be</name></expr>;</throw>
            }</block></then></if>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><call><name><name>exc</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>t</name> == <name>null</name> ? <name>exc</name> : <name>t</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>SAXException</name></type> <name>exc</name></decl></param>) <block>{
            <decl_stmt><decl><type><name>Throwable</name></type> <name>t</name> =<init> <expr><call><name><name>exc</name>.<name>getException</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>t</name> <name>instanceof</name> <name>BuildException</name></expr>)</condition><then> <block>{
                <throw>throw <expr>(<name>BuildException</name>) <name>t</name></expr>;</throw>
            }</block></then></if>
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><call><name><name>exc</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>t</name> == <name>null</name> ? <name>exc</name> : <name>t</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>FileNotFoundException</name></type> <name>exc</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>UnsupportedEncodingException</name></type> <name>exc</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Encoding of project file " + <name>buildFileName</name> + " is invalid."</expr></argument>,
                                     <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <catch>catch (<param><decl><type><name>IOException</name></type> <name>exc</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Error reading project file " + <name>buildFileName</name> + ": "
                                     + <call><name><name>exc</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <finally>finally <block>{
            <expr_stmt><expr><call><name><name>FileUtils</name>.<name>close</name></name><argument_list>(<argument><expr><name>inputStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ZipFile</name>.<name>closeQuietly</name></name><argument_list>(<argument><expr><name>zf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * Returns main handler
     * @return main handler
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>AntHandler</name></type> <name>getMainHandler</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mainHandler</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets main handler
     * @param handler  new main handler
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>void</name></type> <name>setMainHandler</name><parameter_list>(<param><decl><type><name>AntHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>mainHandler</name> = <name>handler</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Returns project handler
     * @return project handler
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>AntHandler</name></type> <name>getProjectHandler</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>projectHandler</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets project handler
     * @param handler  new project handler
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>void</name></type> <name>setProjectHandler</name><parameter_list>(<param><decl><type><name>AntHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>projectHandler</name> = <name>handler</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Returns target handler
     * @return target handler
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>AntHandler</name></type> <name>getTargetHandler</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>targetHandler</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets target handler
     * @param handler  new target handler
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>void</name></type> <name>setTargetHandler</name><parameter_list>(<param><decl><type><name>AntHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>targetHandler</name> = <name>handler</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Returns element handler
     * @return element handler
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>AntHandler</name></type> <name>getElementHandler</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>elementHandler</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets element handler
     * @param handler  new element handler
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>void</name></type> <name>setElementHandler</name><parameter_list>(<param><decl><type><name>AntHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>elementHandler</name> = <name>handler</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * The common superclass for all SAX event handlers used to parse
     * the configuration file.
     *
     * The context will hold all state information. At each time
     * there is one active handler for the current element. It can
     * use onStartChild() to set an alternate handler for the child.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>AntHandler</name>  <block>{
        <comment type="javadoc">/**
         * Handles the start of an element. This base implementation does
         * nothing.
         *
         * @param uri the namespace URI for the tag
         * @param tag The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param qname The qualified name of the element.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param context The context that this element is in.
         *
         * @exception SAXParseException if this method is not overridden, or in
         *                              case of error in an overridden version
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>onStartElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>Attributes</name></type> <name>attrs</name></decl></param>,
                                   <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of an element. This base implementation just
         * throws an exception - you must override this method if you expect
         * child elements.
         *
         * @param uri The namespace uri for this element.
         * @param tag The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param qname The qualified name for this element.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param context The current context.
         * @return a handler (in the derived classes)
         *
         * @exception SAXParseException if this method is not overridden, or in
         *                              case of error in an overridden version
         */</comment>
        <function><type><specifier>public</specifier> <name>AntHandler</name></type> <name>onStartChild</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>Attributes</name></type> <name>attrs</name></decl></param>,
                                       <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"Unexpected element \"" + <name>qname</name> + " \""</expr></argument>, <argument><expr><call><name><name>context</name>
                                        .<name>getLocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></function>

        <comment type="javadoc">/**
         * Handle the end of a element.
         *
         * @param uri the namespace uri of the element
         * @param tag the tag of the element
         * @param qname the qualified name of the element
         * @param context the current context
         * @exception SAXParseException if an error occurs
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>onEndChild</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
        }</block></function>

        <comment type="javadoc">/**
         * This method is called when this element and all elements nested into it have been
         * handled. I.e., this happens at the &amp;lt;/end_tag_of_the_element&amp;gt;.
         * @param uri the namespace uri for this element
         * @param tag the element name
         * @param context the current context
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>onEndElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
        }</block></function>

        <comment type="javadoc">/**
         * Handles text within an element. This base implementation just
         * throws an exception, you must override it if you expect content.
         *
         * @param buf A character array of the text within the element.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param start The start element in the array.
         * @param count The number of characters to read from the array.
         * @param context The current context.
         *
         * @exception SAXParseException if this method is not overridden, or in
         *                              case of error in an overridden version
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>characters</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>, <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>s</name> =<init> <expr>new <call><name>String</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call>.<call><name>trim</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>s</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"Unexpected text \"" + <name>s</name> + "\""</expr></argument>, <argument><expr><call><name><name>context</name>.<name>getLocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></function>

        <comment type="javadoc">/**
         * Will be called every time a namespace is reached.
         * It'll verify if the ns was processed, and if not load the task definitions.
         * @param uri The namespace uri.
         */</comment>
        <function><type><specifier>protected</specifier> <name>void</name></type> <name>checkNamespace</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>)</parameter_list> <block>{
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Handler for ant processing. Uses a stack of AntHandlers to
     * implement each element ( the original parser used a recursive behavior,
     * with the implicit execution stack )
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>RootHandler</name> <super><extends>extends <name>DefaultHandler</name></extends></super> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Stack</name><argument_list>&lt;<argument><name>AntHandler</name></argument>&gt;</argument_list></name></type> <name>antHandlers</name> =<init> <expr>new <call><name><name>Stack</name><argument_list>&lt;<argument><name>AntHandler</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>AntHandler</name></type> <name>currentHandler</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>AntXMLContext</name></type> <name>context</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Creates a new RootHandler instance.
         *
         * @param context The context for the handler.
         * @param rootHandler The handler for the root element.
         */</comment>
        <constructor><specifier>public</specifier> <name>RootHandler</name><parameter_list>(<param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>, <param><decl><type><name>AntHandler</name></type> <name>rootHandler</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name>currentHandler</name> = <name>rootHandler</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>antHandlers</name>.<name>push</name></name><argument_list>(<argument><expr><name>currentHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>context</name></name> = <name>context</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Returns the current ant handler object.
         * @return the current ant handler.
         */</comment>
        <function><type><specifier>public</specifier> <name>AntHandler</name></type> <name>getCurrentAntHandler</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>currentHandler</name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Resolves file: URIs relative to the build file.
         *
         * @param publicId The public identifier, or &lt;code&gt;null&lt;/code&gt;
         *                 if none is available. Ignored in this
         *                 implementation.
         * @param systemId The system identifier provided in the XML
         *                 document. Will not be &lt;code&gt;null&lt;/code&gt;.
         * @return an inputsource for this identifier
         */</comment>
        <function><type><specifier>public</specifier> <name>InputSource</name></type> <name>resolveEntity</name><parameter_list>(<param><decl><type><name>String</name></type> <name>publicId</name></decl></param>, <param><decl><type><name>String</name></type> <name>systemId</name></decl></param>)</parameter_list> <block>{

            <expr_stmt><expr><call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call>.<call><name>log</name><argument_list>(<argument><expr>"resolving systemId: " + <name>systemId</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name><name>systemId</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"file:"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>path</name> =<init> <expr><call><name><name>FILE_UTILS</name>.<name>fromURI</name></name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>File</name></type> <name>file</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name><name>file</name>.<name>isAbsolute</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>file</name> = <call><name><name>FILE_UTILS</name>.<name>resolveFile</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getBuildFileParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call>.<call><name>log</name><argument_list>(
                                             <argument><expr>"Warning: '" + <name>systemId</name> + "' in " + <call><name><name>context</name>.<name>getBuildFile</name></name><argument_list>()</argument_list></call>
                                             + " should be expressed simply as '" + <call><name><name>path</name>.<name>replace</name></name><argument_list>(<argument><expr>'\\'</expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call>
                                             + "' for compliance with other XML tools"</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call>.<call><name>log</name><argument_list>(<argument><expr>"file=" + <name>file</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_DEBUG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <try>try <block>{
                    <decl_stmt><decl><type><name>InputSource</name></type> <name>inputSource</name> =<init> <expr>new <call><name>InputSource</name><argument_list>(<argument><expr>new <call><name>FileInputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>inputSource</name>.<name>setSystemId</name></name><argument_list>(<argument><expr><call><name><name>FILE_UTILS</name>.<name>toURI</name></name><argument_list>(<argument><expr><call><name><name>file</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>inputSource</name></expr>;</return>
                }</block> <catch>catch (<param><decl><type><name>FileNotFoundException</name></type> <name>fne</name></decl></param>) <block>{
                    <expr_stmt><expr><call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call>.<call><name>log</name><argument_list>(<argument><expr><call><name><name>file</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call> + " could not be found"</expr></argument>,
                                             <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></catch></try>

            }</block></then></if>
            <comment type="line">// use default if not file or file not found</comment>
            <expr_stmt><expr><call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call>.<call><name>log</name><argument_list>(<argument><expr>"could not resolve systemId"</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_DEBUG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>null</name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of a project element. A project handler is created
         * and initialised with the element name and attributes.
         *
         * @param uri The namespace uri for this element.
         * @param tag The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param qname The qualified name for this element.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         *
         * @exception org.xml.sax.SAXParseException if the tag given is not
         *                              &lt;code&gt;"project"&lt;/code&gt;
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>startElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>Attributes</name></type> <name>attrs</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name>AntHandler</name></type> <name>next</name> =<init> <expr><call><name><name>currentHandler</name>.<name>onStartChild</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>qname</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>antHandlers</name>.<name>push</name></name><argument_list>(<argument><expr><name>currentHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>currentHandler</name> = <name>next</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>currentHandler</name>.<name>onStartElement</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>qname</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Sets the locator in the project helper for future reference.
         *
         * @param locator The locator used by the parser.
         *                Will not be &lt;code&gt;null&lt;/code&gt;.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setDocumentLocator</name><parameter_list>(<param><decl><type><name>Locator</name></type> <name>locator</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>context</name>.<name>setLocator</name></name><argument_list>(<argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the end of an element. Any required clean-up is performed
         * by the onEndElement() method and then the original handler is restored to the parser.
         *
         * @param uri  The namespace URI for this element.
         * @param name The name of the element which is ending.
         *             Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param qName The qualified name for this element.
         *
         * @exception SAXException in case of error (not thrown in this implementation)
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>endElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>String</name></type> <name>qName</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXException</name></expr></argument></throws> <block>{
            <expr_stmt><expr><call><name><name>currentHandler</name>.<name>onEndElement</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>AntHandler</name></type> <name>prev</name> =<init> <expr>(<name>AntHandler</name>) <call><name><name>antHandlers</name>.<name>pop</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>currentHandler</name> = <name>prev</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>currentHandler</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>currentHandler</name>.<name>onEndChild</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>qName</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></function>

        <comment type="javadoc">/**
         * Handle text within an element, calls currentHandler.characters.
         *
         * @param buf  A character array of the test.
         * @param start The start offset in the array.
         * @param count The number of characters to read.
         * @exception SAXParseException if an error occurs
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>characters</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <expr_stmt><expr><call><name><name>currentHandler</name>.<name>characters</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Start a namespace prefix to uri mapping
         *
         * @param prefix the namespace prefix
         * @param uri the namespace uri
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>startPrefixMapping</name><parameter_list>(<param><decl><type><name>String</name></type> <name>prefix</name></decl></param>, <param><decl><type><name>String</name></type> <name>uri</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>context</name>.<name>startPrefixMapping</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * End a namespace prefix to uri mapping
         *
         * @param prefix the prefix that is not mapped anymore
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>endPrefixMapping</name><parameter_list>(<param><decl><type><name>String</name></type> <name>prefix</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>context</name>.<name>endPrefixMapping</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * The main handler - it handles the &amp;lt;project&amp;gt; tag.
     *
     * @see org.apache.tools.ant.helper.ProjectHelper2.AntHandler
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>MainHandler</name> <super><extends>extends <name>AntHandler</name></extends></super> <block>{

        <comment type="javadoc">/**
         * Handle the project tag
         *
         * @param uri The namespace uri.
         * @param name The element tag.
         * @param qname The element qualified name.
         * @param attrs The attributes of the element.
         * @param context The current context.
         * @return The project handler that handles subelements of project
         * @exception SAXParseException if the qualified name is not "project".
         */</comment>
        <function><type><specifier>public</specifier> <name>AntHandler</name></type> <name>onStartChild</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>Attributes</name></type> <name>attrs</name></decl></param>,
                                       <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <if>if <condition>(<expr><call><name><name>name</name>.<name>equals</name></name><argument_list>(<argument><expr>"project"</expr></argument>)</argument_list></call>
                &amp;&amp; (<call><name><name>uri</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call> || <call><name><name>uri</name>.<name>equals</name></name><argument_list>(<argument><expr><name>ANT_CORE_URI</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                <return>return <expr><name><name>ProjectHelper2</name>.<name>projectHandler</name></name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>name</name>.<name>equals</name></name><argument_list>(<argument><expr><name>qname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"Unexpected element \"{" + <name>uri</name>
                                            + "}" + <name>name</name> + "\" {" + <name>ANT_CORE_URI</name> + "}" + <name>name</name></expr></argument>, <argument><expr><call><name><name>context</name>.<name>getLocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"Unexpected element \"" + <name>qname</name>
                                        + "\" " + <name>name</name></expr></argument>, <argument><expr><call><name><name>context</name>.<name>getLocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Handler for the top level "project" element.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>ProjectHandler</name> <super><extends>extends <name>AntHandler</name></extends></super> <block>{

        <comment type="javadoc">/**
         * Initialisation routine called after handler creation
         * with the element name and attributes. The attributes which
         * this handler can deal with are: &lt;code&gt;"default"&lt;/code&gt;,
         * &lt;code&gt;"name"&lt;/code&gt;, &lt;code&gt;"id"&lt;/code&gt; and &lt;code&gt;"basedir"&lt;/code&gt;.
         *
         * @param uri The namespace URI for this element.
         * @param tag Name of the element which caused this handler
         *            to be created. Should not be &lt;code&gt;null&lt;/code&gt;.
         *            Ignored in this implementation.
         * @param qname The qualified name for this element.
         * @param attrs Attributes of the element which caused this
         *              handler to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         * @param context The current context.
         *
         * @exception SAXParseException if an unexpected attribute is
         *            encountered or if the &lt;code&gt;"default"&lt;/code&gt; attribute
         *            is missing.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>onStartElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>Attributes</name></type> <name>attrs</name></decl></param>,
                                   <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>baseDir</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>nameAttributeSet</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Project</name></type> <name>project</name> =<init> <expr><call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// Set the location of the implicit target associated with the project tag</comment>
            <expr_stmt><expr><call><name><name>context</name>.<name>getImplicitTarget</name></name><argument_list>()</argument_list></call>.<call><name>setLocation</name><argument_list>(<argument><expr>new <call><name>Location</name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getLocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="javadoc">/** TODO I really don't like this - the XML processor is still
             * too 'involved' in the processing. A better solution (IMO)
             * would be to create UE for Project and Target too, and
             * then process the tree and have Project/Target deal with
             * its attributes ( similar with Description ).
             *
             * If we eventually switch to ( or add support for ) DOM,
             * things will work smoothly - UE can be avoided almost completely
             * ( it could still be created on demand, for backward compatibility )
             */</comment>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>attrs</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>attrUri</name> =<init> <expr><call><name><name>attrs</name>.<name>getURI</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>attrUri</name> != <name>null</name> &amp;&amp; !<call><name><name>attrUri</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>attrUri</name>.<name>equals</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <continue>continue;</continue> <comment type="line">// Ignore attributes from unknown uris</comment>
                }</block></then></if>
                <decl_stmt><decl><type><name>String</name></type> <name>key</name> =<init> <expr><call><name><name>attrs</name>.<name>getLocalName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>value</name> =<init> <expr><call><name><name>attrs</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"default"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>value</name> != <name>null</name> &amp;&amp; !<call><name><name>value</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr>!<call><name><name>context</name>.<name>isIgnoringProjectTag</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>project</name>.<name>setDefault</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then></if>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"name"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>value</name> != <name>null</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>context</name>.<name>setCurrentProjectName</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>nameAttributeSet</name> = true</expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<call><name><name>context</name>.<name>isIgnoringProjectTag</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>project</name>.<name>setName</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>project</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><call><name>isInIncludeMode</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                            <if>if <condition>(<expr>!"".<call><name>equals</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>getCurrentTargetPrefix</name><argument_list>()</argument_list></call>!= <name>null</name> &amp;&amp; <call><name>getCurrentTargetPrefix</name><argument_list>()</argument_list></call>.<call><name>endsWith</name><argument_list>(<argument><expr><name><name>ProjectHelper</name>.<name>USE_PROJECT_NAME_AS_TARGET_PREFIX</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>  <block>{
                                <decl_stmt><decl><type><name>String</name></type> <name>newTargetPrefix</name> =<init> <expr><call><name>getCurrentTargetPrefix</name><argument_list>()</argument_list></call>.<call><name>replace</name><argument_list>(<argument><expr><name><name>ProjectHelper</name>.<name>USE_PROJECT_NAME_AS_TARGET_PREFIX</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <comment type="line">// help nested include tasks</comment>
                                <expr_stmt><expr><call><name>setCurrentTargetPrefix</name><argument_list>(<argument><expr><name>newTargetPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if>
                        }</block></then></if></else></if>
                    }</block></then></if>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"id"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>value</name> != <name>null</name></expr>)</condition><then> <block>{
                        <comment type="line">// What's the difference between id and name ?</comment>
                        <if>if <condition>(<expr>!<call><name><name>context</name>.<name>isIgnoringProjectTag</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>project</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then></if>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"basedir"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name><name>context</name>.<name>isIgnoringProjectTag</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>baseDir</name> = <name>value</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then> <else>else <block>{
                    <comment type="line">// TODO ignore attributes in a different NS ( maybe store them ? )</comment>
                    <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"Unexpected attribute \"" + <call><name><name>attrs</name>.<name>getQName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>
                                                + "\""</expr></argument>, <argument><expr><call><name><name>context</name>.<name>getLocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></else></if></else></if></else></if></else></if>
            }</block></for>

            <comment type="line">// TODO Move to Project ( so it is shared by all helpers )</comment>
            <decl_stmt><decl><type><name>String</name></type> <name>antFileProp</name> =<init>
                <expr><name><name>MagicNames</name>.<name>ANT_FILE</name></name> + "." + <call><name><name>context</name>.<name>getCurrentProjectName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>dup</name> =<init> <expr><call><name><name>project</name>.<name>getProperty</name></name><argument_list>(<argument><expr><name>antFileProp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>typeProp</name> =<init>
                <expr><name><name>MagicNames</name>.<name>ANT_FILE_TYPE</name></name> + "." + <call><name><name>context</name>.<name>getCurrentProjectName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>dupType</name> =<init> <expr><call><name><name>project</name>.<name>getProperty</name></name><argument_list>(<argument><expr><name>typeProp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>dup</name> != <name>null</name> &amp;&amp; <name>nameAttributeSet</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Object</name></type> <name>dupFile</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Object</name></type> <name>contextFile</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>MagicNames</name>.<name>ANT_FILE_TYPE_URL</name>.<name>equals</name></name><argument_list>(<argument><expr><name>dupType</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <try>try <block>{
                        <expr_stmt><expr><name>dupFile</name> = new <call><name>URL</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> <catch>catch (<param><decl><type><name><name>java</name>.<name>net</name>.<name>MalformedURLException</name></name></type> <name>mue</name></decl></param>) <block>{
                        <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"failed to parse "
                                                 + <name>dup</name> + " as URL while looking"
                                                 + " at a duplicate project"
                                                 + " name."</expr></argument>, <argument><expr><name>mue</name></expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></catch></try>
                    <expr_stmt><expr><name>contextFile</name> = <call><name><name>context</name>.<name>getBuildFileURL</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>dupFile</name> = new <call><name>File</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>contextFile</name> = <call><name><name>context</name>.<name>getBuildFile</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

                <if>if <condition>(<expr><call><name><name>context</name>.<name>isIgnoringProjectTag</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>dupFile</name>.<name>equals</name></name><argument_list>(<argument><expr><name>contextFile</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr>"Duplicated project name in import. Project "
                                + <call><name><name>context</name>.<name>getCurrentProjectName</name></name><argument_list>()</argument_list></call> + " defined first in " + <name>dup</name>
                                + " and again in " + <name>contextFile</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
            <if>if <condition>(<expr><name>nameAttributeSet</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name><name>context</name>.<name>getBuildFile</name></name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>project</name>.<name>setUserProperty</name></name><argument_list>(<argument><expr><name>antFileProp</name></expr></argument>,
                                            <argument><expr><call><name><name>context</name>.<name>getBuildFile</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>project</name>.<name>setUserProperty</name></name><argument_list>(<argument><expr><name>typeProp</name></expr></argument>,
                                            <argument><expr><name><name>MagicNames</name>.<name>ANT_FILE_TYPE_FILE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>context</name>.<name>getBuildFileURL</name></name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>project</name>.<name>setUserProperty</name></name><argument_list>(<argument><expr><name>antFileProp</name></expr></argument>,
                                            <argument><expr><call><name><name>context</name>.<name>getBuildFileURL</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>project</name>.<name>setUserProperty</name></name><argument_list>(<argument><expr><name>typeProp</name></expr></argument>,
                                            <argument><expr><name><name>MagicNames</name>.<name>ANT_FILE_TYPE_URL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></else></if>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>context</name>.<name>isIgnoringProjectTag</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// no further processing</comment>
                <return>return;</return>
            }</block></then></if>
            <comment type="line">// set explicitly before starting ?</comment>
            <if>if <condition>(<expr><call><name><name>project</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"basedir"</expr></argument>)</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>project</name>.<name>setBasedir</name></name><argument_list>(<argument><expr><call><name><name>project</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"basedir"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <comment type="line">// Default for baseDir is the location of the build file.</comment>
                <if>if <condition>(<expr><name>baseDir</name> == <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>project</name>.<name>setBasedir</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getBuildFileParent</name></name><argument_list>()</argument_list></call>.<call><name>getAbsolutePath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <comment type="line">// check whether the user has specified an absolute path</comment>
                    <if>if <condition>(<expr>(new <call><name>File</name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>)</argument_list></call>).<call><name>isAbsolute</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>project</name>.<name>setBasedir</name></name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>project</name>.<name>setBaseDir</name></name><argument_list>(<argument><expr><call><name><name>FILE_UTILS</name>.<name>resolveFile</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getBuildFileParent</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                  <argument><expr><name>baseDir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></else></if>
            }</block></else></if>
            <expr_stmt><expr><call><name><name>project</name>.<name>addTarget</name></name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><call><name><name>context</name>.<name>getImplicitTarget</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>context</name>.<name>setCurrentTarget</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getImplicitTarget</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of a top-level element within the project. An
         * appropriate handler is created and initialised with the details
         * of the element.
         *
         * @param uri The namespace URI for this element.
         * @param name The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param qname The qualified name for this element.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param context The context for this element.
         * @return a target or an element handler.
         *
         * @exception org.xml.sax.SAXParseException if the tag given is not
         *            &lt;code&gt;"taskdef"&lt;/code&gt;, &lt;code&gt;"typedef"&lt;/code&gt;,
         *            &lt;code&gt;"property"&lt;/code&gt;, &lt;code&gt;"target"&lt;/code&gt;,
         *            &lt;code&gt;"extension-point"&lt;/code&gt;
         *            or a data type definition
         */</comment>
        <function><type><specifier>public</specifier> <name>AntHandler</name></type> <name>onStartChild</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>Attributes</name></type> <name>attrs</name></decl></param>,
                                       <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <return>return <expr>(<call><name><name>name</name>.<name>equals</name></name><argument_list>(<argument><expr>"target"</expr></argument>)</argument_list></call> || <call><name><name>name</name>.<name>equals</name></name><argument_list>(<argument><expr>"extension-point"</expr></argument>)</argument_list></call>)
                &amp;&amp; (<call><name><name>uri</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call> || <call><name><name>uri</name>.<name>equals</name></name><argument_list>(<argument><expr><name>ANT_CORE_URI</name></expr></argument>)</argument_list></call>)
                ? <name><name>ProjectHelper2</name>.<name>targetHandler</name></name> : <name><name>ProjectHelper2</name>.<name>elementHandler</name></name></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Handler for "target" and "extension-point" elements.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>TargetHandler</name> <super><extends>extends <name>AntHandler</name></extends></super> <block>{

        <comment type="javadoc">/**
         * Initialisation routine called after handler creation
         * with the element name and attributes. The attributes which
         * this handler can deal with are: &lt;code&gt;"name"&lt;/code&gt;,
         * &lt;code&gt;"depends"&lt;/code&gt;, &lt;code&gt;"if"&lt;/code&gt;,
         * &lt;code&gt;"unless"&lt;/code&gt;, &lt;code&gt;"id"&lt;/code&gt; and
         * &lt;code&gt;"description"&lt;/code&gt;.
         *
         * @param uri The namespace URI for this element.
         * @param tag Name of the element which caused this handler
         *            to be created. Should not be &lt;code&gt;null&lt;/code&gt;.
         *            Ignored in this implementation.
         * @param qname The qualified name for this element.
         * @param attrs Attributes of the element which caused this
         *              handler to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         * @param context The current context.
         *
         * @exception SAXParseException if an unexpected attribute is encountered
         *            or if the &lt;code&gt;"name"&lt;/code&gt; attribute is missing.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>onStartElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>Attributes</name></type> <name>attrs</name></decl></param>,
                                   <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>depends</name> =<init> <expr>""</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>extensionPoint</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>OnMissingExtensionPoint</name></type> <name>extensionPointMissing</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Project</name></type> <name>project</name> =<init> <expr><call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Target</name></type> <name>target</name> =<init> <expr>"target".<call><name>equals</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call>
                ? new <call><name>Target</name><argument_list>()</argument_list></call> : new <call><name>ExtensionPoint</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>target</name>.<name>setProject</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>target</name>.<name>setLocation</name></name><argument_list>(<argument><expr>new <call><name>Location</name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getLocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>context</name>.<name>addTarget</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>attrs</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>attrUri</name> =<init> <expr><call><name><name>attrs</name>.<name>getURI</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>attrUri</name> != <name>null</name> &amp;&amp; !<call><name><name>attrUri</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>attrUri</name>.<name>equals</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <continue>continue;</continue> <comment type="line">// Ignore attributes from unknown uris</comment>
                }</block></then></if>
                <decl_stmt><decl><type><name>String</name></type> <name>key</name> =<init> <expr><call><name><name>attrs</name>.<name>getLocalName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>value</name> =<init> <expr><call><name><name>attrs</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"name"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>name</name> = <name>value</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>"".<call><name>equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"name attribute must " + "not be empty"</expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></then></if>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"depends"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>depends</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"if"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>target</name>.<name>setIf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"unless"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>target</name>.<name>setUnless</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"id"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>value</name> != <name>null</name> &amp;&amp; !<call><name><name>value</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call>.<call><name>addReference</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"description"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>target</name>.<name>setDescription</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"extensionOf"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>extensionPoint</name> = <name>value</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>key</name>.<name>equals</name></name><argument_list>(<argument><expr>"onMissingExtensionPoint"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <try>try <block>{
                        <expr_stmt><expr><name>extensionPointMissing</name> = <call><name><name>OnMissingExtensionPoint</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> <catch>catch (<param><decl><type><name>IllegalArgumentException</name></type> <name>e</name></decl></param>) <block>{
                        <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Invalid onMissingExtensionPoint " + <name>value</name></expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></catch></try>
                }</block></then> <else>else <block>{
                    <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"Unexpected attribute \"" + <name>key</name> + "\""</expr></argument>, <argument><expr><call><name><name>context</name>
                                                .<name>getLocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
            }</block></for>

            <if>if <condition>(<expr><name>name</name> == <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>SAXParseException</name><argument_list>(<argument><expr>"target element appears without a name attribute"</expr></argument>,
                                            <argument><expr><call><name><name>context</name>.<name>getLocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>

            <decl_stmt><decl><type><name>String</name></type> <name>prefix</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>isInIncludeMode</name> =<init>
                <expr><call><name><name>context</name>.<name>isIgnoringProjectTag</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>isInIncludeMode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>sep</name> =<init> <expr><call><name>getCurrentPrefixSeparator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>isInIncludeMode</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>prefix</name> = <call><name>getTargetPrefix</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>prefix</name> == <name>null</name></expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"can't include build file "
                                             + <call><name><name>context</name>.<name>getBuildFileURL</name></name><argument_list>()</argument_list></call>
                                             + ", no as attribute has been given"
                                             + " and the project tag doesn't"
                                             + " specify a name attribute"</expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <expr_stmt><expr><name>name</name> = <name>prefix</name> + <name>sep</name> + <name>name</name></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// Check if this target is in the current build file</comment>
            <if>if <condition>(<expr><call><name><name>context</name>.<name>getCurrentTargets</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Duplicate target '" + <name>name</name> + "'"</expr></argument>,
                                         <argument><expr><call><name><name>target</name>.<name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <decl_stmt><decl><type><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Target</name></argument>&gt;</argument_list></name></type> <name>projectTargets</name> =<init> <expr><call><name><name>project</name>.<name>getTargets</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type>   <name>usedTarget</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
            <comment type="line">// If the name has not already been defined define it</comment>
            <if>if <condition>(<expr><call><name><name>projectTargets</name>.<name>containsKey</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr>"Already defined in main or a previous import, ignore " + <name>name</name></expr></argument>,
                            <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>target</name>.<name>setName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>context</name>.<name>getCurrentTargets</name></name><argument_list>()</argument_list></call>.<call><name>put</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>project</name>.<name>addOrReplaceTarget</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>usedTarget</name> = true</expr>;</expr_stmt>
            }</block></else></if>

            <if>if <condition>(<expr><call><name><name>depends</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<name>isInIncludeMode</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>target</name>.<name>setDepends</name></name><argument_list>(<argument><expr><name>depends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <for>for (<init><decl><type><name>String</name></type> <name>string</name> :<range> <expr><call><name><name>Target</name>.<name>parseDepends</name></name><argument_list>(<argument><expr><name>depends</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>"depends"</expr></argument>)</argument_list></call></expr></range></decl></init>) <block>{
                        <expr_stmt><expr><call><name><name>target</name>.<name>addDependency</name></name><argument_list>(<argument><expr><name>prefix</name> + <name>sep</name> + <name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                   }</block></for>
                }</block></else></if>
            }</block></then></if>
            <if>if <condition>(<expr>!<name>isInIncludeMode</name> &amp;&amp; <call><name><name>context</name>.<name>isIgnoringProjectTag</name></name><argument_list>()</argument_list></call>
                &amp;&amp; (<name>prefix</name> = <call><name>getTargetPrefix</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
                <comment type="line">// In an imported file (and not completely</comment>
                <comment type="line">// ignoring the project tag or having a preconfigured prefix)</comment>
                <decl_stmt><decl><type><name>String</name></type> <name>newName</name> =<init> <expr><name>prefix</name> + <name>sep</name> + <name>name</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Target</name></type> <name>newTarget</name> =<init> <expr><name>target</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>usedTarget</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>newTarget</name> = "target".<call><name>equals</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call>
                            ? new <call><name>Target</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> : new <call><name>ExtensionPoint</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>newTarget</name>.<name>setName</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>context</name>.<name>getCurrentTargets</name></name><argument_list>()</argument_list></call>.<call><name>put</name><argument_list>(<argument><expr><name>newName</name></expr></argument>, <argument><expr><name>newTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>project</name>.<name>addOrReplaceTarget</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>, <argument><expr><name>newTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>extensionPointMissing</name> != <name>null</name> &amp;&amp; <name>extensionPoint</name> == <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"onMissingExtensionPoint attribute cannot " +
                                         "be specified unless extensionOf is specified"</expr></argument>,
                                         <argument><expr><call><name><name>target</name>.<name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>

            }</block></then></if>
            <if>if <condition>(<expr><name>extensionPoint</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>ProjectHelper</name></type> <name>helper</name> =<init>
                    <expr>(<name>ProjectHelper</name>) <call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call>.
                    <call><name>getReference</name><argument_list>(<argument><expr><name><name>ProjectHelper</name>.<name>PROJECTHELPER_REFERENCE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>String</name></type> <name>extPointName</name> :<range> <expr><call><name><name>Target</name>.<name>parseDepends</name></name><argument_list>(<argument><expr><name>extensionPoint</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>"extensionOf"</expr></argument>)</argument_list></call></expr></range></decl></init>) <block>{
                    <if>if <condition>(<expr><name>extensionPointMissing</name> == <name>null</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>extensionPointMissing</name> = <name><name>OnMissingExtensionPoint</name>.<name>FAIL</name></name></expr>;</expr_stmt>
                    }</block></then></if>
                    <comment type="line">// defer extensionpoint resolution until the full</comment>
                    <comment type="line">// import stack has been processed</comment>
                    <if>if <condition>(<expr><call><name>isInIncludeMode</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="line">// if in include mode, provide prefix we're including by</comment>
                        <comment type="line">// so that we can try and resolve extension point from</comment>
                        <comment type="line">// the local file first</comment>
                        <expr_stmt><expr><call><name><name>helper</name>.<name>getExtensionStack</name></name><argument_list>()</argument_list></call>.<call><name>add</name><argument_list>(
                                <argument><expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><name>extPointName</name></expr>, <expr><call><name><name>target</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr>,
                                        <expr><call><name><name>extensionPointMissing</name>.<name>name</name></name><argument_list>()</argument_list></call></expr>, <expr><name>prefix</name> + <name>sep</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>helper</name>.<name>getExtensionStack</name></name><argument_list>()</argument_list></call>.<call><name>add</name><argument_list>(
                                <argument><expr>new <name><name>String</name><index>[]</index></name> <block>{<expr><name>extPointName</name></expr>, <expr><call><name><name>target</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr>,
                                        <expr><call><name><name>extensionPointMissing</name>.<name>name</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></for>
            }</block></then></if>
        }</block></function>

        <function><type><specifier>private</specifier> <name>String</name></type> <name>getTargetPrefix</name><parameter_list>(<param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>configuredValue</name> =<init> <expr><call><name>getCurrentTargetPrefix</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>configuredValue</name> != <name>null</name> &amp;&amp; <call><name><name>configuredValue</name>.<name>length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>configuredValue</name> = <name>null</name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>configuredValue</name> != <name>null</name></expr>)</condition><then> <block>{
                <return>return <expr><name>configuredValue</name></expr>;</return>
            }</block></then></if>

            <decl_stmt><decl><type><name>String</name></type> <name>projectName</name> =<init> <expr><call><name><name>context</name>.<name>getCurrentProjectName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>"".<call><name>equals</name><argument_list>(<argument><expr><name>projectName</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>projectName</name> = <name>null</name></expr>;</expr_stmt>
            }</block></then></if>

            <return>return <expr><name>projectName</name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of an element within a target.
         *
         * @param uri The namespace URI for this element.
         * @param name The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param qname The qualified name for this element.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param context The current context.
         * @return an element handler.
         *
         * @exception SAXParseException if an error occurs when initialising
         *                              the appropriate child handler
         */</comment>
        <function><type><specifier>public</specifier> <name>AntHandler</name></type> <name>onStartChild</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>Attributes</name></type> <name>attrs</name></decl></param>,
                                       <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <return>return <expr><name><name>ProjectHelper2</name>.<name>elementHandler</name></name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Handle the end of the project, sets the current target of the
         * context to be the implicit target.
         *
         * @param uri The namespace URI of the element.
         * @param tag The name of the element.
         * @param context The current context.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>onEndElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>context</name>.<name>setCurrentTarget</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getImplicitTarget</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Handler for all project elements ( tasks, data types )
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>ElementHandler</name> <super><extends>extends <name>AntHandler</name></extends></super> <block>{

        <comment type="javadoc">/**
         * Constructor.
         */</comment>
        <constructor><specifier>public</specifier> <name>ElementHandler</name><parameter_list>()</parameter_list> <block>{
        }</block></constructor>

        <comment type="javadoc">/**
         * Initialisation routine called after handler creation
         * with the element name and attributes. This configures
         * the element with its attributes and sets it up with
         * its parent container (if any). Nested elements are then
         * added later as the parser encounters them.
         *
         * @param uri The namespace URI for this element.
         * @param tag Name of the element which caused this handler
         *            to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         * @param qname The qualified name for this element.
         * @param attrs Attributes of the element which caused this
         *              handler to be created. Must not be &lt;code&gt;null&lt;/code&gt;.
         * @param context The current context.
         *
         * @exception SAXParseException in case of error (not thrown in
         *                              this implementation)
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>onStartElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>Attributes</name></type> <name>attrs</name></decl></param>,
                                   <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name>RuntimeConfigurable</name></type> <name>parentWrapper</name> =<init> <expr><call><name><name>context</name>.<name>currentWrapper</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Object</name></type> <name>parent</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>parentWrapper</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>parent</name> = <call><name><name>parentWrapper</name>.<name>getProxy</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* UnknownElement is used for tasks and data types - with
               delayed eval */</comment>
            <decl_stmt><decl><type><name>UnknownElement</name></type> <name>task</name> =<init> <expr>new <call><name>UnknownElement</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setProject</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getProject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setNamespace</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setQName</name></name><argument_list>(<argument><expr><name>qname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setTaskType</name></name><argument_list>(<argument><expr><call><name><name>ProjectHelper</name>.<name>genComponentName</name></name><argument_list>(<argument><expr><call><name><name>task</name>.<name>getNamespace</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setTaskName</name></name><argument_list>(<argument><expr><name>qname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Location</name></type> <name>location</name> =<init> <expr>new <call><name>Location</name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getLocator</name></name><argument_list>()</argument_list></call>.<call><name>getSystemId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>context</name>
                                             .<name>getLocator</name></name><argument_list>()</argument_list></call>.<call><name>getLineNumber</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>context</name>.<name>getLocator</name></name><argument_list>()</argument_list></call>.<call><name>getColumnNumber</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setLocation</name></name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>task</name>.<name>setOwningTarget</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getCurrentTarget</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>parent</name> != <name>null</name></expr>)</condition><then> <block>{
                <comment type="line">// Nested element</comment>
                <expr_stmt><expr>((<name>UnknownElement</name>) <name>parent</name>).<call><name>addChild</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>  <else>else <block>{
                <comment type="line">// Task included in a target ( including the default one ).</comment>
                <expr_stmt><expr><call><name><name>context</name>.<name>getCurrentTarget</name></name><argument_list>()</argument_list></call>.<call><name>addTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><call><name><name>context</name>.<name>configureId</name></name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// container.addTask(task);</comment>
            <comment type="line">// This is a nop in UE: task.init();</comment>

            <decl_stmt><decl><type><name>RuntimeConfigurable</name></type> <name>wrapper</name> =<init> <expr>new <call><name>RuntimeConfigurable</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><call><name><name>task</name>.<name>getTaskName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>attrs</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>name</name> =<init> <expr><call><name><name>attrs</name>.<name>getLocalName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>attrUri</name> =<init> <expr><call><name><name>attrs</name>.<name>getURI</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>attrUri</name> != <name>null</name> &amp;&amp; !<call><name><name>attrUri</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>attrUri</name>.<name>equals</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>name</name> = <name>attrUri</name> + ":" + <call><name><name>attrs</name>.<name>getQName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <decl_stmt><decl><type><name>String</name></type> <name>value</name> =<init> <expr><call><name><name>attrs</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// PR: Hack for ant-type value</comment>
                <comment type="line">//  an ant-type is a component name which can</comment>
                <comment type="line">// be namespaced, need to extract the name</comment>
                <comment type="line">// and convert from qualified name to uri/name</comment>
                <if>if <condition>(<expr><call><name><name>ANT_TYPE</name>.<name>equals</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>
                    || (<call><name><name>ANT_CORE_URI</name>.<name>equals</name></name><argument_list>(<argument><expr><name>attrUri</name></expr></argument>)</argument_list></call>
                        &amp;&amp; <call><name><name>ANT_TYPE</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>attrs</name>.<name>getLocalName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>name</name> = <name>ANT_TYPE</name></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>index</name> =<init> <expr><call><name><name>value</name>.<name>indexOf</name></name><argument_list>(<argument><expr>":"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>index</name> &gt;= 0</expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>String</name></type> <name>prefix</name> =<init> <expr><call><name><name>value</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>String</name></type> <name>mappedUri</name> =<init> <expr><call><name><name>context</name>.<name>getPrefixMapping</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>mappedUri</name> == <name>null</name></expr>)</condition><then> <block>{
                            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Unable to find XML NS prefix \"" + <name>prefix</name>
                                                     + "\""</expr></argument>)</argument_list></call></expr>;</throw>
                        }</block></then></if>
                        <expr_stmt><expr><name>value</name> = <call><name><name>ProjectHelper</name>.<name>genComponentName</name></name><argument_list>(<argument><expr><name>mappedUri</name></expr></argument>, <argument><expr><call><name><name>value</name>
                                                               .<name>substring</name></name><argument_list>(<argument><expr><name>index</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>wrapper</name>.<name>setAttribute</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <if>if <condition>(<expr><name>parentWrapper</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>parentWrapper</name>.<name>addChild</name></name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>context</name>.<name>pushWrapper</name></name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Adds text to the task, using the wrapper
         *
         * @param buf A character array of the text within the element.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param start The start element in the array.
         * @param count The number of characters to read from the array.
         * @param context The current context.
         *
         * @exception SAXParseException if the element doesn't support text
         *
         * @see ProjectHelper#addText(Project,java.lang.Object,char[],int,int)
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>characters</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>,
                               <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <decl_stmt><decl><type><name>RuntimeConfigurable</name></type> <name>wrapper</name> =<init> <expr><call><name><name>context</name>.<name>currentWrapper</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>wrapper</name>.<name>addText</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the start of an element within a target. Task containers
         * will always use another task handler, and all other tasks
         * will always use a nested element handler.
         *
         * @param uri The namespace URI for this element.
         * @param tag The name of the element being started.
         *            Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param qname The qualified name for this element.
         * @param attrs Attributes of the element being started.
         *              Will not be &lt;code&gt;null&lt;/code&gt;.
         * @param context The current context.
         * @return The handler for elements.
         *
         * @exception SAXParseException if an error occurs when initialising
         *                              the appropriate child handler
         */</comment>
        <function><type><specifier>public</specifier> <name>AntHandler</name></type> <name>onStartChild</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name></type> <name>qname</name></decl></param>, <param><decl><type><name>Attributes</name></type> <name>attrs</name></decl></param>,
                                       <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>SAXParseException</name></expr></argument></throws> <block>{
            <return>return <expr><name><name>ProjectHelper2</name>.<name>elementHandler</name></name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Handles the end of the element. This pops the wrapper from
         * the context.
         *
         * @param uri The namespace URI for the element.
         * @param tag The name of the element.
         * @param context The current context.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>onEndElement</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>AntXMLContext</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>context</name>.<name>popWrapper</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>
}</block></class>
</unit>
