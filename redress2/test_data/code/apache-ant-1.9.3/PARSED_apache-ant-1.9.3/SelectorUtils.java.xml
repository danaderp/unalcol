<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\types\selectors\SelectorUtils.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>selectors</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>StringTokenizer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Resource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileUtils</name></name>;</import>

<comment type="javadoc">/**
 * &lt;p&gt;This is a utility class used by selectors and DirectoryScanner. The
 * functionality more properly belongs just to selectors, but unfortunately
 * DirectoryScanner exposed these as protected methods. Thus we have to
 * support any subclasses of DirectoryScanner that may access these methods.
 * &lt;/p&gt;
 * &lt;p&gt;This is a Singleton.&lt;/p&gt;
 *
 * @since 1.5
 */</comment>
<class><specifier>public</specifier> <specifier>final</specifier> class <name>SelectorUtils</name> <block>{

    <comment type="javadoc">/**
     * The pattern that matches an arbitrary number of directories.
     * @since Ant 1.8.0
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>DEEP_TREE_MATCH</name> =<init> <expr>"**"</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>SelectorUtils</name></type> <name>instance</name> =<init> <expr>new <call><name>SelectorUtils</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>FileUtils</name></type> <name>FILE_UTILS</name> =<init> <expr><call><name><name>FileUtils</name>.<name>getFileUtils</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Private Constructor
     */</comment>
    <constructor><specifier>private</specifier> <name>SelectorUtils</name><parameter_list>()</parameter_list> <block>{
    }</block></constructor>

    <comment type="javadoc">/**
     * Retrieves the instance of the Singleton.
     * @return singleton instance
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>SelectorUtils</name></type> <name>getInstance</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>instance</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests whether or not a given path matches the start of a given
     * pattern up to the first "**".
     * &lt;p&gt;
     * This is not a general purpose test and should only be used if you
     * can live with false positives. For example, &lt;code&gt;pattern=**\a&lt;/code&gt;
     * and &lt;code&gt;str=b&lt;/code&gt; will yield &lt;code&gt;true&lt;/code&gt;.
     *
     * @param pattern The pattern to match against. Must not be
     *                &lt;code&gt;null&lt;/code&gt;.
     * @param str     The path to match, as a String. Must not be
     *                &lt;code&gt;null&lt;/code&gt;.
     *
     * @return whether or not a given path matches the start of a given
     * pattern up to the first "**".
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>matchPatternStart</name><parameter_list>(<param><decl><type><name>String</name></type> <name>pattern</name></decl></param>, <param><decl><type><name>String</name></type> <name>str</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>matchPatternStart</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests whether or not a given path matches the start of a given
     * pattern up to the first "**".
     * &lt;p&gt;
     * This is not a general purpose test and should only be used if you
     * can live with false positives. For example, &lt;code&gt;pattern=**\a&lt;/code&gt;
     * and &lt;code&gt;str=b&lt;/code&gt; will yield &lt;code&gt;true&lt;/code&gt;.
     *
     * @param pattern The pattern to match against. Must not be
     *                &lt;code&gt;null&lt;/code&gt;.
     * @param str     The path to match, as a String. Must not be
     *                &lt;code&gt;null&lt;/code&gt;.
     * @param isCaseSensitive Whether or not matching should be performed
     *                        case sensitively.
     *
     * @return whether or not a given path matches the start of a given
     * pattern up to the first "**".
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>matchPatternStart</name><parameter_list>(<param><decl><type><name>String</name></type> <name>pattern</name></decl></param>, <param><decl><type><name>String</name></type> <name>str</name></decl></param>,
                                            <param><decl><type><name>boolean</name></type> <name>isCaseSensitive</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// When str starts with a File.separator, pattern has to start with a</comment>
        <comment type="line">// File.separator.</comment>
        <comment type="line">// When pattern starts with a File.separator, str has to start with a</comment>
        <comment type="line">// File.separator.</comment>
        <if>if <condition>(<expr><call><name><name>str</name>.<name>startsWith</name></name><argument_list>(<argument><expr><name><name>File</name>.<name>separator</name></name></expr></argument>)</argument_list></call>
                != <call><name><name>pattern</name>.<name>startsWith</name></name><argument_list>(<argument><expr><name><name>File</name>.<name>separator</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>patDirs</name> =<init> <expr><call><name>tokenizePathAsArray</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>strDirs</name> =<init> <expr><call><name>tokenizePathAsArray</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>matchPatternStart</name><argument_list>(<argument><expr><name>patDirs</name></expr></argument>, <argument><expr><name>strDirs</name></expr></argument>, <argument><expr><name>isCaseSensitive</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Tests whether or not a given path matches the start of a given
     * pattern up to the first "**".
     * &lt;p&gt;
     * This is not a general purpose test and should only be used if you
     * can live with false positives. For example, &lt;code&gt;pattern=**\a&lt;/code&gt;
     * and &lt;code&gt;str=b&lt;/code&gt; will yield &lt;code&gt;true&lt;/code&gt;.
     *
     * @param patDirs The tokenized pattern to match against. Must not be
     *                &lt;code&gt;null&lt;/code&gt;.
     * @param strDirs The tokenized path to match. Must not be
     *                &lt;code&gt;null&lt;/code&gt;.
     * @param isCaseSensitive Whether or not matching should be performed
     *                        case sensitively.
     *
     * @return whether or not a given path matches the start of a given
     * pattern up to the first "**".
     */</comment>
    <function><type><specifier>static</specifier> <name>boolean</name></type> <name>matchPatternStart</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>patDirs</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>strDirs</name></decl></param>,
                                     <param><decl><type><name>boolean</name></type> <name>isCaseSensitive</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>patIdxStart</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>patIdxEnd</name> =<init> <expr><name><name>patDirs</name>.<name>length</name></name> - 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>strIdxStart</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>strIdxEnd</name> =<init> <expr><name><name>strDirs</name>.<name>length</name></name> - 1</expr></init></decl>;</decl_stmt>

        <comment type="line">// up to first '**'</comment>
        <while>while <condition>(<expr><name>patIdxStart</name> &lt;= <name>patIdxEnd</name> &amp;&amp; <name>strIdxStart</name> &lt;= <name>strIdxEnd</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>patDir</name> =<init> <expr><name><name>patDirs</name><index>[<expr><name>patIdxStart</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>patDir</name>.<name>equals</name></name><argument_list>(<argument><expr><name>DEEP_TREE_MATCH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>match</name><argument_list>(<argument><expr><name>patDir</name></expr></argument>, <argument><expr><name><name>strDirs</name><index>[<expr><name>strIdxStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>isCaseSensitive</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>patIdxStart</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>strIdxStart</name>++</expr>;</expr_stmt>
        }</block></while>

        <comment type="line">// CheckStyle:SimplifyBooleanReturnCheck OFF</comment>
        <comment type="line">// Check turned off as the code needs the comments for the various</comment>
        <comment type="line">// code paths.</comment>
        <if>if <condition>(<expr><name>strIdxStart</name> &gt; <name>strIdxEnd</name></expr>)</condition><then> <block>{
            <comment type="line">// String is exhausted</comment>
            <return>return <expr>true</expr>;</return>
        }</block></then> <else>else <if>if <condition>(<expr><name>patIdxStart</name> &gt; <name>patIdxEnd</name></expr>)</condition><then> <block>{
            <comment type="line">// String not exhausted, but pattern is. Failure.</comment>
            <return>return <expr>false</expr>;</return>
        }</block></then> <else>else <block>{
            <comment type="line">// pattern now holds ** while string is not exhausted</comment>
            <comment type="line">// this will generate false positives but we can live with that.</comment>
            <return>return <expr>true</expr>;</return>
        }</block></else></if></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Tests whether or not a given path matches a given pattern.
     *
     * If you need to call this method multiple times with the same
     * pattern you should rather use TokenizedPath
     *
     * @see TokenizedPath
     *
     * @param pattern The pattern to match against. Must not be
     *                &lt;code&gt;null&lt;/code&gt;.
     * @param str     The path to match, as a String. Must not be
     *                &lt;code&gt;null&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the pattern matches against the string,
     *         or &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>matchPath</name><parameter_list>(<param><decl><type><name>String</name></type> <name>pattern</name></decl></param>, <param><decl><type><name>String</name></type> <name>str</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>patDirs</name> =<init> <expr><call><name>tokenizePathAsArray</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>matchPath</name><argument_list>(<argument><expr><name>patDirs</name></expr></argument>, <argument><expr><call><name>tokenizePathAsArray</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests whether or not a given path matches a given pattern.
     *
     * If you need to call this method multiple times with the same
     * pattern you should rather use TokenizedPattern
     *
     * @see TokenizedPattern
     *
     * @param pattern The pattern to match against. Must not be
     *                &lt;code&gt;null&lt;/code&gt;.
     * @param str     The path to match, as a String. Must not be
     *                &lt;code&gt;null&lt;/code&gt;.
     * @param isCaseSensitive Whether or not matching should be performed
     *                        case sensitively.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the pattern matches against the string,
     *         or &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>matchPath</name><parameter_list>(<param><decl><type><name>String</name></type> <name>pattern</name></decl></param>, <param><decl><type><name>String</name></type> <name>str</name></decl></param>,
                                    <param><decl><type><name>boolean</name></type> <name>isCaseSensitive</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>patDirs</name> =<init> <expr><call><name>tokenizePathAsArray</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>matchPath</name><argument_list>(<argument><expr><name>patDirs</name></expr></argument>, <argument><expr><call><name>tokenizePathAsArray</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>isCaseSensitive</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Core implementation of matchPath.  It is isolated so that it
     * can be called from TokenizedPattern.
     */</comment>
    <function><type><specifier>static</specifier> <name>boolean</name></type> <name>matchPath</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>tokenizedPattern</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>strDirs</name></decl></param>,
                             <param><decl><type><name>boolean</name></type> <name>isCaseSensitive</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>patIdxStart</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>patIdxEnd</name> =<init> <expr><name><name>tokenizedPattern</name>.<name>length</name></name> - 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>strIdxStart</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>strIdxEnd</name> =<init> <expr><name><name>strDirs</name>.<name>length</name></name> - 1</expr></init></decl>;</decl_stmt>

        <comment type="line">// up to first '**'</comment>
        <while>while <condition>(<expr><name>patIdxStart</name> &lt;= <name>patIdxEnd</name> &amp;&amp; <name>strIdxStart</name> &lt;= <name>strIdxEnd</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>patDir</name> =<init> <expr><name><name>tokenizedPattern</name><index>[<expr><name>patIdxStart</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>patDir</name>.<name>equals</name></name><argument_list>(<argument><expr><name>DEEP_TREE_MATCH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>match</name><argument_list>(<argument><expr><name>patDir</name></expr></argument>, <argument><expr><name><name>strDirs</name><index>[<expr><name>strIdxStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>isCaseSensitive</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>patIdxStart</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>strIdxStart</name>++</expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>strIdxStart</name> &gt; <name>strIdxEnd</name></expr>)</condition><then> <block>{
            <comment type="line">// String is exhausted</comment>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>patIdxStart</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>patIdxEnd</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr>!<name><name>tokenizedPattern</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>equals</name><argument_list>(<argument><expr><name>DEEP_TREE_MATCH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr>false</expr>;</return>
                }</block></then></if>
            }</block></for>
            <return>return <expr>true</expr>;</return>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>patIdxStart</name> &gt; <name>patIdxEnd</name></expr>)</condition><then> <block>{
                <comment type="line">// String not exhausted, but pattern is. Failure.</comment>
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
        }</block></else></if>

        <comment type="line">// up to last '**'</comment>
        <while>while <condition>(<expr><name>patIdxStart</name> &lt;= <name>patIdxEnd</name> &amp;&amp; <name>strIdxStart</name> &lt;= <name>strIdxEnd</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>patDir</name> =<init> <expr><name><name>tokenizedPattern</name><index>[<expr><name>patIdxEnd</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>patDir</name>.<name>equals</name></name><argument_list>(<argument><expr><name>DEEP_TREE_MATCH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>match</name><argument_list>(<argument><expr><name>patDir</name></expr></argument>, <argument><expr><name><name>strDirs</name><index>[<expr><name>strIdxEnd</name></expr>]</index></name></expr></argument>, <argument><expr><name>isCaseSensitive</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>patIdxEnd</name>--</expr>;</expr_stmt>
            <expr_stmt><expr><name>strIdxEnd</name>--</expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>strIdxStart</name> &gt; <name>strIdxEnd</name></expr>)</condition><then> <block>{
            <comment type="line">// String is exhausted</comment>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>patIdxStart</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>patIdxEnd</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr>!<name><name>tokenizedPattern</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>equals</name><argument_list>(<argument><expr><name>DEEP_TREE_MATCH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr>false</expr>;</return>
                }</block></then></if>
            }</block></for>
            <return>return <expr>true</expr>;</return>
        }</block></then></if>

        <while>while <condition>(<expr><name>patIdxStart</name> != <name>patIdxEnd</name> &amp;&amp; <name>strIdxStart</name> &lt;= <name>strIdxEnd</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>patIdxTmp</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>patIdxStart</name> + 1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>patIdxEnd</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>tokenizedPattern</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>equals</name><argument_list>(<argument><expr><name>DEEP_TREE_MATCH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>patIdxTmp</name> = <name>i</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>patIdxTmp</name> == <name>patIdxStart</name> + 1</expr>)</condition><then> <block>{
                <comment type="line">// '**/**' situation, so skip one</comment>
                <expr_stmt><expr><name>patIdxStart</name>++</expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <comment type="line">// Find the pattern between padIdxStart &amp; padIdxTmp in str between</comment>
            <comment type="line">// strIdxStart &amp; strIdxEnd</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>patLength</name> =<init> <expr>(<name>patIdxTmp</name> - <name>patIdxStart</name> - 1)</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>strLength</name> =<init> <expr>(<name>strIdxEnd</name> - <name>strIdxStart</name> + 1)</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>foundIdx</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
            <label><name>strLoop</name>:</label>
                        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>strLength</name> - <name>patLength</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>patLength</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                                <decl_stmt><decl><type><name>String</name></type> <name>subPat</name> =<init> <expr><name><name>tokenizedPattern</name><index>[<expr><name>patIdxStart</name> + <name>j</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name>String</name></type> <name>subStr</name> =<init> <expr><name><name>strDirs</name><index>[<expr><name>strIdxStart</name> + <name>i</name> + <name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                                <if>if <condition>(<expr>!<call><name>match</name><argument_list>(<argument><expr><name>subPat</name></expr></argument>, <argument><expr><name>subStr</name></expr></argument>, <argument><expr><name>isCaseSensitive</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                                    <continue>continue strLoop;</continue>
                                }</block></then></if>
                            }</block></for>

                            <expr_stmt><expr><name>foundIdx</name> = <name>strIdxStart</name> + <name>i</name></expr>;</expr_stmt>
                            <break>break;</break>
                        }</block></for>

            <if>if <condition>(<expr><name>foundIdx</name> == -1</expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>patIdxStart</name> = <name>patIdxTmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>strIdxStart</name> = <name>foundIdx</name> + <name>patLength</name></expr>;</expr_stmt>
        }</block></while>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>patIdxStart</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>patIdxEnd</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>!<name><name>tokenizedPattern</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>equals</name><argument_list>(<argument><expr><name>DEEP_TREE_MATCH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
        }</block></for>

        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests whether or not a string matches against a pattern.
     * The pattern may contain two special characters:&lt;br&gt;
     * '*' means zero or more characters&lt;br&gt;
     * '?' means one and only one character
     *
     * @param pattern The pattern to match against.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param str     The string which must be matched against the pattern.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the string matches against the pattern,
     *         or &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>match</name><parameter_list>(<param><decl><type><name>String</name></type> <name>pattern</name></decl></param>, <param><decl><type><name>String</name></type> <name>str</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>match</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests whether or not a string matches against a pattern.
     * The pattern may contain two special characters:&lt;br&gt;
     * '*' means zero or more characters&lt;br&gt;
     * '?' means one and only one character
     *
     * @param pattern The pattern to match against.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param str     The string which must be matched against the pattern.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param caseSensitive Whether or not matching should be performed
     *                        case sensitively.
     *
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the string matches against the pattern,
     *         or &lt;code&gt;false&lt;/code&gt; otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>match</name><parameter_list>(<param><decl><type><name>String</name></type> <name>pattern</name></decl></param>, <param><decl><type><name>String</name></type> <name>str</name></decl></param>,
                                <param><decl><type><name>boolean</name></type> <name>caseSensitive</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>char</name><index>[]</index></type> <name>patArr</name> =<init> <expr><call><name><name>pattern</name>.<name>toCharArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name><index>[]</index></type> <name>strArr</name> =<init> <expr><call><name><name>str</name>.<name>toCharArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>patIdxStart</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>patIdxEnd</name> =<init> <expr><name><name>patArr</name>.<name>length</name></name> - 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>strIdxStart</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>strIdxEnd</name> =<init> <expr><name><name>strArr</name>.<name>length</name></name> - 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>boolean</name></type> <name>containsStar</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>patArr</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>patArr</name><index>[<expr><name>i</name></expr>]</index></name> == '*'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>containsStar</name> = true</expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>

        <if>if <condition>(<expr>!<name>containsStar</name></expr>)</condition><then> <block>{
            <comment type="line">// No '*'s, so we make a shortcut</comment>
            <if>if <condition>(<expr><name>patIdxEnd</name> != <name>strIdxEnd</name></expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return> <comment type="line">// Pattern and string do not have the same size</comment>
            }</block></then></if>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>patIdxEnd</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name>ch</name> = <name><name>patArr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>ch</name> != '?'</expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name>different</name><argument_list>(<argument><expr><name>caseSensitive</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name><name>strArr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <return>return <expr>false</expr>;</return> <comment type="line">// Character mismatch</comment>
                    }</block></then></if>
                }</block></then></if>
            }</block></for>
            <return>return <expr>true</expr>;</return> <comment type="line">// String matches against pattern</comment>
        }</block></then></if>

        <if>if <condition>(<expr><name>patIdxEnd</name> == 0</expr>)</condition><then> <block>{
            <return>return <expr>true</expr>;</return> <comment type="line">// Pattern contains only '*', which matches anything</comment>
        }</block></then></if>

        <comment type="line">// Process characters before first star</comment>
        <while>while <condition>(<expr>true</expr>)</condition> <block>{
            <expr_stmt><expr><name>ch</name> = <name><name>patArr</name><index>[<expr><name>patIdxStart</name></expr>]</index></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ch</name> == '*' || <name>strIdxStart</name> &gt; <name>strIdxEnd</name></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><name>ch</name> != '?'</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>different</name><argument_list>(<argument><expr><name>caseSensitive</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name><name>strArr</name><index>[<expr><name>strIdxStart</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr>false</expr>;</return> <comment type="line">// Character mismatch</comment>
                }</block></then></if>
            }</block></then></if>
            <expr_stmt><expr><name>patIdxStart</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>strIdxStart</name>++</expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>strIdxStart</name> &gt; <name>strIdxEnd</name></expr>)</condition><then> <block>{
            <comment type="line">// All characters in the string are used. Check if only '*'s are</comment>
            <comment type="line">// left in the pattern. If so, we succeeded. Otherwise failure.</comment>
            <return>return <expr><call><name>allStars</name><argument_list>(<argument><expr><name>patArr</name></expr></argument>, <argument><expr><name>patIdxStart</name></expr></argument>, <argument><expr><name>patIdxEnd</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="line">// Process characters after last star</comment>
        <while>while <condition>(<expr>true</expr>)</condition> <block>{
            <expr_stmt><expr><name>ch</name> = <name><name>patArr</name><index>[<expr><name>patIdxEnd</name></expr>]</index></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ch</name> == '*' || <name>strIdxStart</name> &gt; <name>strIdxEnd</name></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><name>ch</name> != '?'</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>different</name><argument_list>(<argument><expr><name>caseSensitive</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name><name>strArr</name><index>[<expr><name>strIdxEnd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr>false</expr>;</return> <comment type="line">// Character mismatch</comment>
                }</block></then></if>
            }</block></then></if>
            <expr_stmt><expr><name>patIdxEnd</name>--</expr>;</expr_stmt>
            <expr_stmt><expr><name>strIdxEnd</name>--</expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>strIdxStart</name> &gt; <name>strIdxEnd</name></expr>)</condition><then> <block>{
            <comment type="line">// All characters in the string are used. Check if only '*'s are</comment>
            <comment type="line">// left in the pattern. If so, we succeeded. Otherwise failure.</comment>
            <return>return <expr><call><name>allStars</name><argument_list>(<argument><expr><name>patArr</name></expr></argument>, <argument><expr><name>patIdxStart</name></expr></argument>, <argument><expr><name>patIdxEnd</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="line">// process pattern between stars. padIdxStart and patIdxEnd point</comment>
        <comment type="line">// always to a '*'.</comment>
        <while>while <condition>(<expr><name>patIdxStart</name> != <name>patIdxEnd</name> &amp;&amp; <name>strIdxStart</name> &lt;= <name>strIdxEnd</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>patIdxTmp</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>patIdxStart</name> + 1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>patIdxEnd</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>patArr</name><index>[<expr><name>i</name></expr>]</index></name> == '*'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>patIdxTmp</name> = <name>i</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>patIdxTmp</name> == <name>patIdxStart</name> + 1</expr>)</condition><then> <block>{
                <comment type="line">// Two stars next to each other, skip the first one.</comment>
                <expr_stmt><expr><name>patIdxStart</name>++</expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <comment type="line">// Find the pattern between padIdxStart &amp; padIdxTmp in str between</comment>
            <comment type="line">// strIdxStart &amp; strIdxEnd</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>patLength</name> =<init> <expr>(<name>patIdxTmp</name> - <name>patIdxStart</name> - 1)</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>strLength</name> =<init> <expr>(<name>strIdxEnd</name> - <name>strIdxStart</name> + 1)</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>foundIdx</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
            <label><name>strLoop</name>:</label>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>strLength</name> - <name>patLength</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>patLength</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>ch</name> = <name><name>patArr</name><index>[<expr><name>patIdxStart</name> + <name>j</name> + 1</expr>]</index></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>ch</name> != '?'</expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><call><name>different</name><argument_list>(<argument><expr><name>caseSensitive</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>,
                                      <argument><expr><name><name>strArr</name><index>[<expr><name>strIdxStart</name> + <name>i</name> + <name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <continue>continue strLoop;</continue>
                        }</block></then></if>
                    }</block></then></if>
                }</block></for>

                <expr_stmt><expr><name>foundIdx</name> = <name>strIdxStart</name> + <name>i</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></for>

            <if>if <condition>(<expr><name>foundIdx</name> == -1</expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>patIdxStart</name> = <name>patIdxTmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>strIdxStart</name> = <name>foundIdx</name> + <name>patLength</name></expr>;</expr_stmt>
        }</block></while>

        <comment type="line">// All characters in the string are used. Check if only '*'s are left</comment>
        <comment type="line">// in the pattern. If so, we succeeded. Otherwise failure.</comment>
        <return>return <expr><call><name>allStars</name><argument_list>(<argument><expr><name>patArr</name></expr></argument>, <argument><expr><name>patIdxStart</name></expr></argument>, <argument><expr><name>patIdxEnd</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>allStars</name><parameter_list>(<param><decl><type><name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>end</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> != '*'</expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>different</name><parameter_list>(
        <param><decl><type><name>boolean</name></type> <name>caseSensitive</name></decl></param>, <param><decl><type><name>char</name></type> <name>ch</name></decl></param>, <param><decl><type><name>char</name></type> <name>other</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>caseSensitive</name>
            ? <name>ch</name> != <name>other</name>
            : <call><name><name>Character</name>.<name>toUpperCase</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> != <call><name><name>Character</name>.<name>toUpperCase</name></name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Breaks a path up into a Vector of path elements, tokenizing on
     * &lt;code&gt;File.separator&lt;/code&gt;.
     *
     * @param path Path to tokenize. Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return a Vector of path elements from the tokenized path
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tokenizePath</name><parameter_list>(<param><decl><type><name>String</name></type> <name>path</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>tokenizePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>File</name>.<name>separator</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Breaks a path up into a Vector of path elements, tokenizing on
     *
     * @param path Path to tokenize. Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param separator the separator against which to tokenize.
     *
     * @return a Vector of path elements from the tokenized path
     * @since Ant 1.6
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tokenizePath</name><parameter_list>(<param><decl><type><name>String</name></type> <name>path</name></decl></param>, <param><decl><type><name>String</name></type> <name>separator</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>Vector</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>ret</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>FileUtils</name>.<name>isAbsolutePath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>s</name> =<init> <expr><call><name><name>FILE_UTILS</name>.<name>dissect</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ret</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>s</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>path</name> = <name><name>s</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><name>StringTokenizer</name></type> <name>st</name> =<init> <expr>new <call><name>StringTokenizer</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>st</name>.<name>hasMoreTokens</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><call><name><name>ret</name>.<name>addElement</name></name><argument_list>(<argument><expr><call><name><name>st</name>.<name>nextToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><name>ret</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Same as {@link #tokenizePath tokenizePath} but hopefully faster.
     */</comment>
    <comment type="block">/*package*/</comment> <function><type><specifier>static</specifier> <name>String</name><index>[]</index></type> <name>tokenizePathAsArray</name><parameter_list>(<param><decl><type><name>String</name></type> <name>path</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>root</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>FileUtils</name>.<name>isAbsolutePath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>s</name> =<init> <expr><call><name><name>FILE_UTILS</name>.<name>dissect</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>root</name> = <name><name>s</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>path</name> = <name><name>s</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><name>char</name></type> <name>sep</name> =<init> <expr><name><name>File</name>.<name>separatorChar</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>start</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr><call><name><name>path</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>pos</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>pos</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>pos</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name><name>path</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call> == <name>sep</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>pos</name> != <name>start</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>start</name> = <name>pos</name> + 1</expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr><name>len</name> != <name>start</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>l</name> =<init> <expr>new <name><name>String</name><index>[<expr><name>count</name> + ((<name>root</name> == <name>null</name>) ? 0 : 1)</expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>root</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>l</name><index>[<expr>0</expr>]</index></name> = <name>root</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> = 1</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>pos</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>pos</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>pos</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name><name>path</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call> == <name>sep</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>pos</name> != <name>start</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>tok</name> =<init> <expr><call><name><name>path</name>.<name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>l</name><index>[<expr><name>count</name>++</expr>]</index></name> = <name>tok</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>start</name> = <name>pos</name> + 1</expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr><name>len</name> != <name>start</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>tok</name> =<init> <expr><call><name><name>path</name>.<name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>l</name><index>[<expr><name>count</name></expr><comment type="block">/*++*/</comment>]</index></name> = <name>tok</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>l</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns dependency information on these two files. If src has been
     * modified later than target, it returns true. If target doesn't exist,
     * it likewise returns true. Otherwise, target is newer than src and
     * is not out of date, thus the method returns false. It also returns
     * false if the src file doesn't even exist, since how could the
     * target then be out of date.
     *
     * @param src the original file
     * @param target the file being compared against
     * @param granularity the amount in seconds of slack we will give in
     *        determining out of dateness
     * @return whether the target is out of date
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isOutOfDate</name><parameter_list>(<param><decl><type><name>File</name></type> <name>src</name></decl></param>, <param><decl><type><name>File</name></type> <name>target</name></decl></param>, <param><decl><type><name>int</name></type> <name>granularity</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr>!<call><name><name>src</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!<call><name><name>target</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>true</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>(<call><name><name>src</name>.<name>lastModified</name></name><argument_list>()</argument_list></call> - <name>granularity</name>) &gt; <call><name><name>target</name>.<name>lastModified</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>true</expr>;</return>
        }</block></then></if>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns dependency information on these two resources. If src has been
     * modified later than target, it returns true. If target doesn't exist,
     * it likewise returns true. Otherwise, target is newer than src and
     * is not out of date, thus the method returns false. It also returns
     * false if the src file doesn't even exist, since how could the
     * target then be out of date.
     *
     * @param src the original resource
     * @param target the resource being compared against
     * @param granularity the int amount in seconds of slack we will give in
     *        determining out of dateness
     * @return whether the target is out of date
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isOutOfDate</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>src</name></decl></param>, <param><decl><type><name>Resource</name></type> <name>target</name></decl></param>,
                                      <param><decl><type><name>int</name></type> <name>granularity</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>isOutOfDate</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr>(<name>long</name>) <name>granularity</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns dependency information on these two resources. If src has been
     * modified later than target, it returns true. If target doesn't exist,
     * it likewise returns true. Otherwise, target is newer than src and
     * is not out of date, thus the method returns false. It also returns
     * false if the src file doesn't even exist, since how could the
     * target then be out of date.
     *
     * @param src the original resource
     * @param target the resource being compared against
     * @param granularity the long amount in seconds of slack we will give in
     *        determining out of dateness
     * @return whether the target is out of date
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isOutOfDate</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>src</name></decl></param>, <param><decl><type><name>Resource</name></type> <name>target</name></decl></param>, <param><decl><type><name>long</name></type> <name>granularity</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>sourceLastModified</name> =<init> <expr><call><name><name>src</name>.<name>getLastModified</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>targetLastModified</name> =<init> <expr><call><name><name>target</name>.<name>getLastModified</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>src</name>.<name>isExists</name></name><argument_list>()</argument_list></call>
                &amp;&amp; (<name>sourceLastModified</name> == <name><name>Resource</name>.<name>UNKNOWN_DATETIME</name></name>
                        || <name>targetLastModified</name> == <name><name>Resource</name>.<name>UNKNOWN_DATETIME</name></name>
                                || (<name>sourceLastModified</name> - <name>granularity</name>) &gt; <name>targetLastModified</name>)</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * "Flattens" a string by removing all whitespace (space, tab, linefeed,
     * carriage return, and formfeed). This uses StringTokenizer and the
     * default set of tokens as documented in the single argument constructor.
     *
     * @param input a String to remove all whitespace.
     * @return a String that has had all whitespace removed.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>removeWhitespace</name><parameter_list>(<param><decl><type><name>String</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>result</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>input</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>StringTokenizer</name></type> <name>st</name> =<init> <expr>new <call><name>StringTokenizer</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>st</name>.<name>hasMoreTokens</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><call><name><name>result</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>st</name>.<name>nextToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>
        <return>return <expr><call><name><name>result</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests if a string contains stars or question marks
     * @param input a String which one wants to test for containing wildcard
     * @return true if the string contains at least a star or a question mark
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>hasWildcards</name><parameter_list>(<param><decl><type><name>String</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<call><name><name>input</name>.<name>indexOf</name></name><argument_list>(<argument><expr>'*'</expr></argument>)</argument_list></call> != -1 || <call><name><name>input</name>.<name>indexOf</name></name><argument_list>(<argument><expr>'?'</expr></argument>)</argument_list></call> != -1)</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * removes from a pattern all tokens to the right containing wildcards
     * @param input the input string
     * @return the leftmost part of the pattern without wildcards
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>rtrimWildcardTokens</name><parameter_list>(<param><decl><type><name>String</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>new <call><name>TokenizedPattern</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call>.<call><name>rtrimWildcardTokens</name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>
}</block></class>

</unit>
