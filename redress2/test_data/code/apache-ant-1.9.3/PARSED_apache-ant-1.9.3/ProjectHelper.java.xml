<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\ProjectHelper.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Hashtable</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>LinkedList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Locale</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Resource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>resources</name>.<name>FileResource</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>LoaderUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>xml</name>.<name>sax</name>.<name>AttributeList</name></name>;</import>

<comment type="javadoc">/**
 * Configures a Project (complete with Targets and Tasks) based on
 * a build file. It'll rely on a plugin to do the actual processing
 * of the file.
 * &lt;p&gt;
 * This class also provide static wrappers for common introspection.
 */</comment>
<class><specifier>public</specifier> class <name>ProjectHelper</name> <block>{
    <comment type="javadoc">/** The URI for ant name space */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ANT_CORE_URI</name>    =<init> <expr>"antlib:org.apache.tools.ant"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** The URI for antlib current definitions */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ANT_CURRENT_URI</name>      =<init> <expr>"ant:current"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** The URI for ant specific attributes
     * @since Ant 1.9.1
     * */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ANT_ATTRIBUTE_URI</name>      =<init> <expr>"ant:attribute"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** The URI for defined types/tasks - the format is antlib:&lt;package&gt; */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ANTLIB_URI</name>     =<init> <expr>"antlib:"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** Polymorphic attribute  */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ANT_TYPE</name> =<init> <expr>"ant-type"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Name of JVM system property which provides the name of the
     * ProjectHelper class to use.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HELPER_PROPERTY</name> =<init> <expr><name><name>MagicNames</name>.<name>PROJECT_HELPER_CLASS</name></name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The service identifier in jars which provide Project Helper
     * implementations.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>SERVICE_ID</name> =<init> <expr><name><name>MagicNames</name>.<name>PROJECT_HELPER_SERVICE</name></name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * name of project helper reference that we add to a project
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>PROJECTHELPER_REFERENCE</name> =<init> <expr><name><name>MagicNames</name>.<name>REFID_PROJECT_HELPER</name></name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * constant to denote use project name as target prefix
     * @since Ant 1.9.1
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>USE_PROJECT_NAME_AS_TARGET_PREFIX</name> =<init> <expr>"USE_PROJECT_NAME_AS_TARGET_PREFIX"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Configures the project with the contents of the specified build file.
     *
     * @param project The project to configure. Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param buildFile A build file giving the project's configuration.
     *                  Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception BuildException if the configuration is invalid or cannot be read
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>configureProject</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>File</name></type> <name>buildFile</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>FileResource</name></type> <name>resource</name> =<init> <expr>new <call><name>FileResource</name><argument_list>(<argument><expr><name>buildFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ProjectHelper</name></type> <name>helper</name> =<init> <expr><call><name><name>ProjectHelperRepository</name>.<name>getInstance</name></name><argument_list>()</argument_list></call>.<call><name>getProjectHelperForBuildFile</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>project</name>.<name>addReference</name></name><argument_list>(<argument><expr><name>PROJECTHELPER_REFERENCE</name></expr></argument>, <argument><expr><name>helper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>helper</name>.<name>parse</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><name>buildFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Possible value for target's onMissingExtensionPoint attribute. It determines how to deal with
     * targets that want to extend missing extension-points.
     * &lt;p&gt;
     * This class behaves like a Java 1.5 Enum class.
     *
     * @since 1.8.2
     */</comment>
    <class><specifier>public</specifier> <specifier>final</specifier> <specifier>static</specifier> class <name>OnMissingExtensionPoint</name> <block>{

        <comment type="javadoc">/** fail if the extension-point is not defined */</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>OnMissingExtensionPoint</name></type> <name>FAIL</name> =<init> <expr>new <call><name>OnMissingExtensionPoint</name><argument_list>(
                <argument><expr>"fail"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="javadoc">/** warn if the extension-point is not defined */</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>OnMissingExtensionPoint</name></type> <name>WARN</name> =<init> <expr>new <call><name>OnMissingExtensionPoint</name><argument_list>(
                <argument><expr>"warn"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="javadoc">/** ignore the extensionOf attribute if the extension-point is not defined */</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>OnMissingExtensionPoint</name></type> <name>IGNORE</name> =<init> <expr>new <call><name>OnMissingExtensionPoint</name><argument_list>(
                <argument><expr>"ignore"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>OnMissingExtensionPoint</name><index>[]</index></type> <name>values</name> =<init> <expr>new <name><name>OnMissingExtensionPoint</name><index>[]</index></name> <block>{
                                <expr><name>FAIL</name></expr>, <expr><name>WARN</name></expr>, <expr><name>IGNORE</name></expr> }</block></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>String</name></type> <name>name</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>OnMissingExtensionPoint</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>name</name></name> = <name>name</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>String</name></type> <name>name</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>name</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>name</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <specifier>static</specifier> <name>OnMissingExtensionPoint</name></type> <name>valueOf</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr><name>name</name> == <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>NullPointerException</name><argument_list>()</argument_list></call></expr>;</throw>
            }</block></then></if>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>values</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><call><name><name>name</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>name</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
                }</block></then></if>
            }</block></for>
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(
                    <argument><expr>"Unknown onMissingExtensionPoint " + <name>name</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/** Default constructor */</comment>
    <constructor><specifier>public</specifier> <name>ProjectHelper</name><parameter_list>()</parameter_list> <block>{
    }</block></constructor>

    <comment type="line">// -------------------- Common properties  --------------------</comment>
    <comment type="line">// The following properties are required by import ( and other tasks</comment>
    <comment type="line">// that read build files using ProjectHelper ).</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>importStack</name> =<init> <expr>new <call><name><name>Vector</name><argument_list>&lt;<argument><name>Object</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name><index>[]</index></argument>&gt;</argument_list></name></type> <name>extensionStack</name> =<init> <expr>new <call><name><name>LinkedList</name><argument_list>&lt;<argument><name><name>String</name><index>[]</index></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     *  Import stack.
     *  Used to keep track of imported files. Error reporting should
     *  display the import path.
     *
     * @return the stack of import source objects.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Vector</name><argument_list>&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>getImportStack</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>importStack</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Extension stack.
     * Used to keep track of targets that extend extension points.
     *
     * @return a list of three element string arrays where the first
     * element is the name of the extensionpoint, the second the name
     * of the target and the third the name of the enum like class
     * {@link OnMissingExtensionPoint}.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name><index>[]</index></argument>&gt;</argument_list></name></type> <name>getExtensionStack</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>extensionStack</name></expr>;</return>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <specifier>static</specifier> <name><name>ThreadLocal</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>targetPrefix</name> =<init> <expr>new <call><name><name>ThreadLocal</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The prefix to prepend to imported target names.
     *
     * &lt;p&gt;May be set by &amp;lt;import&amp;gt;'s as attribute.&lt;/p&gt;
     *
     * @return the configured prefix or null
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getCurrentTargetPrefix</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>targetPrefix</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the prefix to prepend to imported target names.
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>setCurrentTargetPrefix</name><parameter_list>(<param><decl><type><name>String</name></type> <name>prefix</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>targetPrefix</name>.<name>set</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <specifier>static</specifier> <name><name>ThreadLocal</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>prefixSeparator</name> =<init> <expr>new <class><super><name><name>ThreadLocal</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
            <function><type><specifier>protected</specifier> <name>String</name></type> <name>initialValue</name><parameter_list>()</parameter_list> <block>{
                <return>return <expr>"."</expr>;</return>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The separator between the prefix and the target name.
     *
     * &lt;p&gt;May be set by &amp;lt;import&amp;gt;'s prefixSeparator attribute.&lt;/p&gt;
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getCurrentPrefixSeparator</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>prefixSeparator</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the separator between the prefix and the target name.
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>setCurrentPrefixSeparator</name><parameter_list>(<param><decl><type><name>String</name></type> <name>sep</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>prefixSeparator</name>.<name>set</name></name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <specifier>static</specifier> <name><name>ThreadLocal</name><argument_list>&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>inIncludeMode</name> =<init> <expr>new <class><super><name><name>ThreadLocal</name><argument_list>&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
            <function><type><specifier>protected</specifier> <name>Boolean</name></type> <name>initialValue</name><parameter_list>()</parameter_list> <block>{
                <return>return <expr><name><name>Boolean</name>.<name>FALSE</name></name></expr>;</return>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Whether the current file should be read in include as opposed
     * to import mode.
     *
     * &lt;p&gt;In include mode included targets are only known by their
     * prefixed names and their depends lists get rewritten so that
     * all dependencies get the prefix as well.&lt;/p&gt;
     *
     * &lt;p&gt;In import mode imported targets are known by an adorned as
     * well as a prefixed name and the unadorned target may be
     * overwritten in the importing build file.  The depends list of
     * the imported targets is not modified at all.&lt;/p&gt;
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isInIncludeMode</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>Boolean</name>.<name>TRUE</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>inIncludeMode</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets whether the current file should be read in include as
     * opposed to import mode.
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>setInIncludeMode</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>includeMode</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>inIncludeMode</name>.<name>set</name></name><argument_list>(<argument><expr><call><name><name>Boolean</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>includeMode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// --------------------  Parse method  --------------------</comment>
    <comment type="javadoc">/**
     * Parses the project file, configuring the project as it goes.
     *
     * @param project The project for the resulting ProjectHelper to configure.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param source The source for XML configuration. A helper must support
     *               at least File, for backward compatibility. Helpers may
     *               support URL, InputStream, etc or specialized types.
     *
     * @since Ant1.5
     * @exception BuildException if the configuration is invalid or cannot
     *                           be read
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>parse</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>Object</name></type> <name>source</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"ProjectHelper.parse() must be implemented "
            + "in a helper plugin " + <call><name><name>this</name>.<name>getClass</name></name><argument_list>()</argument_list></call>.<call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="javadoc">/**
     * Get the first project helper found in the classpath
     *
     * @return an project helper, never &lt;code&gt;null&lt;/code&gt;
     * @see org.apache.tools.ant.ProjectHelperRepository#getHelpers()
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ProjectHelper</name></type> <name>getProjectHelper</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr>(<name>ProjectHelper</name>) <call><name><name>ProjectHelperRepository</name>.<name>getInstance</name></name><argument_list>()</argument_list></call>.<call><name>getHelpers</name><argument_list>()</argument_list></call>.<call><name>next</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * JDK1.1 compatible access to the context class loader. Cut &amp; paste from JAXP.
     *
     * @deprecated since 1.6.x.
     *             Use LoaderUtils.getContextClassLoader()
     *
     * @return the current context class loader, or &lt;code&gt;null&lt;/code&gt;
     * if the context class loader is unavailable.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ClassLoader</name></type> <name>getContextClassLoader</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>LoaderUtils</name>.<name>isContextLoaderAvailable</name></name><argument_list>()</argument_list></call> ? <call><name><name>LoaderUtils</name>.<name>getContextClassLoader</name></name><argument_list>()</argument_list></call> : <name>null</name></expr>;</return>
    }</block></function>

    <comment type="line">// -------------------- Static utils, used by most helpers ----------------</comment>

    <comment type="javadoc">/**
     * Configures an object using an introspection handler.
     *
     * @param target The target object to be configured.
     *               Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param attrs  A list of attributes to configure within the target.
     *               Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param project The project containing the target.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @deprecated since 1.6.x.
     *             Use IntrospectionHelper for each property.
     *
     * @exception BuildException if any of the attributes can't be handled by
     *                           the target
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>configure</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>target</name></decl></param>, <param><decl><type><name>AttributeList</name></type> <name>attrs</name></decl></param>,
                                 <param><decl><type><name>Project</name></type> <name>project</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>target</name> <name>instanceof</name> <name>TypeAdapter</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>target</name> = ((<name>TypeAdapter</name>) <name>target</name>).<call><name>getProxy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><name>IntrospectionHelper</name></type> <name>ih</name> =<init> <expr><call><name><name>IntrospectionHelper</name>.<name>getHelper</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><call><name><name>target</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init>, <name>length</name> =<init> <expr><call><name><name>attrs</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <comment type="line">// reflect these into the target</comment>
            <decl_stmt><decl><type><name>String</name></type> <name>value</name> =<init> <expr><call><name>replaceProperties</name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><call><name><name>attrs</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>project</name>.<name>getProperties</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try <block>{
                <expr_stmt><expr><call><name><name>ih</name>.<name>setAttribute</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><call><name><name>attrs</name>.<name>getName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<call><name>toLowerCase</name><argument_list>(<argument><expr><name><name>Locale</name>.<name>ENGLISH</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> <catch>catch (<param><decl><type><name>BuildException</name></type> <name>be</name></decl></param>) <block>{
                <comment type="line">// id attribute must be set externally</comment>
                <if>if <condition>(<expr>!<call><name><name>attrs</name>.<name>getName</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr>"id"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <throw>throw <expr><name>be</name></expr>;</throw>
                }</block></then></if>
            }</block></catch></try>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Adds the content of #PCDATA sections to an element.
     *
     * @param project The project containing the target.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param target  The target object to be configured.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param buf A character array of the text within the element.
     *            Will not be &lt;code&gt;null&lt;/code&gt;.
     * @param start The start element in the array.
     * @param count The number of characters to read from the array.
     *
     * @exception BuildException if the target object doesn't accept text
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>addText</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>Object</name></type> <name>target</name></decl></param>, <param><decl><type><name><name>char</name><index>[]</index></name></type> <name>buf</name></decl></param>,
        <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>addText</name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds the content of #PCDATA sections to an element.
     *
     * @param project The project containing the target.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param target  The target object to be configured.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param text    Text to add to the target.
     *                May be &lt;code&gt;null&lt;/code&gt;, in which case this
     *                method call is a no-op.
     *
     * @exception BuildException if the target object doesn't accept text
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>addText</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>Object</name></type> <name>target</name></decl></param>, <param><decl><type><name>String</name></type> <name>text</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{

        <if>if <condition>(<expr><name>text</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>target</name> <name>instanceof</name> <name>TypeAdapter</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>target</name> = ((<name>TypeAdapter</name>) <name>target</name>).<call><name>getProxy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>IntrospectionHelper</name>.<name>getHelper</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><call><name><name>target</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>addText</name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Stores a configured child element within its parent object.
     *
     * @param project Project containing the objects.
     *                May be &lt;code&gt;null&lt;/code&gt;.
     * @param parent  Parent object to add child to.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param child   Child object to store in parent.
     *                Should not be &lt;code&gt;null&lt;/code&gt;.
     * @param tag     Name of element which generated the child.
     *                May be &lt;code&gt;null&lt;/code&gt;, in which case
     *                the child is not stored.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>storeChild</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>Object</name></type> <name>parent</name></decl></param>, <param><decl><type><name>Object</name></type> <name>child</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>IntrospectionHelper</name></type> <name>ih</name> =<init> <expr><call><name><name>IntrospectionHelper</name>.<name>getHelper</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><call><name><name>parent</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>ih</name>.<name>storeElement</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Replaces &lt;code&gt;${xxx}&lt;/code&gt; style constructions in the given value with
     * the string value of the corresponding properties.
     *
     * @param project The project containing the properties to replace.
     *                Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @param value The string to be scanned for property references.
     *              May be &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception BuildException if the string contains an opening
     *                           &lt;code&gt;${&lt;/code&gt; without a closing
     *                           &lt;code&gt;}&lt;/code&gt;
     * @return the original string with the properties replaced, or
     *         &lt;code&gt;null&lt;/code&gt; if the original string is &lt;code&gt;null&lt;/code&gt;.
     *
     * @deprecated since 1.6.x.
     *             Use project.replaceProperties().
     * @since 1.5
     */</comment>
     <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>replaceProperties</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>String</name></type> <name>value</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <comment type="line">// needed since project properties are not accessible</comment>
         <return>return <expr><call><name><name>project</name>.<name>replaceProperties</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
     }</block></function>

    <comment type="javadoc">/**
     * Replaces &lt;code&gt;${xxx}&lt;/code&gt; style constructions in the given value
     * with the string value of the corresponding data types.
     *
     * @param project The container project. This is used solely for
     *                logging purposes. Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param value The string to be scanned for property references.
     *              May be &lt;code&gt;null&lt;/code&gt;, in which case this
     *              method returns immediately with no effect.
     * @param keys  Mapping (String to Object) of property names to their
     *              values. Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception BuildException if the string contains an opening
     *                           &lt;code&gt;${&lt;/code&gt; without a closing
     *                           &lt;code&gt;}&lt;/code&gt;
     * @return the original string with the properties replaced, or
     *         &lt;code&gt;null&lt;/code&gt; if the original string is &lt;code&gt;null&lt;/code&gt;.
     * @deprecated since 1.6.x.
     *             Use PropertyHelper.
     */</comment>
     <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>replaceProperties</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>, <param><decl><type><name>String</name></type> <name>value</name></decl></param>, <param><decl><type><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>keys</name></decl></param>)</parameter_list>
             <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>PropertyHelper</name></type> <name>ph</name> =<init> <expr><call><name><name>PropertyHelper</name>.<name>getPropertyHelper</name></name><argument_list>(<argument><expr><name>project</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>ph</name>.<name>replaceProperties</name></name><argument_list>(<argument><expr><name>null</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Parses a string containing &lt;code&gt;${xxx}&lt;/code&gt; style property
     * references into two lists. The first list is a collection
     * of text fragments, while the other is a set of string property names.
     * &lt;code&gt;null&lt;/code&gt; entries in the first list indicate a property
     * reference from the second list.
     *
     * &lt;p&gt;As of Ant 1.8.0 this method is never invoked by any code
     * inside of Ant itself.&lt;/p&gt;
     *
     * @param value     Text to parse. Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param fragments List to add text fragments to.
     *                  Must not be &lt;code&gt;null&lt;/code&gt;.
     * @param propertyRefs List to add property names to.
     *                     Must not be &lt;code&gt;null&lt;/code&gt;.
     *
     * @deprecated since 1.6.x.
     *             Use PropertyHelper.
     * @exception BuildException if the string contains an opening
     *                           &lt;code&gt;${&lt;/code&gt; without a closing &lt;code&gt;}&lt;/code&gt;
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>parsePropertyString</name><parameter_list>(<param><decl><type><name>String</name></type> <name>value</name></decl></param>, <param><decl><type><name><name>Vector</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>fragments</name></decl></param>, <param><decl><type><name><name>Vector</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>propertyRefs</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name><name>PropertyHelper</name>.<name>parsePropertyStringDefault</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>fragments</name></expr></argument>, <argument><expr><name>propertyRefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Map a namespaced {uri,name} to an internal string format.
     * For BC purposes the names from the ant core uri will be
     * mapped to "name", other names will be mapped to
     * uri + ":" + name.
     * @param uri   The namespace URI
     * @param name  The localname
     * @return      The stringified form of the ns name
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>genComponentName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>uri</name></decl></param>, <param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>uri</name> == <name>null</name> || <call><name><name>uri</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call> || <call><name><name>uri</name>.<name>equals</name></name><argument_list>(<argument><expr><name>ANT_CORE_URI</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>name</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>uri</name> + ":" + <name>name</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * extract a uri from a component name
     *
     * @param componentName  The stringified form for {uri, name}
     * @return               The uri or "" if not present
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>extractUriFromComponentName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>componentName</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>componentName</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr>""</expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> =<init> <expr><call><name><name>componentName</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> == -1</expr>)</condition><then> <block>{
            <return>return <expr>""</expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>componentName</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * extract the element name from a component name
     *
     * @param componentName  The stringified form for {uri, name}
     * @return               The element name of the component
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>extractNameFromComponentName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>componentName</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> =<init> <expr><call><name><name>componentName</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> == -1</expr>)</condition><then> <block>{
            <return>return <expr><name>componentName</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>componentName</name>.<name>substring</name></name><argument_list>(<argument><expr><name>index</name> + 1</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Convert an attribute namespace to a "component name".
     * @param ns the xml namespace uri.
     * @return the converted value.
     * @since Ant 1.9.1
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>nsToComponentName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>ns</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>"attribute namespace:" + <name>ns</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Add location to build exception.
     * @param ex the build exception, if the build exception
     *           does not include
     * @param newLocation the location of the calling task (may be null)
     * @return a new build exception based in the build exception with
     *         location set to newLocation. If the original exception
     *         did not have a location, just return the build exception
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>BuildException</name></type> <name>addLocationToBuildException</name><parameter_list>(
            <param><decl><type><name>BuildException</name></type> <name>ex</name></decl></param>, <param><decl><type><name>Location</name></type> <name>newLocation</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ex</name>.<name>getLocation</name></name><argument_list>()</argument_list></call> == <name>null</name> || <call><name><name>ex</name>.<name>getMessage</name></name><argument_list>()</argument_list></call> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr><name>ex</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>String</name></type> <name>errorMessage</name>
            =<init> <expr>"The following error occurred while executing this line:"
            + <call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"line.separator"</expr></argument>)</argument_list></call>
            + <call><name><name>ex</name>.<name>getLocation</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call>
            + <call><name><name>ex</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newLocation</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>newLocation</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Whether this instance of ProjectHelper can parse an Antlib
     * descriptor given by the URL and return its content as an
     * UnknownElement ready to be turned into an Antlib task.
     *
     * &lt;p&gt;This method should not try to parse the content of the
     * descriptor, the URL is only given as an argument to allow
     * subclasses to decide whether they can support a given URL
     * scheme or not.&lt;/p&gt;
     *
     * &lt;p&gt;Subclasses that return true in this method must also
     * override {@link #parseAntlibDescriptor
     * parseAntlibDescriptor}.&lt;/p&gt;
     *
     * &lt;p&gt;This implementation returns false.&lt;/p&gt;
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>canParseAntlibDescriptor</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>r</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Parse the given URL as an antlib descriptor and return the
     * content as something that can be turned into an Antlib task.
     *
     * @since ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>UnknownElement</name></type> <name>parseAntlibDescriptor</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>containingProject</name></decl></param>,
                                                <param><decl><type><name>Resource</name></type> <name>source</name></decl></param>)</parameter_list> <block>{
        <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"can't parse antlib descriptors"</expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="javadoc">/**
     * Check if the helper supports the kind of file. Some basic check on the
     * extension's file should be done here.
     *
     * @param buildFile
     *            the file expected to be parsed (never &lt;code&gt;null&lt;/code&gt;)
     * @return true if the helper supports it
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>canParseBuildFile</name><parameter_list>(<param><decl><type><name>Resource</name></type> <name>buildFile</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * The file name of the build script to be parsed if none specified on the command line
     *
     * @return the name of the default file (never &lt;code&gt;null&lt;/code&gt;)
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getDefaultBuildFile</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>Main</name>.<name>DEFAULT_BUILD_FILENAME</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Check extensionStack and inject all targets having extensionOf attributes
     * into extensionPoint.
     * &lt;p&gt;
     * This method allow you to defer injection and have a powerful control of
     * extensionPoint wiring.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This should be invoked by each concrete implementation of ProjectHelper
     * when the root "buildfile" and all imported/included buildfile are loaded.
     * &lt;/p&gt;
     *
     * @param project The project containing the target. Must not be
     *            &lt;code&gt;null&lt;/code&gt;.
     * @exception BuildException if OnMissingExtensionPoint.FAIL and
     *                extensionPoint does not exist
     * @see OnMissingExtensionPoint
     * @since 1.9
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>resolveExtensionOfAttributes</name><parameter_list>(<param><decl><type><name>Project</name></type> <name>project</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <for>for (<init><decl><type><name>String</name><index>[]</index></type> <name>extensionInfo</name> :<range> <expr><call><name>getExtensionStack</name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>extPointName</name> =<init> <expr><name><name>extensionInfo</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>targetName</name> =<init> <expr><name><name>extensionInfo</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>OnMissingExtensionPoint</name></type> <name>missingBehaviour</name> =<init> <expr><call><name><name>OnMissingExtensionPoint</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name><name>extensionInfo</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// if the file has been included or imported, it may have a prefix</comment>
            <comment type="line">// we should consider when trying to resolve the target it is</comment>
            <comment type="line">// extending</comment>
            <decl_stmt><decl><type><name>String</name></type> <name>prefixAndSep</name> =<init> <expr><name><name>extensionInfo</name>.<name>length</name></name> &gt; 3 ? <name><name>extensionInfo</name><index>[<expr>3</expr>]</index></name> : <name>null</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// find the target we're extending</comment>
            <decl_stmt><decl><type><name><name>Hashtable</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Target</name></argument>&gt;</argument_list></name></type> <name>projectTargets</name> =<init> <expr><call><name><name>project</name>.<name>getTargets</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Target</name></type> <name>extPoint</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>prefixAndSep</name> == <name>null</name></expr>)</condition><then> <block>{
                <comment type="line">// no prefix - not from an imported/included build file</comment>
                <expr_stmt><expr><name>extPoint</name> = <call><name><name>projectTargets</name>.<name>get</name></name><argument_list>(<argument><expr><name>extPointName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <comment type="line">// we have a prefix, which means we came from an include/import</comment>

                <comment type="line">// FIXME: here we handle no particular level of include. We try</comment>
                <comment type="line">// the fully prefixed name, and then the non-prefixed name. But</comment>
                <comment type="line">// there might be intermediate project in the import stack,</comment>
                <comment type="line">// which prefix should be tested before testing the non-prefix</comment>
                <comment type="line">// root name.</comment>

                <expr_stmt><expr><name>extPoint</name> = <call><name><name>projectTargets</name>.<name>get</name></name><argument_list>(<argument><expr><name>prefixAndSep</name> + <name>extPointName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>extPoint</name> == <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>extPoint</name> = <call><name><name>projectTargets</name>.<name>get</name></name><argument_list>(<argument><expr><name>extPointName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>

            <comment type="line">// make sure we found a point to extend on</comment>
            <if>if <condition>(<expr><name>extPoint</name> == <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>message</name> =<init> <expr>"can't add target " + <name>targetName</name>
                        + " to extension-point " + <name>extPointName</name>
                        + " because the extension-point is unknown."</expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>missingBehaviour</name> == <name><name>OnMissingExtensionPoint</name>.<name>FAIL</name></name></expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then> <else>else <if>if <condition>(<expr><name>missingBehaviour</name> == <name><name>OnMissingExtensionPoint</name>.<name>WARN</name></name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>Target</name></type> <name>t</name> =<init> <expr><call><name><name>projectTargets</name>.<name>get</name></name><argument_list>(<argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>project</name>.<name>log</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>"Warning: " + <name>message</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></else></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!(<name>extPoint</name> <name>instanceof</name> <name>ExtensionPoint</name>)</expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"referenced target " + <name>extPointName</name>
                            + " is not an extension-point"</expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>extPoint</name>.<name>addDependency</name></name><argument_list>(<argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
    }</block></function>
}</block></class>
</unit>
