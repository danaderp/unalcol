<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\taskdefs\optional\Javah.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>optional</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Enumeration</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>StringTokenizer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Task</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>optional</name>.<name>javah</name>.<name>JavahAdapter</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>optional</name>.<name>javah</name>.<name>JavahAdapterFactory</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Commandline</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>FileSet</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Path</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>Reference</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>StringUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>facade</name>.<name>FacadeTaskHelper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>facade</name>.<name>ImplementationSpecificArgument</name></name>;</import>

<comment type="javadoc">/**
 * Generates JNI header files using javah.
 *
 * This task can take the following arguments:
 * &lt;ul&gt;
 * &lt;li&gt;classname - the fully-qualified name of a class&lt;/li&gt;
 * &lt;li&gt;outputFile - Concatenates the resulting header or source files for all
 *     the classes listed into this file&lt;/li&gt;
 * &lt;li&gt;destdir - Sets the directory where javah saves the header files or the
 *     stub files&lt;/li&gt;
 * &lt;li&gt;classpath&lt;/li&gt;
 * &lt;li&gt;bootclasspath&lt;/li&gt;
 * &lt;li&gt;force - Specifies that output files should always be written
       (JDK1.2 only)&lt;/li&gt;
 * &lt;li&gt;old - Specifies that old JDK1.0-style header files should be generated
 *     (otherwise output file contain JNI-style native method
 *      function prototypes) (JDK1.2 only)&lt;/li&gt;
 * &lt;li&gt;stubs - generate C declarations from the Java object file (used with old)&lt;/li&gt;
 * &lt;li&gt;verbose - causes javah to print a message to stdout concerning the status
 *     of the generated files&lt;/li&gt;
 * &lt;li&gt;extdirs - Override location of installed extensions&lt;/li&gt;
 * &lt;/ul&gt;
 * Of these arguments, either &lt;b&gt;outputFile&lt;/b&gt; or &lt;b&gt;destdir&lt;/b&gt; is required,
 * but not both. More than one classname may be specified, using a comma-separated
 * list or by using &lt;code&gt;&amp;lt;class name="xxx"&amp;gt;&lt;/code&gt; elements within the task.
 * &lt;p&gt;
 * When this task executes, it will generate C header and source files that
 * are needed to implement native methods.
 *
 */</comment>

<class><specifier>public</specifier> class <name>Javah</name> <super><extends>extends <name>Task</name></extends></super> <block>{

    <decl_stmt><decl><type><specifier>private</specifier> <name>Vector</name></type> <name>classes</name> =<init> <expr>new <call><name>Vector</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>cls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>destDir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Path</name></type> <name>classpath</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>outputFile</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>verbose</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>force</name>   =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>old</name>     =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>stubs</name>   =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Path</name></type> <name>bootclasspath</name></decl>;</decl_stmt>
    <comment type="line">//private Path extdirs;</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>FacadeTaskHelper</name></type> <name>facade</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Vector</name></type> <name>files</name> =<init> <expr>new <call><name>Vector</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>JavahAdapter</name></type> <name>nestedAdapter</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * No arg constructor.
     */</comment>
    <constructor><specifier>public</specifier> <name>Javah</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>facade</name> = new <call><name>FacadeTaskHelper</name><argument_list>(<argument><expr><call><name><name>JavahAdapterFactory</name>.<name>getDefault</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * the fully-qualified name of the class (or classes, separated by commas).
     * @param cls the classname (or classnames).
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setClass</name><parameter_list>(<param><decl><type><name>String</name></type> <name>cls</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>cls</name></name> = <name>cls</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Adds class to process.
     * @return a &lt;code&gt;ClassArgument&lt;/code&gt; to be configured.
     */</comment>
    <function><type><specifier>public</specifier> <name>ClassArgument</name></type> <name>createClass</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>ClassArgument</name></type> <name>ga</name> =<init> <expr>new <call><name>ClassArgument</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>classes</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ga</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * A class corresponding the the nested "class" element.
     * It contains a "name" attribute.
     */</comment>
    <class><specifier>public</specifier> class <name>ClassArgument</name> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>name</name></decl>;</decl_stmt>

        <comment type="javadoc">/** Constructor for ClassArgument. */</comment>
        <constructor><specifier>public</specifier> <name>ClassArgument</name><parameter_list>()</parameter_list> <block>{
        }</block></constructor>

        <comment type="javadoc">/**
         * Set the name attribute.
         * @param name the name attribute.
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>setName</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>name</name></name> = <name>name</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Get the name attribute.
         * @return the name attribute.
         */</comment>
        <function><type><specifier>public</specifier> <name>String</name></type> <name>getName</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name>name</name></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Add a fileset.
     * @param fs the fileset to add.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addFileSet</name><parameter_list>(<param><decl><type><name>FileSet</name></type> <name>fs</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>files</name>.<name>add</name></name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Names of the classes to process.
     * @return the array of classes.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getClasses</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>ArrayList</name></type> <name>al</name> =<init> <expr>new <call><name>ArrayList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cls</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>StringTokenizer</name></type> <name>tok</name> =<init> <expr>new <call><name>StringTokenizer</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr>","</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>tok</name>.<name>hasMoreTokens</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><call><name><name>al</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>tok</name>.<name>nextToken</name></name><argument_list>()</argument_list></call>.<call><name>trim</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>files</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <for>for (<init><decl><type><name>Enumeration</name></type> <name>e</name> =<init> <expr><call><name><name>files</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>) <block>{
                <decl_stmt><decl><type><name>FileSet</name></type> <name>fs</name> =<init> <expr>(<name>FileSet</name>) <call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>includedClasses</name> =<init> <expr><call><name><name>fs</name>.<name>getDirectoryScanner</name></name><argument_list>(
                    <argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>getIncludedFiles</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>includedClasses</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>className</name> =<init>
                        <expr><name><name>includedClasses</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>replace</name><argument_list>(<argument><expr>'\\'</expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call>.<call><name>replace</name><argument_list>(<argument><expr>'/'</expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call>
                        .<call><name>substring</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name><name>includedClasses</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>length</name><argument_list>()</argument_list></call> - 6</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>al</name>.<name>add</name></name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></for>
        }</block></then></if>
        <decl_stmt><decl><type><name>Enumeration</name></type> <name>e</name> =<init> <expr><call><name><name>classes</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>ClassArgument</name></type> <name>arg</name> =<init> <expr>(<name>ClassArgument</name>) <call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>al</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>arg</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr>(<name><name>String</name><index>[]</index></name>) <call><name><name>al</name>.<name>toArray</name></name><argument_list>(<argument><expr>new <name><name>String</name><index>[<expr><call><name><name>al</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set the destination directory into which the Java source
     * files should be compiled.
     * @param destDir the destination directory.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDestdir</name><parameter_list>(<param><decl><type><name>File</name></type> <name>destDir</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>destDir</name></name> = <name>destDir</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * The destination directory, if any.
     * @return the destination directory.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>File</name></type> <name>getDestdir</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>destDir</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * the classpath to use.
     * @param src the classpath.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setClasspath</name><parameter_list>(<param><decl><type><name>Path</name></type> <name>src</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>classpath</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>classpath</name> = <name>src</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>classpath</name>.<name>append</name></name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Path to use for classpath.
     * @return a path to be configured.
     */</comment>
    <function><type><specifier>public</specifier> <name>Path</name></type> <name>createClasspath</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>classpath</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>classpath</name> = new <call><name>Path</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><call><name><name>classpath</name>.<name>createPath</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Adds a reference to a classpath defined elsewhere.
     * @param r a reference to a classpath.
     * @todo this needs to be documented in the HTML docs.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setClasspathRef</name><parameter_list>(<param><decl><type><name>Reference</name></type> <name>r</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>createClasspath</name><argument_list>()</argument_list></call>.<call><name>setRefid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * The classpath to use.
     * @return the classpath.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>Path</name></type> <name>getClasspath</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>classpath</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * location of bootstrap class files.
     * @param src the bootstrap classpath.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setBootclasspath</name><parameter_list>(<param><decl><type><name>Path</name></type> <name>src</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>bootclasspath</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>bootclasspath</name> = <name>src</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>bootclasspath</name>.<name>append</name></name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Adds path to bootstrap class files.
     * @return a path to be configured.
     */</comment>
    <function><type><specifier>public</specifier> <name>Path</name></type> <name>createBootclasspath</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>bootclasspath</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>bootclasspath</name> = new <call><name>Path</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><call><name><name>bootclasspath</name>.<name>createPath</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * To the bootstrap path, this adds a reference to a classpath defined elsewhere.
     * @param r a reference to a classpath
     * @todo this needs to be documented in the HTML.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setBootClasspathRef</name><parameter_list>(<param><decl><type><name>Reference</name></type> <name>r</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>createBootclasspath</name><argument_list>()</argument_list></call>.<call><name>setRefid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * The bootclasspath to use.
     * @return the bootclass path.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>Path</name></type> <name>getBootclasspath</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>bootclasspath</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Concatenates the resulting header or source files for all
     * the classes listed into this file.
     * @param outputFile the output file.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setOutputFile</name><parameter_list>(<param><decl><type><name>File</name></type> <name>outputFile</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>outputFile</name></name> = <name>outputFile</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * The destination file, if any.
     * @return the destination file.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>File</name></type> <name>getOutputfile</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>outputFile</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * If true, output files should always be written (JDK1.2 only).
     * @param force the value to use.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setForce</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>force</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>force</name></name> = <name>force</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether output files should always be written.
     * @return the force attribute.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getForce</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>force</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * If true, specifies that old JDK1.0-style header files should be
     * generated.
     * (otherwise output file contain JNI-style native method function
     *  prototypes) (JDK1.2 only).
     * @param old if true use old 1.0 style header files.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setOld</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>old</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>old</name></name> = <name>old</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether old JDK1.0-style header files should be generated.
     * @return the old attribute.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getOld</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>old</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * If true, generate C declarations from the Java object file (used with old).
     * @param stubs if true, generated C declarations.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setStubs</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>stubs</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>stubs</name></name> = <name>stubs</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether C declarations from the Java object file should be generated.
     * @return the stubs attribute.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getStubs</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>stubs</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * If true, causes Javah to print a message concerning
     * the status of the generated files.
     * @param verbose if true, do verbose printing.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setVerbose</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>verbose</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>verbose</name></name> = <name>verbose</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether verbose output should get generated.
     * @return the verbose attribute.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getVerbose</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>verbose</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Choose the implementation for this particular task.
     * @param impl the name of the implementation.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setImplementation</name><parameter_list>(<param><decl><type><name>String</name></type> <name>impl</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr>"default".<call><name>equals</name><argument_list>(<argument><expr><name>impl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>facade</name>.<name>setImplementation</name></name><argument_list>(<argument><expr><call><name><name>JavahAdapterFactory</name>.<name>getDefault</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>facade</name>.<name>setImplementation</name></name><argument_list>(<argument><expr><name>impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Adds an implementation specific command-line argument.
     * @return a ImplementationSpecificArgument to be configured.
     *
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>ImplementationSpecificArgument</name></type> <name>createArg</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>ImplementationSpecificArgument</name></type> <name>arg</name> =<init>
            <expr>new <call><name>ImplementationSpecificArgument</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>facade</name>.<name>addImplementationArgument</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>arg</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the (implementation specific) settings given as nested
     * arg elements.
     * @return the arguments.
     * @since Ant 1.6.3
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getCurrentArgs</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>facade</name>.<name>getArgs</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * The classpath to use when loading the javah implementation
     * if it is not a built-in one.
     *
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>Path</name></type> <name>createImplementationClasspath</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>facade</name>.<name>getImplementationClasspath</name></name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Set the adapter explicitly.
     * @since Ant 1.8.0
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>JavahAdapter</name></type> <name>adapter</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>nestedAdapter</name> != <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Can't have more than one javah"
                                     + " adapter"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name>nestedAdapter</name> = <name>adapter</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Execute the task
     *
     * @throws BuildException is there is a problem in the task execution.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <comment type="line">// first off, make sure that we've got a srcdir</comment>

        <if>if <condition>(<expr>(<name>cls</name> == <name>null</name>) &amp;&amp; (<call><name><name>classes</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0) &amp;&amp; (<call><name><name>files</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0)</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"class attribute must be set!"</expr></argument>,
                <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <if>if <condition>(<expr>(<name>cls</name> != <name>null</name>) &amp;&amp; (<call><name><name>classes</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0) &amp;&amp; (<call><name><name>files</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0)</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"set class attribute OR class element OR fileset, "
                + "not 2 or more of them."</expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <if>if <condition>(<expr><name>destDir</name> != <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name><name>destDir</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"destination directory \"" + <name>destDir</name>
                    + "\" does not exist or is not a directory"</expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <if>if <condition>(<expr><name>outputFile</name> != <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"destdir and outputFile are mutually "
                    + "exclusive"</expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></then></if>

        <if>if <condition>(<expr><name>classpath</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>classpath</name> = (new <call><name>Path</name><argument_list>(<argument><expr><call><name>getProject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>).<call><name>concatSystemClasspath</name><argument_list>(<argument><expr>"last"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>classpath</name> = <call><name><name>classpath</name>.<name>concatSystemClasspath</name></name><argument_list>(<argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <decl_stmt><decl><type><name>JavahAdapter</name></type> <name>ad</name> =<init>
            <expr><name>nestedAdapter</name> != <name>null</name> ? <name>nestedAdapter</name> :
            <call><name><name>JavahAdapterFactory</name>.<name>getAdapter</name></name><argument_list>(<argument><expr><call><name><name>facade</name>.<name>getImplementation</name></name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><name>this</name></expr></argument>,
                                           <argument><expr><call><name>createImplementationClasspath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>ad</name>.<name>compile</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"compilation failed"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Logs the compilation parameters, adds the files to compile and logs the
     * &amp;quot;niceSourceList&amp;quot;
     * @param cmd the command line.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>logAndAddFiles</name><parameter_list>(<param><decl><type><name>Commandline</name></type> <name>cmd</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>logAndAddFilesToCompile</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Logs the compilation parameters, adds the files to compile and logs the
     * &amp;quot;niceSourceList&amp;quot;
     * @param cmd the command line to add parameters to.
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>logAndAddFilesToCompile</name><parameter_list>(<param><decl><type><name>Commandline</name></type> <name>cmd</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Compilation " + <call><name><name>cmd</name>.<name>describeArguments</name></name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>niceClassList</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>c</name> =<init> <expr><call><name>getClasses</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>c</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name><name>cmd</name>.<name>createArgument</name></name><argument_list>()</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>niceClassList</name>.<name>append</name></name><argument_list>(<argument><expr>"    "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>niceClassList</name>.<name>append</name></name><argument_list>(<argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>niceClassList</name>.<name>append</name></name><argument_list>(<argument><expr><name><name>StringUtils</name>.<name>LINE_SEP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>prefix</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>(<argument><expr>"Class"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>c</name>.<name>length</name></name> &gt; 1</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>prefix</name>.<name>append</name></name><argument_list>(<argument><expr>"es"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>prefix</name>.<name>append</name></name><argument_list>(<argument><expr>" to be compiled:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>prefix</name>.<name>append</name></name><argument_list>(<argument><expr><name><name>StringUtils</name>.<name>LINE_SEP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><call><name><name>prefix</name>.<name>toString</name></name><argument_list>()</argument_list></call> + <call><name><name>niceClassList</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>
}</block></class>
</unit>
