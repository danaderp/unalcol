<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\taskdefs\StreamPumper.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>InputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>OutputStream</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileUtils</name></name>;</import>

<comment type="javadoc">/**
 * Copies all data from an input stream to an output stream.
 *
 * @since Ant 1.2
 */</comment>
<class><specifier>public</specifier> class <name>StreamPumper</name> <super><implements>implements <name>Runnable</name></implements></super> <block>{

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>SMALL_BUFFER_SIZE</name> =<init> <expr>128</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>InputStream</name></type> <name>is</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>OutputStream</name></type> <name>os</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>volatile</name> <name>boolean</name></type> <name>finish</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>volatile</name> <name>boolean</name></type> <name>finished</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>closeWhenExhausted</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>autoflush</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Exception</name></type> <name>exception</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>bufferSize</name> =<init> <expr><name>SMALL_BUFFER_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>started</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>useAvailable</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Create a new StreamPumper.
     *
     * @param is input stream to read data from
     * @param os output stream to write data to.
     * @param closeWhenExhausted if true, the output stream will be closed when
     *        the input is exhausted.
     */</comment>
    <constructor><specifier>public</specifier> <name>StreamPumper</name><parameter_list>(<param><decl><type><name>InputStream</name></type> <name>is</name></decl></param>, <param><decl><type><name>OutputStream</name></type> <name>os</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>closeWhenExhausted</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>is</name></expr></argument>, <argument><expr><name>os</name></expr></argument>, <argument><expr><name>closeWhenExhausted</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>


    <comment type="javadoc">/**
     * Create a new StreamPumper.
     *
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; If you set useAvailable to true, you must
     * explicitly invoke {@link #stop stop} or interrupt the
     * corresponding Thread when you are done or the run method will
     * never finish on some JVMs (namely those where available returns
     * 0 on a closed stream).  Setting it to true may also impact
     * performance negatively.  This flag should only be set to true
     * if you intend to stop the pumper before the input stream gets
     * closed.&lt;/p&gt;
     *
     * @param is input stream to read data from
     * @param os output stream to write data to.
     * @param closeWhenExhausted if true, the output stream will be closed when
     *        the input is exhausted.
     * @param useAvailable whether the pumper should use {@link
     *        java.io.InputStream#available available} to determine
     *        whether input is ready, thus trying to emulate
     *        non-blocking behavior.
     *
     * @since Ant 1.8.0
     */</comment>
    <constructor><specifier>public</specifier> <name>StreamPumper</name><parameter_list>(<param><decl><type><name>InputStream</name></type> <name>is</name></decl></param>, <param><decl><type><name>OutputStream</name></type> <name>os</name></decl></param>,
                        <param><decl><type><name>boolean</name></type> <name>closeWhenExhausted</name></decl></param>,
                        <param><decl><type><name>boolean</name></type> <name>useAvailable</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>is</name></name> = <name>is</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>os</name></name> = <name>os</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>closeWhenExhausted</name></name> = <name>closeWhenExhausted</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>useAvailable</name></name> = <name>useAvailable</name></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Create a new StreamPumper.
     *
     * @param is input stream to read data from
     * @param os output stream to write data to.
     */</comment>
    <constructor><specifier>public</specifier> <name>StreamPumper</name><parameter_list>(<param><decl><type><name>InputStream</name></type> <name>is</name></decl></param>, <param><decl><type><name>OutputStream</name></type> <name>os</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>is</name></expr></argument>, <argument><expr><name>os</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Set whether data should be flushed through to the output stream.
     * @param autoflush if true, push through data; if false, let it be buffered
     * @since Ant 1.6.3
     */</comment>
    <comment type="block">/*package*/</comment> <function><type><name>void</name></type> <name>setAutoflush</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>autoflush</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>autoflush</name></name> = <name>autoflush</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Copies data from the input stream to the output stream.
     *
     * Terminates as soon as the input stream is closed or an error occurs.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list> <block>{
        <synchronized>synchronized (<expr><name>this</name></expr>) <block>{
            <expr_stmt><expr><name>started</name> = true</expr>;</expr_stmt>
        }</block></synchronized>
        <expr_stmt><expr><name>finished</name> = false</expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buf</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>bufferSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
        <try>try <block>{
            <while>while <condition>(<expr>true</expr>)</condition> <block>{
                <expr_stmt><expr><call><name>waitForInput</name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>finish</name> || <call><name><name>Thread</name>.<name>interrupted</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>

                <expr_stmt><expr><name>length</name> = <call><name><name>is</name>.<name>read</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>length</name> &lt;= 0 || <call><name><name>Thread</name>.<name>interrupted</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>os</name>.<name>write</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>autoflush</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>os</name>.<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>finish</name></expr>)</condition><then> <block>{
                	<break>break;</break>
                }</block></then></if>
            }</block></while>
            <comment type="line">// On completion, drain any available data (which might be the first data available for quick executions)</comment>
            <if>if <condition>(<expr><name>finish</name></expr>)</condition><then> <block>{
                <while>while<condition>(<expr>(<name>length</name> = <call><name><name>is</name>.<name>available</name></name><argument_list>()</argument_list></call>) &gt; 0</expr>)</condition> <block>{
                	<if>if <condition>(<expr><call><name><name>Thread</name>.<name>interrupted</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                		<break>break;</break>
                	}</block></then></if>
                    <expr_stmt><expr><name>length</name> = <call><name><name>is</name>.<name>read</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><name><name>buf</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>length</name> &lt;= 0</expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><call><name><name>os</name>.<name>write</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></while>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>os</name>.<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><name>InterruptedException</name></type> <name>ie</name></decl></param>) <block>{
            <comment type="line">// likely PumpStreamHandler trying to stop us</comment>
        }</block></catch> <catch>catch (<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>) <block>{
            <synchronized>synchronized (<expr><name>this</name></expr>) <block>{
                <expr_stmt><expr><name>exception</name> = <name>e</name></expr>;</expr_stmt>
            }</block></synchronized>
        }</block></catch> <finally>finally <block>{
            <if>if <condition>(<expr><name>closeWhenExhausted</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>FileUtils</name>.<name>close</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>finished</name> = true</expr>;</expr_stmt>
            <expr_stmt><expr><name>finish</name> = false</expr>;</expr_stmt>
            <synchronized>synchronized (<expr><name>this</name></expr>) <block>{
                <expr_stmt><expr><call><name>notifyAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></synchronized>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * Tells whether the end of the stream has been reached.
     * @return true is the stream has been exhausted.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isFinished</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>finished</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * This method blocks until the StreamPumper finishes.
     * @throws InterruptedException if interrupted.
     * @see #isFinished()
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>waitFor</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument></throws> <block>{
        <while>while <condition>(<expr>!<call><name>isFinished</name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>wait</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <comment type="javadoc">/**
     * Set the size in bytes of the read buffer.
     * @param bufferSize the buffer size to use.
     * @throws IllegalStateException if the StreamPumper is already running.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>setBufferSize</name><parameter_list>(<param><decl><type><name>int</name></type> <name>bufferSize</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>started</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Cannot set buffer size on a running StreamPumper"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>bufferSize</name></name> = <name>bufferSize</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Get the size in bytes of the read buffer.
     * @return the int size of the read buffer.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>int</name></type> <name>getBufferSize</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>bufferSize</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Get the exception encountered, if any.
     * @return the Exception encountered.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>Exception</name></type> <name>getException</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>exception</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Stop the pumper as soon as possible.
     * Note that it may continue to block on the input stream
     * but it will really stop the thread as soon as it gets EOF
     * or any byte, and it will be marked as finished.
     * @since Ant 1.6.3
     */</comment>
    <comment type="block">/*package*/</comment> <function><type><specifier>synchronized</specifier> <name>void</name></type> <name>stop</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>finish</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>POLL_INTERVAL</name> =<init> <expr>100</expr></init></decl>;</decl_stmt>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>waitForInput</name><parameter_list>(<param><decl><type><name>InputStream</name></type> <name>is</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>useAvailable</name></expr>)</condition><then> <block>{
            <while>while <condition>(<expr>!<name>finish</name> &amp;&amp; <call><name><name>is</name>.<name>available</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition> <block>{
                <if>if <condition>(<expr><call><name><name>Thread</name>.<name>interrupted</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <throw>throw <expr>new <call><name>InterruptedException</name><argument_list>()</argument_list></call></expr>;</throw>
                }</block></then></if>

                <synchronized>synchronized (<expr><name>this</name></expr>) <block>{
                    <expr_stmt><expr><call><name><name>this</name>.<name>wait</name></name><argument_list>(<argument><expr><name>POLL_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></synchronized>
            }</block></while>
        }</block></then></if>
    }</block></function>

}</block></class>
</unit>
