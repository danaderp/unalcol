<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\bzip2\BlockSort.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>bzip2</name></name>;</package>

<import>import <name><name>java</name>.<name>util</name>.<name>BitSet</name></name>;</import>

<comment type="javadoc">/**
 * Encapsulates the Burrows-Wheeler sorting algorithm needed by {@link
 * CBZip2OutputStream}.
 *
 * &lt;p&gt;This class is based on a Java port of Julian Seward's
 * blocksort.c in his libbzip2&lt;/p&gt;
 *
 * &lt;p&gt;The Burrows-Wheeler transform is a reversible transform of the
 * original data that is supposed to group similiar bytes close to
 * each other.  The idea is to sort all permutations of the input and
 * only keep the last byte of each permutation.  E.g. for "Commons
 * Compress" you'd get:&lt;/p&gt;
 *
 * &lt;pre&gt;
 *  CompressCommons
 * Commons Compress
 * CompressCommons 
 * essCommons Compr
 * mmons CompressCo
 * mons CompressCom
 * mpressCommons Co
 * ns CompressCommo
 * ommons CompressC
 * ompressCommons C
 * ons CompressComm
 * pressCommons Com
 * ressCommons Comp
 * s CompressCommon
 * sCommons Compres
 * ssCommons Compre
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Which results in a new text "ss romooCCmmpnse", in adition the
 * index of the first line that contained the original text is kept -
 * in this case it is 1.  The idea is that in a long English text all
 * permutations that start with "he" are likely suffixes of a "the" and
 * thus they end in "t" leading to a larger block of "t"s that can
 * better be compressed by the subsequent Move-to-Front, run-length
 * und Huffman encoding steps.&lt;/p&gt;
 *
 * &lt;p&gt;For more information see for example:&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;a
 *   href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-124.pdf"&gt;Burrows,
 *   M. and Wheeler, D.: A Block-sorting Lossless Data Compression
 *   Algorithm&lt;/a&gt;&lt;/li&gt;
 *   &lt;li&gt;&lt;a href="http://webglimpse.net/pubs/suffix.pdf"&gt;Manber, U. and
 *   Myers, G.: Suffix arrays: A new method for on-line string
 *   searches&lt;/a&gt;&lt;/li&gt;
 *   &lt;li&gt;&lt;a
 *   href="http://www.cs.tufts.edu/~nr/comp150fp/archive/bob-sedgewick/fast-strings.pdf"&gt;Bentley,
 *   J.L. and Sedgewick, R.: Fast Algorithms for Sorting and Searching
 *   Strings&lt;/a&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @NotThreadSafe
 */</comment>
<class>class <name>BlockSort</name> <block>{

    <comment type="block">/*
     * Some of the constructs used in the C code cannot be ported
     * literally to Java - for example macros, unsigned types.  Some
     * code has been hand-tuned to improve performance.  In order to
     * avoid memory pressure some structures are reused for several
     * blocks and some memory is even shared between sorting and the
     * MTF stage even though either algorithm uses it for its own
     * purpose.
     *
     * Comments preserved from the actual C code are prefixed with
     * "LBZ2:".
     */</comment>

    <comment type="block">/*
     * 2012-05-20 Stefan Bodewig:
     *
     * This class seems to mix several revisions of libbzip2's code.
     * The mainSort function and those used by it look closer to the
     * 0.9.5 version but show some variations introduced later.  At
     * the same time the logic of Compress 1.4 to randomize the block
     * on bad input has been dropped after libbzip2 0.9.0 and replaced
     * by a fallback sorting algorithm.
     *
     * I've added the fallbackSort function of 1.0.6 and tried to
     * integrate it with the existing code without touching too much.
     * I've also removed the now unused randomization code.
     */</comment>

    <comment type="block">/*
     * LBZ2: If you are ever unlucky/improbable enough to get a stack
     * overflow whilst sorting, increase the following constant and
     * try again. In practice I have never seen the stack go above 27
     * elems, so the following limit seems very generous.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>QSORT_STACK_SIZE</name> =<init> <expr>1000</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>FALLBACK_QSORT_STACK_SIZE</name> =<init> <expr>100</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>STACK_SIZE</name> =<init>
        <expr><name>QSORT_STACK_SIZE</name> &lt; <name>FALLBACK_QSORT_STACK_SIZE</name>
        ? <name>FALLBACK_QSORT_STACK_SIZE</name> : <name>QSORT_STACK_SIZE</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Used when sorting. If too many long comparisons happen, we stop sorting,
     * and use fallbackSort instead.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>workDone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>workLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>firstAttempt</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>stack_ll</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>STACK_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 4000 byte</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>stack_hh</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>STACK_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 4000 byte</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>stack_dd</name> =<init> <expr>new <name><name>int</name><index>[<expr><name>QSORT_STACK_SIZE</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 4000 byte</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>mainSort_runningOrder</name> =<init> <expr>new <name><name>int</name><index>[<expr>256</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 1024 byte</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>mainSort_copy</name> =<init> <expr>new <name><name>int</name><index>[<expr>256</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 1024 byte</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name><index>[]</index></type> <name>mainSort_bigDone</name> =<init> <expr>new <name><name>boolean</name><index>[<expr>256</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 256 byte</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>ftab</name> =<init> <expr>new <name><name>int</name><index>[<expr>65537</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// 262148 byte</comment>

    <comment type="javadoc">/**
     * Array instance identical to Data's sfmap, both are used only
     * temporarily and indepently, so we do not need to allocate
     * additional memory.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>char</name><index>[]</index></type> <name>quadrant</name></decl>;</decl_stmt>

    <constructor><name>BlockSort</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>CBZip2OutputStream</name>.<name>Data</name></name></type> <name>data</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>quadrant</name></name> = <name><name>data</name>.<name>sfmap</name></name></expr>;</expr_stmt>
    }</block></constructor>

    <function><type><name>void</name></type> <name>blockSort</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>CBZip2OutputStream</name>.<name>Data</name></name></type> <name>data</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>last</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>workLimit</name></name> = <name>WORK_FACTOR</name> * <name>last</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>workDone</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>firstAttempt</name></name> = true</expr>;</expr_stmt>

        <if>if <condition>(<expr><name>last</name> + 1 &lt; 10000</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fallbackSort</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>mainSort</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name><name>this</name>.<name>firstAttempt</name></name> &amp;&amp; (<name><name>this</name>.<name>workDone</name></name> &gt; <name><name>this</name>.<name>workLimit</name></name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>fallbackSort</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>fmap</name> =<init> <expr><name><name>data</name>.<name>fmap</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>data</name>.<name>origPtr</name></name> = -1</expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>last</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>fmap</name><index>[<expr><name>i</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>data</name>.<name>origPtr</name></name> = <name>i</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>

        <comment type="line">// assert (data.origPtr != -1) : data.origPtr;</comment>
    }</block></function>

    <comment type="javadoc">/**
     * Adapt fallbackSort to the expected interface of the rest of the
     * code, in particular deal with the fact that block starts at
     * offset 1 (in libbzip2 1.0.6 it starts at 0).
     */</comment>
    <function><type><specifier>final</specifier> <name>void</name></type> <name>fallbackSort</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>CBZip2OutputStream</name>.<name>Data</name></name></type> <name>data</name></decl></param>,
                            <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>last</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>data</name>.<name>block</name><index>[<expr>0</expr>]</index></name> = <name><name>data</name>.<name>block</name><index>[<expr><name>last</name> + 1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fallbackSort</name><argument_list>(<argument><expr><name><name>data</name>.<name>fmap</name></name></expr></argument>, <argument><expr><name><name>data</name>.<name>block</name></name></expr></argument>, <argument><expr><name>last</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>last</name> + 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr>--<name><name>data</name>.<name>fmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>last</name> + 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>data</name>.<name>fmap</name><index>[<expr><name>i</name></expr>]</index></name> == -1</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>data</name>.<name>fmap</name><index>[<expr><name>i</name></expr>]</index></name> = <name>last</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>
    }</block></function>

<comment type="block">/*---------------------------------------------*/</comment>

<comment type="block">/*---------------------------------------------*/</comment>
<comment type="block">/*--- LBZ2: Fallback O(N log(N)^2) sorting        ---*/</comment>
<comment type="block">/*--- algorithm, for repetitive blocks      ---*/</comment>
<comment type="block">/*---------------------------------------------*/</comment>

    <comment type="block">/*
     * This is the fallback sorting algorithm libbzip2 1.0.6 uses for
     * repetitive or very short inputs.
     *
     * The idea is inspired by Manber-Myers string suffix sorting
     * algorithm.  First a bucket sort places each permutation of the
     * block into a bucket based on its first byte.  Permutations are
     * represented by pointers to their first character kept in
     * (partially) sorted order inside the array ftab.
     *
     * The next step visits all buckets in order and performs a
     * quicksort on all permutations of the bucket based on the index
     * of the bucket the second byte of the permutation belongs to,
     * thereby forming new buckets.  When arrived here the
     * permutations are sorted up to the second character and we have
     * buckets of permutations that are identical up to two
     * characters.
     *
     * Repeat the step of quicksorting each bucket, now based on the
     * bucket holding the sequence of the third and forth character
     * leading to four byte buckets.  Repeat this doubling of bucket
     * sizes until all buckets only contain single permutations or the
     * bucket size exceeds the block size.
     *
     * I.e.
     *
     * "abraba" form three buckets for the chars "a", "b", and "r" in
     * the first step with
     *
     * fmap = { 'a:' 5, 3, 0, 'b:' 4, 1, 'r', 2 }
     *
     * when looking at the bucket of "a"s the second characters are in
     * the buckets that start with fmap-index 0 (rolled over), 3 and 3
     * respectively, forming two new buckets "aa" and "ab", so we get
     *
     * fmap = { 'aa:' 5, 'ab:' 3, 0, 'ba:' 4, 'br': 1, 'ra:' 2 }
     *
     * since the last bucket only contained a single item it didn't
     * have to be sorted at all.
     *
     * There now is just one bucket with more than one permutation
     * that remains to be sorted.  For the permutation that starts
     * with index 3 the third and forth char are in bucket 'aa' at
     * index 0 and for the one starting at block index 0 they are in
     * bucket 'ra' with sort index 5.  The fully sorted order then becomes.
     *
     * fmap = { 5, 3, 0, 4, 1, 2 }
     * 
     */</comment>

    <comment type="javadoc">/**
     * @param fmap points to the index of the starting point of a
     *        permutation inside the block of data in the current
     *        partially sorted order
     * @param eclass points from the index of a character inside the
     *        block to the first index in fmap that contains the
     *        bucket of its suffix that is sorted in this step.
     * @param lo lower boundary of the fmap-interval to be sorted 
     * @param hi upper boundary of the fmap-interval to be sorted 
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>fallbackSimpleSort</name><parameter_list>(<param><decl><type><name><name>int</name><index>[]</index></name></type> <name>fmap</name></decl></param>, 
                                    <param><decl><type><name><name>int</name><index>[]</index></name></type> <name>eclass</name></decl></param>, 
                                    <param><decl><type><name>int</name></type> <name>lo</name></decl></param>, 
                                    <param><decl><type><name>int</name></type> <name>hi</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>lo</name> == <name>hi</name></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>hi</name> - <name>lo</name> &gt; 3</expr>)</condition><then> <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>hi</name> - 4</expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= <name>lo</name></expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>tmp</name> =<init> <expr><name><name>fmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>ec_tmp</name> =<init> <expr><name><name>eclass</name><index>[<expr><name>tmp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <for>for (<init><expr><name>j</name> = <name>i</name> + 4</expr>;</init> <condition><expr><name>j</name> &lt;= <name>hi</name> &amp;&amp; <name>ec_tmp</name> &gt; <name><name>eclass</name><index>[<expr><name><name>fmap</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr>;</condition>
                     <incr><expr><name>j</name> += 4</expr></incr>) <block>{
                    <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>j</name> - 4</expr>]</index></name> = <name><name>fmap</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>j</name> - 4</expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>hi</name> - 1</expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= <name>lo</name></expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>tmp</name> =<init> <expr><name><name>fmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>ec_tmp</name> =<init> <expr><name><name>eclass</name><index>[<expr><name>tmp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for (<init><expr><name>j</name> = <name>i</name> + 1</expr>;</init> <condition><expr><name>j</name> &lt;= <name>hi</name> &amp;&amp; <name>ec_tmp</name> &gt; <name><name>eclass</name><index>[<expr><name><name>fmap</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>j</name> - 1</expr>]</index></name> = <name><name>fmap</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>j</name>-1</expr>]</index></name> = <name>tmp</name></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>FALLBACK_QSORT_SMALL_THRESH</name> =<init> <expr>10</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * swaps two values in fmap
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>fswap</name><parameter_list>(<param><decl><type><name><name>int</name><index>[]</index></name></type> <name>fmap</name></decl></param>, <param><decl><type><name>int</name></type> <name>zz1</name></decl></param>, <param><decl><type><name>int</name></type> <name>zz2</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>zztmp</name> =<init> <expr><name><name>fmap</name><index>[<expr><name>zz1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>zz1</name></expr>]</index></name> = <name><name>fmap</name><index>[<expr><name>zz2</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>zz2</name></expr>]</index></name> = <name>zztmp</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * swaps two intervals starting at yyp1 and yyp2 of length yyn inside fmap.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>fvswap</name><parameter_list>(<param><decl><type><name><name>int</name><index>[]</index></name></type> <name>fmap</name></decl></param>, <param><decl><type><name>int</name></type> <name>yyp1</name></decl></param>, <param><decl><type><name>int</name></type> <name>yyp2</name></decl></param>, <param><decl><type><name>int</name></type> <name>yyn</name></decl></param>)</parameter_list> <block>{
        <while>while <condition>(<expr><name>yyn</name> &gt; 0</expr>)</condition> <block>{
            <expr_stmt><expr><call><name>fswap</name><argument_list>(<argument><expr><name>fmap</name></expr></argument>, <argument><expr><name>yyp1</name></expr></argument>, <argument><expr><name>yyp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>yyp1</name>++</expr>;</expr_stmt> <expr_stmt><expr><name>yyp2</name>++</expr>;</expr_stmt> <expr_stmt><expr><name>yyn</name>--</expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>fmin</name><parameter_list>(<param><decl><type><name>int</name></type> <name>a</name></decl></param>, <param><decl><type><name>int</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>a</name> &lt; <name>b</name> ? <name>a</name> : <name>b</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>fpush</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sp</name></decl></param>, <param><decl><type><name>int</name></type> <name>lz</name></decl></param>, <param><decl><type><name>int</name></type> <name>hz</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>stack_ll</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>lz</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stack_hh</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>hz</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>int</name><index>[]</index></type> <name>fpop</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sp</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>new <name><name>int</name><index>[]</index></name> <block>{ <expr><name><name>stack_ll</name><index>[<expr><name>sp</name></expr>]</index></name></expr>, <expr><name><name>stack_hh</name><index>[<expr><name>sp</name></expr>]</index></name></expr> }</block></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * @param fmap points to the index of the starting point of a
     *        permutation inside the block of data in the current
     *        partially sorted order
     * @param eclass points from the index of a character inside the
     *        block to the first index in fmap that contains the
     *        bucket of its suffix that is sorted in this step.
     * @param loSt lower boundary of the fmap-interval to be sorted 
     * @param hiSt upper boundary of the fmap-interval to be sorted 
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>fallbackQSort3</name><parameter_list>(<param><decl><type><name><name>int</name><index>[]</index></name></type> <name>fmap</name></decl></param>, 
                                <param><decl><type><name><name>int</name><index>[]</index></name></type> <name>eclass</name></decl></param>, 
                                <param><decl><type><name>int</name></type> <name>loSt</name></decl></param>, 
                                <param><decl><type><name>int</name></type> <name>hiSt</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>lo</name>, <name>unLo</name>, <name>ltLo</name>, <name>hi</name>, <name>unHi</name>, <name>gtHi</name>, <name>n</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>r</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>sp</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fpush</name><argument_list>(<argument><expr><name>sp</name>++</expr></argument>, <argument><expr><name>loSt</name></expr></argument>, <argument><expr><name>hiSt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>sp</name> &gt; 0</expr>)</condition> <block>{
            <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>s</name> =<init> <expr><call><name>fpop</name><argument_list>(<argument><expr>--<name>sp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>lo</name> = <name><name>s</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>hi</name> = <name><name>s</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>hi</name> - <name>lo</name> &lt; <name>FALLBACK_QSORT_SMALL_THRESH</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>fallbackSimpleSort</name><argument_list>(<argument><expr><name>fmap</name></expr></argument>, <argument><expr><name>eclass</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <comment type="block">/* LBZ2: Random partitioning.  Median of 3 sometimes fails to
               avoid bad cases.  Median of 9 seems to help but 
               looks rather expensive.  This too seems to work but
               is cheaper.  Guidance for the magic constants 
               7621 and 32768 is taken from Sedgewick's algorithms
               book, chapter 35.
            */</comment>
            <expr_stmt><expr><name>r</name> = ((<name>r</name> * 7621) + 1) % 32768</expr>;</expr_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>r3</name> =<init> <expr><name>r</name> % 3</expr></init>, <name>med</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>r3</name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>med</name> = <name><name>eclass</name><index>[<expr><name><name>fmap</name><index>[<expr><name>lo</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt> 
            }</block></then> <else>else <if>if <condition>(<expr><name>r3</name> == 1</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>med</name> = <name><name>eclass</name><index>[<expr><name><name>fmap</name><index>[<expr>(<name>lo</name> + <name>hi</name>) &gt;&gt;&gt; 1</expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>med</name> = <name><name>eclass</name><index>[<expr><name><name>fmap</name><index>[<expr><name>hi</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
            }</block></else></if></else></if>

            <expr_stmt><expr><name>unLo</name> = <name>ltLo</name> = <name>lo</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>unHi</name> = <name>gtHi</name> = <name>hi</name></expr>;</expr_stmt>

            <comment type="line">// looks like the ternary partition attributed to Wegner</comment>
            <comment type="line">// in the cited Sedgewick paper</comment>
            <while>while <condition>(<expr>true</expr>)</condition> <block>{
                <while>while <condition>(<expr>true</expr>)</condition> <block>{
                    <if>if <condition>(<expr><name>unLo</name> &gt; <name>unHi</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><name>n</name> = <name><name>eclass</name><index>[<expr><name><name>fmap</name><index>[<expr><name>unLo</name></expr>]</index></name></expr>]</index></name> - (<name>int</name>) <name>med</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{ 
                        <expr_stmt><expr><call><name>fswap</name><argument_list>(<argument><expr><name>fmap</name></expr></argument>, <argument><expr><name>unLo</name></expr></argument>, <argument><expr><name>ltLo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
                        <expr_stmt><expr><name>ltLo</name>++</expr>;</expr_stmt> <expr_stmt><expr><name>unLo</name>++</expr>;</expr_stmt> 
                        <continue>continue;</continue> 
                    }</block></then></if>
                    <if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><name>unLo</name>++</expr>;</expr_stmt>
                }</block></while>
                <while>while <condition>(<expr>true</expr>)</condition> <block>{
                    <if>if <condition>(<expr><name>unLo</name> &gt; <name>unHi</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><name>n</name> = <name><name>eclass</name><index>[<expr><name><name>fmap</name><index>[<expr><name>unHi</name></expr>]</index></name></expr>]</index></name> - (<name>int</name>) <name>med</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>fswap</name><argument_list>(<argument><expr><name>fmap</name></expr></argument>, <argument><expr><name>unHi</name></expr></argument>, <argument><expr><name>gtHi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
                        <expr_stmt><expr><name>gtHi</name>--</expr>;</expr_stmt> <expr_stmt><expr><name>unHi</name>--</expr>;</expr_stmt> 
                        <continue>continue;</continue> 
                    }</block></then></if>
                    <if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><name>unHi</name>--</expr>;</expr_stmt>
                }</block></while>
                <if>if <condition>(<expr><name>unLo</name> &gt; <name>unHi</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name>fswap</name><argument_list>(<argument><expr><name>fmap</name></expr></argument>, <argument><expr><name>unLo</name></expr></argument>, <argument><expr><name>unHi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>unLo</name>++</expr>;</expr_stmt> <expr_stmt><expr><name>unHi</name>--</expr>;</expr_stmt>
            }</block></while>

            <if>if <condition>(<expr><name>gtHi</name> &lt; <name>ltLo</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><name>n</name> = <call><name>fmin</name><argument_list>(<argument><expr><name>ltLo</name> - <name>lo</name></expr></argument>, <argument><expr><name>unLo</name> - <name>ltLo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fvswap</name><argument_list>(<argument><expr><name>fmap</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>unLo</name> - <name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>m</name> =<init> <expr><call><name>fmin</name><argument_list>(<argument><expr><name>hi</name> - <name>gtHi</name></expr></argument>, <argument><expr><name>gtHi</name> - <name>unHi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>fvswap</name><argument_list>(<argument><expr><name>fmap</name></expr></argument>, <argument><expr><name>unHi</name> + 1</expr></argument>, <argument><expr><name>hi</name> - <name>m</name> + 1</expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>n</name> = <name>lo</name> + <name>unLo</name> - <name>ltLo</name> - 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>m</name> = <name>hi</name> - (<name>gtHi</name> - <name>unHi</name>) + 1</expr>;</expr_stmt>

            <if>if <condition>(<expr><name>n</name> - <name>lo</name> &gt; <name>hi</name> - <name>m</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>fpush</name><argument_list>(<argument><expr><name>sp</name>++</expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fpush</name><argument_list>(<argument><expr><name>sp</name>++</expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>fpush</name><argument_list>(<argument><expr><name>sp</name>++</expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fpush</name><argument_list>(<argument><expr><name>sp</name>++</expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>
    }</block></function>


<comment type="block">/*---------------------------------------------*/</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name><index>[]</index></type> <name>eclass</name></decl>;</decl_stmt>

    <function><type><specifier>private</specifier> <name>int</name><index>[]</index></type> <name>getEclass</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>eclass</name> == <name>null</name>
            ? (<name>eclass</name> = new <name><name>int</name><index>[<expr><name><name>quadrant</name>.<name>length</name></name> / 2</expr>]</index></name>) : <name>eclass</name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * The C code uses an array of ints (each int holding 32 flags) to
     * represents the bucket-start flags (bhtab).  It also contains
     * optimizations to skip over 32 consecutively set or
     * consecutively unset bits on word boundaries at once.  For now
     * I've chosen to use the simpler but potentially slower code
     * using BitSet - also in the hope that using the BitSet#nextXXX
     * methods may be fast enough.
     */</comment>

    <comment type="javadoc">/**
     * @param fmap points to the index of the starting point of a
     *        permutation inside the block of data in the current
     *        partially sorted order
     * @param block the original data
     * @param nblock size of the block
     * @param off offset of first byte to sort in block
     */</comment>
    <function><type><specifier>final</specifier> <name>void</name></type> <name>fallbackSort</name><parameter_list>(<param><decl><type><name><name>int</name><index>[]</index></name></type> <name>fmap</name></decl></param>, <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>block</name></decl></param>, <param><decl><type><name>int</name></type> <name>nblock</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>ftab</name> =<init> <expr>new <name><name>int</name><index>[<expr>257</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>H</name>, <name>i</name>, <name>j</name>, <name>k</name>, <name>l</name>, <name>r</name>, <name>cc</name>, <name>cc1</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nNotDone</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nBhtab</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>eclass</name> =<init> <expr><call><name>getEclass</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nblock</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>eclass</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        }</block></for>
        <comment type="block">/*--
          LBZ2: Initial 1-char radix sort to generate
          initial fmap and initial BH bits.
          --*/</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nblock</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>ftab</name><index>[<expr><name><name>block</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xff</expr>]</index></name>++</expr>;</expr_stmt>
        }</block></for>
        <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; 257</expr>;</condition>    <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>ftab</name><index>[<expr><name>i</name></expr>]</index></name> += <name><name>ftab</name><index>[<expr><name>i</name> - 1</expr>]</index></name></expr>;</expr_stmt>
        }</block></for>

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nblock</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>j</name> = <name><name>block</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xff</expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name> = <name><name>ftab</name><index>[<expr><name>j</name></expr>]</index></name> - 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ftab</name><index>[<expr><name>j</name></expr>]</index></name> = <name>k</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>k</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><name>nBhtab</name> = 64 + <name>nblock</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>BitSet</name></type> <name>bhtab</name> =<init> <expr>new <call><name>BitSet</name><argument_list>(<argument><expr><name>nBhtab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name><name>bhtab</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>ftab</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="block">/*--
          LBZ2: Inductively refine the buckets.  Kind-of an
          "exponential radix sort" (!), inspired by the
          Manber-Myers suffix array construction algorithm.
          --*/</comment>

        <comment type="block">/*-- LBZ2: set sentinel bits for block-end detection --*/</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 32</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{ 
            <expr_stmt><expr><call><name><name>bhtab</name>.<name>set</name></name><argument_list>(<argument><expr><name>nblock</name> + 2 * <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>bhtab</name>.<name>clear</name></name><argument_list>(<argument><expr><name>nblock</name> + 2 * <name>i</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="block">/*-- LBZ2: the log(N) loop --*/</comment>
        <expr_stmt><expr><name>H</name> = 1</expr>;</expr_stmt>
        <while>while <condition>(<expr>true</expr>)</condition> <block>{

            <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nblock</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><call><name><name>bhtab</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>k</name> = <name><name>fmap</name><index>[<expr><name>i</name></expr>]</index></name> - <name>H</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>k</name> &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>k</name> += <name>nblock</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name><name>eclass</name><index>[<expr><name>k</name></expr>]</index></name> = <name>j</name></expr>;</expr_stmt>
            }</block></for>

            <expr_stmt><expr><name>nNotDone</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>r</name> = -1</expr>;</expr_stmt>
            <while>while <condition>(<expr>true</expr>)</condition> <block>{

                <comment type="block">/*-- LBZ2: find the next non-singleton bucket --*/</comment>
                <expr_stmt><expr><name>k</name> = <name>r</name> + 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>k</name> = <call><name><name>bhtab</name>.<name>nextClearBit</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>l</name> = <name>k</name> - 1</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>l</name> &gt;= <name>nblock</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><name>k</name> = <call><name><name>bhtab</name>.<name>nextSetBit</name></name><argument_list>(<argument><expr><name>k</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>r</name> = <name>k</name> - 1</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>r</name> &gt;= <name>nblock</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>

                <comment type="block">/*-- LBZ2: now [l, r] bracket current bucket --*/</comment>
                <if>if <condition>(<expr><name>r</name> &gt; <name>l</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>nNotDone</name> += (<name>r</name> - <name>l</name> + 1)</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fallbackQSort3</name><argument_list>(<argument><expr><name>fmap</name></expr></argument>, <argument><expr><name>eclass</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*-- LBZ2: scan bucket and generate header bits-- */</comment>
                    <expr_stmt><expr><name>cc</name> = -1</expr>;</expr_stmt>
                    <for>for (<init><expr><name>i</name> = <name>l</name></expr>;</init> <condition><expr><name>i</name> &lt;= <name>r</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                        <expr_stmt><expr><name>cc1</name> = <name><name>eclass</name><index>[<expr><name><name>fmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>cc</name> != <name>cc1</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>bhtab</name>.<name>set</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>cc</name> = <name>cc1</name></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></for>
                }</block></then></if>
            }</block></while>

            <expr_stmt><expr><name>H</name> *= 2</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>H</name> &gt; <name>nblock</name> || <name>nNotDone</name> == 0</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
        }</block></while>
    }</block></function>

<comment type="block">/*---------------------------------------------*/</comment>

    <comment type="block">/*
     * LBZ2: Knuth's increments seem to work better than Incerpi-Sedgewick here.
     * Possibly because the number of elems to sort is usually small, typically
     * &amp;lt;= 20.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>INCS</name> =<init> <expr><block>{ <expr>1</expr>, <expr>4</expr>, <expr>13</expr>, <expr>40</expr>, <expr>121</expr>, <expr>364</expr>, <expr>1093</expr>, <expr>3280</expr>,
                                        <expr>9841</expr>, <expr>29524</expr>, <expr>88573</expr>, <expr>265720</expr>, <expr>797161</expr>,
                                        <expr>2391484</expr> }</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This is the most hammered method of this class.
     *
     * &lt;p&gt;
     * This is the version using unrolled loops. Normally I never use such ones
     * in Java code. The unrolling has shown a noticable performance improvement
     * on JRE 1.4.2 (Linux i586 / HotSpot Client). Of course it depends on the
     * JIT compiler of the vm.
     * &lt;/p&gt;
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>mainSimpleSort</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>CBZip2OutputStream</name>.<name>Data</name></name></type> <name>dataShadow</name></decl></param>,
                                   <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>lo</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>hi</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>d</name></decl></param>,
                                   <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>lastShadow</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>bigN</name> =<init> <expr><name>hi</name> - <name>lo</name> + 1</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>bigN</name> &lt; 2</expr>)</condition><then> <block>{
            <return>return <expr><name><name>this</name>.<name>firstAttempt</name></name> &amp;&amp; (<name><name>this</name>.<name>workDone</name></name> &gt; <name><name>this</name>.<name>workLimit</name></name>)</expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name>hp</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name><name>INCS</name><index>[<expr><name>hp</name></expr>]</index></name> &lt; <name>bigN</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>hp</name>++</expr>;</expr_stmt>
        }</block></while>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>fmap</name> =<init> <expr><name><name>dataShadow</name>.<name>fmap</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name><index>[]</index></type> <name>quadrant</name> =<init> <expr><name><name>this</name>.<name>quadrant</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>block</name> =<init> <expr><name><name>dataShadow</name>.<name>block</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>lastPlus1</name> =<init> <expr><name>lastShadow</name> + 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>firstAttemptShadow</name> =<init> <expr><name><name>this</name>.<name>firstAttempt</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>workLimitShadow</name> =<init> <expr><name><name>this</name>.<name>workLimit</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>workDoneShadow</name> =<init> <expr><name><name>this</name>.<name>workDone</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Following block contains unrolled code which could be shortened by</comment>
        <comment type="line">// coding it in additional loops.</comment>

        <label><name>HP</name>:</label> <while>while <condition>(<expr>--<name>hp</name> &gt;= 0</expr>)</condition> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>h</name> =<init> <expr><name><name>INCS</name><index>[<expr><name>hp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>mj</name> =<init> <expr><name>lo</name> + <name>h</name> - 1</expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>lo</name> + <name>h</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>hi</name></expr>;</condition><incr/>) <block>{
                <comment type="line">// copy</comment>
                <for>for (<init><decl><type><name>int</name></type> <name>k</name> =<init> <expr>3</expr></init></decl>;</init> <condition><expr>(<name>i</name> &lt;= <name>hi</name>) &amp;&amp; (--<name>k</name> &gt;= 0)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>v</name> =<init> <expr><name><name>fmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>vd</name> =<init> <expr><name>v</name> + <name>d</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name>i</name></expr></init></decl>;</decl_stmt>

                    <comment type="line">// for (int a;</comment>
                    <comment type="line">// (j &gt; mj) &amp;&amp; mainGtU((a = fmap[j - h]) + d, vd,</comment>
                    <comment type="line">// block, quadrant, lastShadow);</comment>
                    <comment type="line">// j -= h) {</comment>
                    <comment type="line">// fmap[j] = a;</comment>
                    <comment type="line">// }</comment>
                    <comment type="line">//</comment>
                    <comment type="line">// unrolled version:</comment>

                    <comment type="line">// start inline mainGTU</comment>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>onceRunned</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>a</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

                    <label><name>HAMMER</name>:</label> <while>while <condition>(<expr>true</expr>)</condition> <block>{
                        <if>if <condition>(<expr><name>onceRunned</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>j</name></expr>]</index></name> = <name>a</name></expr>;</expr_stmt>
                            <if>if <condition>(<expr>(<name>j</name> -= <name>h</name>) &lt;= <name>mj</name></expr>)</condition><then> <block>{
                                <break>break HAMMER;</break>
                            }</block></then></if>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><name>onceRunned</name> = true</expr>;</expr_stmt>
                        }</block></else></if>

                        <expr_stmt><expr><name>a</name> = <name><name>fmap</name><index>[<expr><name>j</name> - <name>h</name></expr>]</index></name></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>i1</name> =<init> <expr><name>a</name> + <name>d</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>i2</name> =<init> <expr><name>vd</name></expr></init></decl>;</decl_stmt>

                        <comment type="line">// following could be done in a loop, but</comment>
                        <comment type="line">// unrolled it for performance:</comment>
                        <if>if <condition>(<expr><name><name>block</name><index>[<expr><name>i1</name> + 1</expr>]</index></name> == <name><name>block</name><index>[<expr><name>i2</name> + 1</expr>]</index></name></expr>)</condition><then> <block>{
                            <if>if <condition>(<expr><name><name>block</name><index>[<expr><name>i1</name> + 2</expr>]</index></name> == <name><name>block</name><index>[<expr><name>i2</name> + 2</expr>]</index></name></expr>)</condition><then> <block>{
                                <if>if <condition>(<expr><name><name>block</name><index>[<expr><name>i1</name> + 3</expr>]</index></name> == <name><name>block</name><index>[<expr><name>i2</name> + 3</expr>]</index></name></expr>)</condition><then> <block>{
                                    <if>if <condition>(<expr><name><name>block</name><index>[<expr><name>i1</name> + 4</expr>]</index></name> == <name><name>block</name><index>[<expr><name>i2</name> + 4</expr>]</index></name></expr>)</condition><then> <block>{
                                        <if>if <condition>(<expr><name><name>block</name><index>[<expr><name>i1</name> + 5</expr>]</index></name> == <name><name>block</name><index>[<expr><name>i2</name> + 5</expr>]</index></name></expr>)</condition><then> <block>{
                                            <if>if <condition>(<expr><name><name>block</name><index>[<expr>(<name>i1</name> += 6)</expr>]</index></name> == <name><name>block</name><index>[<expr>(<name>i2</name> += 6)</expr>]</index></name></expr>)</condition><then> <block>{
                                                <decl_stmt><decl><type><name>int</name></type> <name>x</name> =<init> <expr><name>lastShadow</name></expr></init></decl>;</decl_stmt>
                                                <label><name>X</name>:</label> <while>while <condition>(<expr><name>x</name> &gt; 0</expr>)</condition> <block>{
                                                    <expr_stmt><expr><name>x</name> -= 4</expr>;</expr_stmt>

                                                    <if>if <condition>(<expr><name><name>block</name><index>[<expr><name>i1</name> + 1</expr>]</index></name> == <name><name>block</name><index>[<expr><name>i2</name> + 1</expr>]</index></name></expr>)</condition><then> <block>{
                                                        <if>if <condition>(<expr><name><name>quadrant</name><index>[<expr><name>i1</name></expr>]</index></name> == <name><name>quadrant</name><index>[<expr><name>i2</name></expr>]</index></name></expr>)</condition><then> <block>{
                                                            <if>if <condition>(<expr><name><name>block</name><index>[<expr><name>i1</name> + 2</expr>]</index></name> == <name><name>block</name><index>[<expr><name>i2</name> + 2</expr>]</index></name></expr>)</condition><then> <block>{
                                                                <if>if <condition>(<expr><name><name>quadrant</name><index>[<expr><name>i1</name> + 1</expr>]</index></name> == <name><name>quadrant</name><index>[<expr><name>i2</name> + 1</expr>]</index></name></expr>)</condition><then> <block>{
                                                                    <if>if <condition>(<expr><name><name>block</name><index>[<expr><name>i1</name> + 3</expr>]</index></name> == <name><name>block</name><index>[<expr><name>i2</name> + 3</expr>]</index></name></expr>)</condition><then> <block>{
                                                                        <if>if <condition>(<expr><name><name>quadrant</name><index>[<expr><name>i1</name> + 2</expr>]</index></name> == <name><name>quadrant</name><index>[<expr><name>i2</name> + 2</expr>]</index></name></expr>)</condition><then> <block>{
                                                                            <if>if <condition>(<expr><name><name>block</name><index>[<expr><name>i1</name> + 4</expr>]</index></name> == <name><name>block</name><index>[<expr><name>i2</name> + 4</expr>]</index></name></expr>)</condition><then> <block>{
                                                                                <if>if <condition>(<expr><name><name>quadrant</name><index>[<expr><name>i1</name> + 3</expr>]</index></name> == <name><name>quadrant</name><index>[<expr><name>i2</name> + 3</expr>]</index></name></expr>)</condition><then> <block>{
                                                                                    <if>if <condition>(<expr>(<name>i1</name> += 4) &gt;= <name>lastPlus1</name></expr>)</condition><then> <block>{
                                                                                        <expr_stmt><expr><name>i1</name> -= <name>lastPlus1</name></expr>;</expr_stmt>
                                                                                    }</block></then></if>
                                                                                    <if>if <condition>(<expr>(<name>i2</name> += 4) &gt;= <name>lastPlus1</name></expr>)</condition><then> <block>{
                                                                                        <expr_stmt><expr><name>i2</name> -= <name>lastPlus1</name></expr>;</expr_stmt>
                                                                                    }</block></then></if>
                                                                                    <expr_stmt><expr><name>workDoneShadow</name>++</expr>;</expr_stmt>
                                                                                    <continue>continue X;</continue>
                                                                                }</block></then> <else>else <if>if <condition>(<expr>(<name><name>quadrant</name><index>[<expr><name>i1</name> + 3</expr>]</index></name> &gt; <name><name>quadrant</name><index>[<expr><name>i2</name> + 3</expr>]</index></name>)</expr>)</condition><then> <block>{
                                                                                    <continue>continue HAMMER;</continue>
                                                                                }</block></then> <else>else <block>{
                                                                                    <break>break HAMMER;</break>
                                                                                }</block></else></if></else></if>
                                                                            }</block></then> <else>else <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i1</name> + 4</expr>]</index></name> &amp; 0xff) &gt; (<name><name>block</name><index>[<expr><name>i2</name> + 4</expr>]</index></name> &amp; 0xff)</expr>)</condition><then> <block>{
                                                                                <continue>continue HAMMER;</continue>
                                                                            }</block></then> <else>else <block>{
                                                                                <break>break HAMMER;</break>
                                                                            }</block></else></if></else></if>
                                                                        }</block></then> <else>else <if>if <condition>(<expr>(<name><name>quadrant</name><index>[<expr><name>i1</name> + 2</expr>]</index></name> &gt; <name><name>quadrant</name><index>[<expr><name>i2</name> + 2</expr>]</index></name>)</expr>)</condition><then> <block>{
                                                                            <continue>continue HAMMER;</continue>
                                                                        }</block></then> <else>else <block>{
                                                                            <break>break HAMMER;</break>
                                                                        }</block></else></if></else></if>
                                                                    }</block></then> <else>else <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i1</name> + 3</expr>]</index></name> &amp; 0xff) &gt; (<name><name>block</name><index>[<expr><name>i2</name> + 3</expr>]</index></name> &amp; 0xff)</expr>)</condition><then> <block>{
                                                                        <continue>continue HAMMER;</continue>
                                                                    }</block></then> <else>else <block>{
                                                                        <break>break HAMMER;</break>
                                                                    }</block></else></if></else></if>
                                                                }</block></then> <else>else <if>if <condition>(<expr>(<name><name>quadrant</name><index>[<expr><name>i1</name> + 1</expr>]</index></name> &gt; <name><name>quadrant</name><index>[<expr><name>i2</name> + 1</expr>]</index></name>)</expr>)</condition><then> <block>{
                                                                    <continue>continue HAMMER;</continue>
                                                                }</block></then> <else>else <block>{
                                                                    <break>break HAMMER;</break>
                                                                }</block></else></if></else></if>
                                                            }</block></then> <else>else <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i1</name> + 2</expr>]</index></name> &amp; 0xff) &gt; (<name><name>block</name><index>[<expr><name>i2</name> + 2</expr>]</index></name> &amp; 0xff)</expr>)</condition><then> <block>{
                                                                <continue>continue HAMMER;</continue>
                                                            }</block></then> <else>else <block>{
                                                                <break>break HAMMER;</break>
                                                            }</block></else></if></else></if>
                                                        }</block></then> <else>else <if>if <condition>(<expr>(<name><name>quadrant</name><index>[<expr><name>i1</name></expr>]</index></name> &gt; <name><name>quadrant</name><index>[<expr><name>i2</name></expr>]</index></name>)</expr>)</condition><then> <block>{
                                                            <continue>continue HAMMER;</continue>
                                                        }</block></then> <else>else <block>{
                                                            <break>break HAMMER;</break>
                                                        }</block></else></if></else></if>
                                                    }</block></then> <else>else <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i1</name> + 1</expr>]</index></name> &amp; 0xff) &gt; (<name><name>block</name><index>[<expr><name>i2</name> + 1</expr>]</index></name> &amp; 0xff)</expr>)</condition><then> <block>{
                                                        <continue>continue HAMMER;</continue>
                                                    }</block></then> <else>else <block>{
                                                        <break>break HAMMER;</break>
                                                    }</block></else></if></else></if>

                                                }</block></while>
                                                <break>break HAMMER;</break>
                                            }</block></then> <comment type="line">// while x &gt; 0</comment>
                                            <else>else <block>{
                                                <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i1</name></expr>]</index></name> &amp; 0xff) &gt; (<name><name>block</name><index>[<expr><name>i2</name></expr>]</index></name> &amp; 0xff)</expr>)</condition><then> <block>{
                                                    <continue>continue HAMMER;</continue>
                                                }</block></then> <else>else <block>{
                                                    <break>break HAMMER;</break>
                                                }</block></else></if>
                                            }</block></else></if>
                                        }</block></then> <else>else <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i1</name> + 5</expr>]</index></name> &amp; 0xff) &gt; (<name><name>block</name><index>[<expr><name>i2</name> + 5</expr>]</index></name> &amp; 0xff)</expr>)</condition><then> <block>{
                                            <continue>continue HAMMER;</continue>
                                        }</block></then> <else>else <block>{
                                            <break>break HAMMER;</break>
                                        }</block></else></if></else></if>
                                    }</block></then> <else>else <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i1</name> + 4</expr>]</index></name> &amp; 0xff) &gt; (<name><name>block</name><index>[<expr><name>i2</name> + 4</expr>]</index></name> &amp; 0xff)</expr>)</condition><then> <block>{
                                        <continue>continue HAMMER;</continue>
                                    }</block></then> <else>else <block>{
                                        <break>break HAMMER;</break>
                                    }</block></else></if></else></if>
                                }</block></then> <else>else <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i1</name> + 3</expr>]</index></name> &amp; 0xff) &gt; (<name><name>block</name><index>[<expr><name>i2</name> + 3</expr>]</index></name> &amp; 0xff)</expr>)</condition><then> <block>{
                                    <continue>continue HAMMER;</continue>
                                }</block></then> <else>else <block>{
                                    <break>break HAMMER;</break>
                                }</block></else></if></else></if>
                            }</block></then> <else>else <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i1</name> + 2</expr>]</index></name> &amp; 0xff) &gt; (<name><name>block</name><index>[<expr><name>i2</name> + 2</expr>]</index></name> &amp; 0xff)</expr>)</condition><then> <block>{
                                <continue>continue HAMMER;</continue>
                            }</block></then> <else>else <block>{
                                <break>break HAMMER;</break>
                            }</block></else></if></else></if>
                        }</block></then> <else>else <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i1</name> + 1</expr>]</index></name> &amp; 0xff) &gt; (<name><name>block</name><index>[<expr><name>i2</name> + 1</expr>]</index></name> &amp; 0xff)</expr>)</condition><then> <block>{
                            <continue>continue HAMMER;</continue>
                        }</block></then> <else>else <block>{
                            <break>break HAMMER;</break>
                        }</block></else></if></else></if>

                    }</block></while> <comment type="line">// HAMMER</comment>
                    <comment type="line">// end inline mainGTU</comment>

                    <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>j</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
                }</block></for>

                <if>if <condition>(<expr><name>firstAttemptShadow</name> &amp;&amp; (<name>i</name> &lt;= <name>hi</name>)
                    &amp;&amp; (<name>workDoneShadow</name> &gt; <name>workLimitShadow</name>)</expr>)</condition><then> <block>{
                    <break>break HP;</break>
                }</block></then></if>
            }</block></for>
        }</block></while>

        <expr_stmt><expr><name><name>this</name>.<name>workDone</name></name> = <name>workDoneShadow</name></expr>;</expr_stmt>
        <return>return <expr><name>firstAttemptShadow</name> &amp;&amp; (<name>workDoneShadow</name> &gt; <name>workLimitShadow</name>)</expr>;</return>
    }</block></function>

<comment type="block">/*--
   LBZ2: The following is an implementation of
   an elegant 3-way quicksort for strings,
   described in a paper "Fast Algorithms for
   Sorting and Searching Strings", by Robert
   Sedgewick and Jon L. Bentley.
--*/</comment>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>vswap</name><parameter_list>(<param><decl><type><name><name>int</name><index>[]</index></name></type> <name>fmap</name></decl></param>, <param><decl><type><name>int</name></type> <name>p1</name></decl></param>, <param><decl><type><name>int</name></type> <name>p2</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>n</name> += <name>p1</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>p1</name> &lt; <name>n</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>t</name> =<init> <expr><name><name>fmap</name><index>[<expr><name>p1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>p1</name>++</expr>]</index></name> = <name><name>fmap</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>p2</name>++</expr>]</index></name> = <name>t</name></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>byte</name></type> <name>med3</name><parameter_list>(<param><decl><type><name>byte</name></type> <name>a</name></decl></param>, <param><decl><type><name>byte</name></type> <name>b</name></decl></param>, <param><decl><type><name>byte</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>a</name> &lt; <name>b</name>) ? (<name>b</name> &lt; <name>c</name> ? <name>b</name> : <name>a</name> &lt; <name>c</name> ? <name>c</name> : <name>a</name>) : (<name>b</name> &gt; <name>c</name> ? <name>b</name> : <name>a</name> &gt; <name>c</name> ? <name>c</name>
                                                        : <name>a</name>)</expr>;</return>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>SMALL_THRESH</name> =<init> <expr>20</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEPTH_THRESH</name> =<init> <expr>10</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>WORK_FACTOR</name> =<init> <expr>30</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Method "mainQSort3", file "blocksort.c", BZip2 1.0.2
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>mainQSort3</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>CBZip2OutputStream</name>.<name>Data</name></name></type> <name>dataShadow</name></decl></param>,
                            <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>loSt</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>hiSt</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>dSt</name></decl></param>,
                            <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>last</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>stack_ll</name> =<init> <expr><name><name>this</name>.<name>stack_ll</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>stack_hh</name> =<init> <expr><name><name>this</name>.<name>stack_hh</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>stack_dd</name> =<init> <expr><name><name>this</name>.<name>stack_dd</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>fmap</name> =<init> <expr><name><name>dataShadow</name>.<name>fmap</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>block</name> =<init> <expr><name><name>dataShadow</name>.<name>block</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>stack_ll</name><index>[<expr>0</expr>]</index></name> = <name>loSt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stack_hh</name><index>[<expr>0</expr>]</index></name> = <name>hiSt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stack_dd</name><index>[<expr>0</expr>]</index></name> = <name>dSt</name></expr>;</expr_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>sp</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr>--<name>sp</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>lo</name> =<init> <expr><name><name>stack_ll</name><index>[<expr><name>sp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>hi</name> =<init> <expr><name><name>stack_hh</name><index>[<expr><name>sp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>d</name> =<init> <expr><name><name>stack_dd</name><index>[<expr><name>sp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr>(<name>hi</name> - <name>lo</name> &lt; <name>SMALL_THRESH</name>) || (<name>d</name> &gt; <name>DEPTH_THRESH</name>)</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>mainSimpleSort</name><argument_list>(<argument><expr><name>dataShadow</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return;</return>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>d1</name> =<init> <expr><name>d</name> + 1</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>med</name> =<init> <expr><call><name>med3</name><argument_list>(<argument><expr><name><name>block</name><index>[<expr><name><name>fmap</name><index>[<expr><name>lo</name></expr>]</index></name> + <name>d1</name></expr>]</index></name></expr></argument>,
                                     <argument><expr><name><name>block</name><index>[<expr><name><name>fmap</name><index>[<expr><name>hi</name></expr>]</index></name> + <name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>block</name><index>[<expr><name><name>fmap</name><index>[<expr>(<name>lo</name> + <name>hi</name>) &gt;&gt;&gt; 1</expr>]</index></name> + <name>d1</name></expr>]</index></name></expr></argument>)</argument_list></call> &amp; 0xff</expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>unLo</name> =<init> <expr><name>lo</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>unHi</name> =<init> <expr><name>hi</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>ltLo</name> =<init> <expr><name>lo</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>gtHi</name> =<init> <expr><name>hi</name></expr></init></decl>;</decl_stmt>

                <while>while <condition>(<expr>true</expr>)</condition> <block>{
                    <while>while <condition>(<expr><name>unLo</name> &lt;= <name>unHi</name></expr>)</condition> <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>n</name> =<init> <expr>(<name><name>block</name><index>[<expr><name><name>fmap</name><index>[<expr><name>unLo</name></expr>]</index></name> + <name>d1</name></expr>]</index></name> &amp; 0xff)
                            - <name>med</name></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>temp</name> =<init> <expr><name><name>fmap</name><index>[<expr><name>unLo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>unLo</name>++</expr>]</index></name> = <name><name>fmap</name><index>[<expr><name>ltLo</name></expr>]</index></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>ltLo</name>++</expr>]</index></name> = <name>temp</name></expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>unLo</name>++</expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <break>break;</break>
                        }</block></else></if></else></if>
                    }</block></while>

                    <while>while <condition>(<expr><name>unLo</name> &lt;= <name>unHi</name></expr>)</condition> <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>n</name> =<init> <expr>(<name><name>block</name><index>[<expr><name><name>fmap</name><index>[<expr><name>unHi</name></expr>]</index></name> + <name>d1</name></expr>]</index></name> &amp; 0xff)
                            - <name>med</name></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>temp</name> =<init> <expr><name><name>fmap</name><index>[<expr><name>unHi</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>unHi</name>--</expr>]</index></name> = <name><name>fmap</name><index>[<expr><name>gtHi</name></expr>]</index></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>gtHi</name>--</expr>]</index></name> = <name>temp</name></expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>unHi</name>--</expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <break>break;</break>
                        }</block></else></if></else></if>
                    }</block></while>

                    <if>if <condition>(<expr><name>unLo</name> &lt;= <name>unHi</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>temp</name> =<init> <expr><name><name>fmap</name><index>[<expr><name>unLo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>unLo</name>++</expr>]</index></name> = <name><name>fmap</name><index>[<expr><name>unHi</name></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>fmap</name><index>[<expr><name>unHi</name>--</expr>]</index></name> = <name>temp</name></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <break>break;</break>
                    }</block></else></if>
                }</block></while>

                <if>if <condition>(<expr><name>gtHi</name> &lt; <name>ltLo</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>stack_ll</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>lo</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stack_hh</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>hi</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stack_dd</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>d1</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>sp</name>++</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr>((<name>ltLo</name> - <name>lo</name>) &lt; (<name>unLo</name> - <name>ltLo</name>)) ? (<name>ltLo</name> - <name>lo</name>)
                        : (<name>unLo</name> - <name>ltLo</name>)</expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>vswap</name><argument_list>(<argument><expr><name>fmap</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>unLo</name> - <name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>m</name> =<init> <expr>((<name>hi</name> - <name>gtHi</name>) &lt; (<name>gtHi</name> - <name>unHi</name>)) ? (<name>hi</name> - <name>gtHi</name>)
                        : (<name>gtHi</name> - <name>unHi</name>)</expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>vswap</name><argument_list>(<argument><expr><name>fmap</name></expr></argument>, <argument><expr><name>unLo</name></expr></argument>, <argument><expr><name>hi</name> - <name>m</name> + 1</expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>n</name> = <name>lo</name> + <name>unLo</name> - <name>ltLo</name> - 1</expr>;</expr_stmt>
                    <expr_stmt><expr><name>m</name> = <name>hi</name> - (<name>gtHi</name> - <name>unHi</name>) + 1</expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>stack_ll</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>lo</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stack_hh</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>n</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stack_dd</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>d</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>sp</name>++</expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>stack_ll</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>n</name> + 1</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stack_hh</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>m</name> - 1</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stack_dd</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>d1</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>sp</name>++</expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>stack_ll</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>m</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stack_hh</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>hi</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stack_dd</name><index>[<expr><name>sp</name></expr>]</index></name> = <name>d</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>sp</name>++</expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if>
        }</block></for>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>SETMASK</name> =<init> <expr>(1 &lt;&lt; 21)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CLEARMASK</name> =<init> <expr>(~<name>SETMASK</name>)</expr></init></decl>;</decl_stmt>

    <function><type><specifier>final</specifier> <name>void</name></type> <name>mainSort</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>CBZip2OutputStream</name>.<name>Data</name></name></type> <name>dataShadow</name></decl></param>,
                        <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>lastShadow</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>runningOrder</name> =<init> <expr><name><name>this</name>.<name>mainSort_runningOrder</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>copy</name> =<init> <expr><name><name>this</name>.<name>mainSort_copy</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name><index>[]</index></type> <name>bigDone</name> =<init> <expr><name><name>this</name>.<name>mainSort_bigDone</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>ftab</name> =<init> <expr><name><name>this</name>.<name>ftab</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>block</name> =<init> <expr><name><name>dataShadow</name>.<name>block</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name><index>[]</index></type> <name>fmap</name> =<init> <expr><name><name>dataShadow</name>.<name>fmap</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name><index>[]</index></type> <name>quadrant</name> =<init> <expr><name><name>this</name>.<name>quadrant</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>workLimitShadow</name> =<init> <expr><name><name>this</name>.<name>workLimit</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>firstAttemptShadow</name> =<init> <expr><name><name>this</name>.<name>firstAttempt</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// LBZ2: Set up the 2-byte frequency table</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>65537</expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name><name>ftab</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        }</block></for>

        <comment type="block">/*
         * In the various block-sized structures, live data runs from 0 to
         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area
         * for block.
         */</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>BZip2Constants</name>.<name>NUM_OVERSHOOT_BYTES</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>block</name><index>[<expr><name>lastShadow</name> + <name>i</name> + 2</expr>]</index></name> = <name><name>block</name><index>[<expr>(<name>i</name> % (<name>lastShadow</name> + 1)) + 1</expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>lastShadow</name> + <name><name>BZip2Constants</name>.<name>NUM_OVERSHOOT_BYTES</name></name> +1</expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name><name>quadrant</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name><name>block</name><index>[<expr>0</expr>]</index></name> = <name><name>block</name><index>[<expr><name>lastShadow</name> + 1</expr>]</index></name></expr>;</expr_stmt>

        <comment type="line">// LBZ2: Complete the initial radix sort:</comment>

        <decl_stmt><decl><type><name>int</name></type> <name>c1</name> =<init> <expr><name><name>block</name><index>[<expr>0</expr>]</index></name> &amp; 0xff</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>lastShadow</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>c2</name> =<init> <expr><name><name>block</name><index>[<expr><name>i</name> + 1</expr>]</index></name> &amp; 0xff</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>ftab</name><index>[<expr>(<name>c1</name> &lt;&lt; 8) + <name>c2</name></expr>]</index></name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>c1</name> = <name>c2</name></expr>;</expr_stmt>
        }</block></for>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= 65536</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>ftab</name><index>[<expr><name>i</name></expr>]</index></name> += <name><name>ftab</name><index>[<expr><name>i</name> - 1</expr>]</index></name></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><name>c1</name> = <name><name>block</name><index>[<expr>1</expr>]</index></name> &amp; 0xff</expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>lastShadow</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>c2</name> =<init> <expr><name><name>block</name><index>[<expr><name>i</name> + 2</expr>]</index></name> &amp; 0xff</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>fmap</name><index>[<expr>--<name><name>ftab</name><index>[<expr>(<name>c1</name> &lt;&lt; 8) + <name>c2</name></expr>]</index></name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>c1</name> = <name>c2</name></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><name><name>fmap</name><index>[<expr>--<name><name>ftab</name><index>[<expr>((<name><name>block</name><index>[<expr><name>lastShadow</name> + 1</expr>]</index></name> &amp; 0xff) &lt;&lt; 8) + (<name><name>block</name><index>[<expr>1</expr>]</index></name> &amp; 0xff)</expr>]</index></name></expr>]</index></name> = <name>lastShadow</name></expr>;</expr_stmt>

        <comment type="block">/*
         * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the
         * running order, from smallest to largest big bucket.
         */</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>256</expr></init></decl>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name><name>bigDone</name><index>[<expr><name>i</name></expr>]</index></name> = false</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>runningOrder</name><index>[<expr><name>i</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
        }</block></for>

        <for>for (<init><decl><type><name>int</name></type> <name>h</name> =<init> <expr>364</expr></init></decl>;</init> <condition><expr><name>h</name> != 1</expr>;</condition><incr/>) <block>{
            <expr_stmt><expr><name>h</name> /= 3</expr>;</expr_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>h</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= 255</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>vv</name> =<init> <expr><name><name>runningOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>a</name> =<init> <expr><name><name>ftab</name><index>[<expr>(<name>vv</name> + 1) &lt;&lt; 8</expr>]</index></name> - <name><name>ftab</name><index>[<expr><name>vv</name> &lt;&lt; 8</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>b</name> =<init> <expr><name>h</name> - 1</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name>i</name></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>ro</name> =<init> <expr><name><name>runningOrder</name><index>[<expr><name>j</name> - <name>h</name></expr>]</index></name></expr></init></decl>;</init> <condition><expr>(<name><name>ftab</name><index>[<expr>(<name>ro</name> + 1) &lt;&lt; 8</expr>]</index></name> - <name><name>ftab</name><index>[<expr><name>ro</name> &lt;&lt; 8</expr>]</index></name>) &gt; <name>a</name></expr>;</condition> <incr><expr><name>ro</name> = <name><name>runningOrder</name><index>[<expr><name>j</name>
                                                                                                                - <name>h</name></expr>]</index></name></expr></incr>) <block>{
                    <expr_stmt><expr><name><name>runningOrder</name><index>[<expr><name>j</name></expr>]</index></name> = <name>ro</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>j</name> -= <name>h</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>j</name> &lt;= <name>b</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                }</block></for>
                <expr_stmt><expr><name><name>runningOrder</name><index>[<expr><name>j</name></expr>]</index></name> = <name>vv</name></expr>;</expr_stmt>
            }</block></for>
        }</block></for>

        <comment type="block">/*
         * LBZ2: The main sorting loop.
         */</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= 255</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <comment type="block">/*
             * LBZ2: Process big buckets, starting with the least full.
             */</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>ss</name> =<init> <expr><name><name>runningOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Step 1:</comment>
            <comment type="block">/*
             * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small
             * buckets [ss, j]. Hopefully previous pointer-scanning phases have
             * already completed many of the small buckets [ss, j], so we don't
             * have to sort them at all.
             */</comment>
            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt;= 255</expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>sb</name> =<init> <expr>(<name>ss</name> &lt;&lt; 8) + <name>j</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>ftab_sb</name> =<init> <expr><name><name>ftab</name><index>[<expr><name>sb</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>(<name>ftab_sb</name> &amp; <name>SETMASK</name>) != <name>SETMASK</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>lo</name> =<init> <expr><name>ftab_sb</name> &amp; <name>CLEARMASK</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>hi</name> =<init> <expr>(<name><name>ftab</name><index>[<expr><name>sb</name> + 1</expr>]</index></name> &amp; <name>CLEARMASK</name>) - 1</expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>hi</name> &gt; <name>lo</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>mainQSort3</name><argument_list>(<argument><expr><name>dataShadow</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>lastShadow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>firstAttemptShadow</name>
                            &amp;&amp; (<name><name>this</name>.<name>workDone</name></name> &gt; <name>workLimitShadow</name>)</expr>)</condition><then> <block>{
                            <return>return;</return>
                        }</block></then></if>
                    }</block></then></if>
                    <expr_stmt><expr><name><name>ftab</name><index>[<expr><name>sb</name></expr>]</index></name> = <name>ftab_sb</name> | <name>SETMASK</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

            <comment type="line">// Step 2:</comment>
            <comment type="line">// LBZ2: Now scan this big bucket so as to synthesise the</comment>
            <comment type="line">// sorted order for small buckets [t, ss] for all t != ss.</comment>

            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt;= 255</expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name><name>copy</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>ftab</name><index>[<expr>(<name>j</name> &lt;&lt; 8) + <name>ss</name></expr>]</index></name> &amp; <name>CLEARMASK</name></expr>;</expr_stmt>
            }</block></for>

            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name><name>ftab</name><index>[<expr><name>ss</name> &lt;&lt; 8</expr>]</index></name> &amp; <name>CLEARMASK</name></expr></init>, <name>hj</name> =<init> <expr>(<name><name>ftab</name><index>[<expr>(<name>ss</name> + 1) &lt;&lt; 8</expr>]</index></name> &amp; <name>CLEARMASK</name>)</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>hj</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>fmap_j</name> =<init> <expr><name><name>fmap</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>c1</name> = <name><name>block</name><index>[<expr><name>fmap_j</name></expr>]</index></name> &amp; 0xff</expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name><name>bigDone</name><index>[<expr><name>c1</name></expr>]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>fmap</name><index>[<expr><name><name>copy</name><index>[<expr><name>c1</name></expr>]</index></name></expr>]</index></name> = (<name>fmap_j</name> == 0) ? <name>lastShadow</name> : (<name>fmap_j</name> - 1)</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>copy</name><index>[<expr><name>c1</name></expr>]</index></name>++</expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>256</expr></init></decl>;</init> <condition><expr>--<name>j</name> &gt;= 0</expr>;</condition><incr/>) <block>{
                <expr_stmt><expr><name><name>ftab</name><index>[<expr>(<name>j</name> &lt;&lt; 8) + <name>ss</name></expr>]</index></name> |= <name>SETMASK</name></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// Step 3:</comment>
            <comment type="block">/*
             * LBZ2: The ss big bucket is now done. Record this fact, and update the
             * quadrant descriptors. Remember to update quadrants in the
             * overshoot area too, if necessary. The "if (i &lt; 255)" test merely
             * skips this updating for the last bucket processed, since updating
             * for the last bucket is pointless.
             */</comment>
            <expr_stmt><expr><name><name>bigDone</name><index>[<expr><name>ss</name></expr>]</index></name> = true</expr>;</expr_stmt>

            <if>if <condition>(<expr><name>i</name> &lt; 255</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>bbStart</name> =<init> <expr><name><name>ftab</name><index>[<expr><name>ss</name> &lt;&lt; 8</expr>]</index></name> &amp; <name>CLEARMASK</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>bbSize</name> =<init> <expr>(<name><name>ftab</name><index>[<expr>(<name>ss</name> + 1) &lt;&lt; 8</expr>]</index></name> &amp; <name>CLEARMASK</name>) - <name>bbStart</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>shifts</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

                <while>while <condition>(<expr>(<name>bbSize</name> &gt;&gt; <name>shifts</name>) &gt; 65534</expr>)</condition> <block>{
                    <expr_stmt><expr><name>shifts</name>++</expr>;</expr_stmt>
                }</block></while>

                <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>bbSize</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>a2update</name> =<init> <expr><name><name>fmap</name><index>[<expr><name>bbStart</name> + <name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>qVal</name> =<init> <expr><call>(<name>char</name>) <argument_list>(<argument><expr><name>j</name> &gt;&gt; <name>shifts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>quadrant</name><index>[<expr><name>a2update</name></expr>]</index></name> = <name>qVal</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>a2update</name> &lt; <name><name>BZip2Constants</name>.<name>NUM_OVERSHOOT_BYTES</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>quadrant</name><index>[<expr><name>a2update</name> + <name>lastShadow</name> + 1</expr>]</index></name> = <name>qVal</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></then></if>

        }</block></for>
    }</block></function>

}</block></class>
</unit>
