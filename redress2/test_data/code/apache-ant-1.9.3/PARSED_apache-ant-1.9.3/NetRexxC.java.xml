<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\ant\taskdefs\optional\NetRexxC.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>optional</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>BufferedReader</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>PrintWriter</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>StringReader</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>StringWriter</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Enumeration</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Hashtable</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Properties</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>StringTokenizer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Vector</name></name>;</import>
<import>import <name><name>netrexx</name>.<name>lang</name>.<name>Rexx</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>BuildException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>DirectoryScanner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>Project</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>taskdefs</name>.<name>MatchingTask</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>types</name>.<name>EnumeratedAttribute</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>ant</name>.<name>util</name>.<name>FileUtils</name></name>;</import>

<comment type="line">// CheckStyle:InnerAssignmentCheck OFF - used too much in the file to be removed</comment>
<comment type="javadoc">/**
 * Compiles NetRexx source files.
 * This task can take the following
 * arguments:
 * &lt;ul&gt;
 * &lt;li&gt;binary&lt;/li&gt;
 * &lt;li&gt;classpath&lt;/li&gt;
 * &lt;li&gt;comments&lt;/li&gt;
 * &lt;li&gt;compile&lt;/li&gt;
 * &lt;li&gt;console&lt;/li&gt;
 * &lt;li&gt;crossref&lt;/li&gt;
 * &lt;li&gt;decimal&lt;/li&gt;
 * &lt;li&gt;destdir&lt;/li&gt;
 * &lt;li&gt;diag&lt;/li&gt;
 * &lt;li&gt;explicit&lt;/li&gt;
 * &lt;li&gt;format&lt;/li&gt;
 * &lt;li&gt;keep&lt;/li&gt;
 * &lt;li&gt;logo&lt;/li&gt;
 * &lt;li&gt;replace&lt;/li&gt;
 * &lt;li&gt;savelog&lt;/li&gt;
 * &lt;li&gt;srcdir&lt;/li&gt;
 * &lt;li&gt;sourcedir&lt;/li&gt;
 * &lt;li&gt;strictargs&lt;/li&gt;
 * &lt;li&gt;strictassign&lt;/li&gt;
 * &lt;li&gt;strictcase&lt;/li&gt;
 * &lt;li&gt;strictimport&lt;/li&gt;
 * &lt;li&gt;symbols&lt;/li&gt;
 * &lt;li&gt;time&lt;/li&gt;
 * &lt;li&gt;trace&lt;/li&gt;
 * &lt;li&gt;utf8&lt;/li&gt;
 * &lt;li&gt;verbose&lt;/li&gt;
 * &lt;li&gt;suppressMethodArgumentNotUsed&lt;/li&gt;
 * &lt;li&gt;suppressPrivatePropertyNotUsed&lt;/li&gt;
 * &lt;li&gt;suppressVariableNotUsed&lt;/li&gt;
 * &lt;li&gt;suppressExceptionNotSignalled&lt;/li&gt;
 * &lt;li&gt;suppressDeprecation&lt;/li&gt;
 * &lt;li&gt;removeKeepExtension&lt;/li&gt;
 * &lt;/ul&gt;
 * Of these arguments, the &lt;b&gt;srcdir&lt;/b&gt; argument is required.
 *
 * &lt;p&gt;When this task executes, it will recursively scan the srcdir
 * looking for NetRexx source files to compile. This task makes its
 * compile decision based on timestamp.
 * &lt;p&gt;Before files are compiled they and any other file in the
 * srcdir will be copied to the destdir allowing support files to be
 * located properly in the classpath. The reason for copying the source files
 * before the compile is that NetRexxC has only two destinations for classfiles:
 * &lt;ol&gt;
 * &lt;li&gt;The current directory, and,&lt;/li&gt;
 * &lt;li&gt;The directory the source is in (see sourcedir option)
 * &lt;/ol&gt;
 *
 */</comment>
<class><specifier>public</specifier> class <name>NetRexxC</name> <super><extends>extends <name>MatchingTask</name></extends></super> <block>{

    <comment type="line">// variables to hold arguments</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>binary</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>classpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>comments</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>compact</name> =<init> <expr>true</expr></init></decl>;</decl_stmt> <comment type="line">// should be the default, as it integrates better in ant.</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>compile</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>console</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>crossref</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>decimal</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>destDir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>diag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>explicit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>format</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>keep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>logo</name> =<init> <expr>true</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>replace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>savelog</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>File</name></type> <name>srcDir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>sourcedir</name> =<init> <expr>true</expr></init></decl>;</decl_stmt> <comment type="line">// ?? Should this be the default for ant?</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>strictargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>strictassign</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>strictcase</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>strictimport</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>strictprops</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>strictsignal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>symbols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>trace</name> =<init> <expr>"trace2"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>utf8</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>String</name></type> <name>verbose</name> =<init> <expr>"verbose3"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>suppressMethodArgumentNotUsed</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>suppressPrivatePropertyNotUsed</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>suppressVariableNotUsed</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>suppressExceptionNotSignalled</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>suppressDeprecation</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>removeKeepExtension</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="line">// constants for the messages to suppress by flags and their corresponding properties</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>MSG_METHOD_ARGUMENT_NOT_USED</name>
        =<init> <expr>"Warning: Method argument is not used"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>MSG_PRIVATE_PROPERTY_NOT_USED</name>
        =<init> <expr>"Warning: Private property is defined but not used"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>MSG_VARIABLE_NOT_USED</name>
        =<init> <expr>"Warning: Variable is set but not used"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>MSG_EXCEPTION_NOT_SIGNALLED</name>
        =<init> <expr>"is in SIGNALS list but is not signalled within the method"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>MSG_DEPRECATION</name> =<init> <expr>"has been deprecated"</expr></init></decl>;</decl_stmt>

    <comment type="line">// other implementation variables</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Vector</name></type> <name>compileList</name> =<init> <expr>new <call><name>Vector</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Hashtable</name></type> <name>filecopyList</name> =<init> <expr>new <call><name>Hashtable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Set whether literals are treated as binary, rather than NetRexx types.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default is false.
     * @param binary a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setBinary</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>binary</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>binary</name></name> = <name>binary</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Set the classpath used for NetRexx compilation.
     * @param classpath the classpath to use.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setClasspath</name><parameter_list>(<param><decl><type><name>String</name></type> <name>classpath</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>classpath</name></name> = <name>classpath</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Set whether comments are passed through to the generated java source.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param comments a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setComments</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>comments</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>comments</name></name> = <name>comments</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Set whether error messages come out in compact or verbose format.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is true.
     * @param compact a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompact</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>compact</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>compact</name></name> = <name>compact</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Set whether the NetRexx compiler should compile the generated java code.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is true.
     * Setting this flag to false, will automatically set the keep flag to true.
     * @param compile a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompile</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>compile</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>compile</name></name> = <name>compile</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>this</name>.<name>compile</name></name> &amp;&amp; !<name><name>this</name>.<name>keep</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>keep</name></name> = true</expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>


    <comment type="javadoc">/**
     * Set whether or not compiler messages should be displayed on the 'console'.
     * Note that this task will rely on the default value for filtering compile messages.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param console a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setConsole</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>console</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>console</name></name> = <name>console</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether variable cross references are generated.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param crossref a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCrossref</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>crossref</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>crossref</name></name> = <name>crossref</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Set whether decimal arithmetic should be used for the netrexx code.
     * Setting this to off will report decimal arithmetic as an error, for
     * performance critical applications.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is true.
     * @param decimal a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDecimal</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>decimal</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>decimal</name></name> = <name>decimal</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Set the destination directory into which the NetRexx source files
     * should be copied and then compiled.
     * @param destDirName the destination directory.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDestDir</name><parameter_list>(<param><decl><type><name>File</name></type> <name>destDirName</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>destDir</name> = <name>destDirName</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether diagnostic information about the compile is generated
     * @param diag a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDiag</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>diag</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>diag</name></name> = <name>diag</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Sets whether variables must be declared explicitly before use.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param explicit a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setExplicit</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>explicit</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>explicit</name></name> = <name>explicit</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether the generated java code is formatted nicely or left to match
     * NetRexx line numbers for call stack debugging.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value false.
     * @param format a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setFormat</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>format</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>format</name></name> = <name>format</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether the generated java code is produced.
     * This is not implemented yet.
     * @param java a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setJava</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>java</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"The attribute java is currently unused."</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Sets whether the generated java source file should be kept after
     * compilation. The generated files will have an extension of .java.keep,
     * &lt;b&gt;not&lt;/b&gt; .java. See setRemoveKeepExtension
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param keep a &lt;code&gt;boolean&lt;/code&gt; value.
     * @see #setRemoveKeepExtension(boolean)
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setKeep</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>keep</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>keep</name></name> = <name>keep</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether the compiler text logo is displayed when compiling.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param logo a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setLogo</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>logo</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>logo</name></name> = <name>logo</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether the generated .java file should be replaced when compiling.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param replace a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setReplace</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>replace</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>replace</name></name> = <name>replace</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Sets whether the compiler messages will be written to NetRexxC.log as
     * well as to the console.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param savelog a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setSavelog</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>savelog</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>savelog</name></name> = <name>savelog</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Tells the NetRexx compiler to store the class files in the same
     * directory as the source files. The alternative is the working directory.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is true.
     * @param sourcedir a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setSourcedir</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>sourcedir</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>sourcedir</name></name> = <name>sourcedir</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Set the source dir to find the source Java files.
     * @param srcDirName the source directory.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setSrcDir</name><parameter_list>(<param><decl><type><name>File</name></type> <name>srcDirName</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>srcDir</name> = <name>srcDirName</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Tells the NetRexx compiler that method calls always need parentheses,
     * even if no arguments are needed, e.g. &lt;code&gt;aStringVar.getBytes&lt;/code&gt;
     * vs. &lt;code&gt;aStringVar.getBytes()&lt;/code&gt;.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param strictargs a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setStrictargs</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>strictargs</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>strictargs</name></name> = <name>strictargs</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Tells the NetRexx compile that assignments must match exactly on type.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param strictassign a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setStrictassign</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>strictassign</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>strictassign</name></name> = <name>strictassign</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Specifies whether the NetRexx compiler should be case sensitive or not.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param strictcase a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setStrictcase</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>strictcase</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>strictcase</name></name> = <name>strictcase</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Sets whether classes need to be imported explicitly using an &lt;code&gt;import&lt;/code&gt;
     * statement. By default the NetRexx compiler will import certain packages
     * automatically.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param strictimport a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setStrictimport</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>strictimport</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>strictimport</name></name> = <name>strictimport</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Sets whether local properties need to be qualified explicitly using
     * &lt;code&gt;this&lt;/code&gt;.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param strictprops a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setStrictprops</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>strictprops</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>strictprops</name></name> = <name>strictprops</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether the compiler should force catching of exceptions by explicitly
     * named types.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false
     * @param strictsignal a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setStrictsignal</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>strictsignal</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>strictsignal</name></name> = <name>strictsignal</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Sets whether debug symbols should be generated into the class file.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param symbols a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setSymbols</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>symbols</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>symbols</name></name> = <name>symbols</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Asks the NetRexx compiler to print compilation times to the console
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param time a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTime</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>time</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>time</name></name> = <name>time</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Turns on or off tracing and directs the resultant trace output Valid
     * values are: "trace", "trace1", "trace2" and "notrace". "trace" and
     * "trace2".
     * @param trace the value to set.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTrace</name><parameter_list>(<param><decl><type><name>TraceAttr</name></type> <name>trace</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>trace</name></name> = <call><name><name>trace</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Turns on or off tracing and directs the resultant trace output Valid
     * values are: "trace", "trace1", "trace2" and "notrace". "trace" and
     * "trace2".
     * @param trace the value to set.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTrace</name><parameter_list>(<param><decl><type><name>String</name></type> <name>trace</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>TraceAttr</name></type> <name>t</name> =<init> <expr>new <call><name>TraceAttr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>t</name>.<name>setValue</name></name><argument_list>(<argument><expr><name>trace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setTrace</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Tells the NetRexx compiler that the source is in UTF8.
     * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
     * The default value is false.
     * @param utf8 a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setUtf8</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>utf8</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>utf8</name></name> = <name>utf8</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether lots of warnings and error messages should be generated
     * @param verbose the value to set - verbose&amp;lt;level&amp;gt; or noverbose.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setVerbose</name><parameter_list>(<param><decl><type><name>VerboseAttr</name></type> <name>verbose</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>verbose</name></name> = <call><name><name>verbose</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether lots of warnings and error messages should be generated
     * @param verbose the value to set - verbose&amp;lt;level&amp;gt; or noverbose.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setVerbose</name><parameter_list>(<param><decl><type><name>String</name></type> <name>verbose</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>VerboseAttr</name></type> <name>v</name> =<init> <expr>new <call><name>VerboseAttr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>v</name>.<name>setValue</name></name><argument_list>(<argument><expr><name>verbose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setVerbose</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Whether the task should suppress the "Method argument is not used" in
     * strictargs-Mode, which can not be suppressed by the compiler itself.
     * The warning is logged as verbose message, though.
     * @param suppressMethodArgumentNotUsed a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setSuppressMethodArgumentNotUsed</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>suppressMethodArgumentNotUsed</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>suppressMethodArgumentNotUsed</name></name> = <name>suppressMethodArgumentNotUsed</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether the task should suppress the "Private property is defined but
     * not used" in strictargs-Mode, which can be quite annoying while
     * developing. The warning is logged as verbose message, though.
     * @param suppressPrivatePropertyNotUsed a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setSuppressPrivatePropertyNotUsed</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>suppressPrivatePropertyNotUsed</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>suppressPrivatePropertyNotUsed</name></name> = <name>suppressPrivatePropertyNotUsed</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether the task should suppress the "Variable is set but not used" in
     * strictargs-Mode. Be careful with this one! The warning is logged as
     * verbose message, though.
     * @param suppressVariableNotUsed a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setSuppressVariableNotUsed</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>suppressVariableNotUsed</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>suppressVariableNotUsed</name></name> = <name>suppressVariableNotUsed</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Whether the task should suppress the "FooException is in SIGNALS list
     * but is not signalled within the method", which is sometimes rather
     * useless. The warning is logged as verbose message, though.
     * @param suppressExceptionNotSignalled a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setSuppressExceptionNotSignalled</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>suppressExceptionNotSignalled</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>suppressExceptionNotSignalled</name></name> = <name>suppressExceptionNotSignalled</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Tells whether we should filter out any deprecation-messages
     * of the compiler out.
     * @param suppressDeprecation a &lt;code&gt;boolean&lt;/code&gt; value.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setSuppressDeprecation</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>suppressDeprecation</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>suppressDeprecation</name></name> = <name>suppressDeprecation</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * Tells whether the trailing .keep in nocompile-mode should be removed
     * so that the resulting java source really ends on .java.
     * This facilitates the use of the javadoc tool lateron.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setRemoveKeepExtension</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>removeKeepExtension</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>removeKeepExtension</name></name> = <name>removeKeepExtension</name></expr>;</expr_stmt>
    }</block></function>


    <comment type="javadoc">/**
     * init-Method sets defaults from Properties. That way, when ant is called
     * with arguments like -Dant.netrexxc.verbose=verbose5 one can easily take
     * control of all netrexxc-tasks.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>p</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.binary"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>binary</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="line">// classpath makes no sense</comment>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.comments"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>comments</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.compact"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>compact</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.compile"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>compile</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.console"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>console</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.crossref"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>crossref</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.decimal"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>decimal</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// destDir</comment>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.diag"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>diag</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.explicit"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>explicit</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.format"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>format</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.keep"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>keep</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.logo"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>logo</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.replace"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>replace</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.savelog"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>savelog</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// srcDir</comment>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.sourcedir"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>sourcedir</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.strictargs"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>strictargs</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.strictassign"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>strictassign</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.strictcase"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>strictcase</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.strictimport"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>strictimport</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.strictprops"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>strictprops</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.strictsignal"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>strictsignal</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.symbols"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>symbols</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.time"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>time</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.trace"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>setTrace</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.utf8"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>utf8</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.verbose"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>setVerbose</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.suppressMethodArgumentNotUsed"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>suppressMethodArgumentNotUsed</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.suppressPrivatePropertyNotUsed"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>suppressPrivatePropertyNotUsed</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.suppressVariableNotUsed"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>suppressVariableNotUsed</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.suppressExceptionNotSignalled"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>suppressExceptionNotSignalled</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.suppressDeprecation"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>suppressDeprecation</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>(<name>p</name> = <call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>getProperty</name><argument_list>(<argument><expr>"ant.netrexxc.removeKeepExtension"</expr></argument>)</argument_list></call>) != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>removeKeepExtension</name></name> = <call><name><name>Project</name>.<name>toBoolean</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>


    <comment type="javadoc">/**
     * Executes the task - performs the actual compiler call.
     * @throws BuildException on error.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>execute</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{

        <comment type="line">// first off, make sure that we've got a srcdir and destdir</comment>
        <if>if <condition>(<expr><name>srcDir</name> == <name>null</name> || <name>destDir</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"srcDir and destDir attributes must be set!"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="line">// scan source and dest dirs to build up both copy lists and</comment>
        <comment type="line">// compile lists</comment>
        <comment type="line">//        scanDir(srcDir, destDir);</comment>
        <decl_stmt><decl><type><name>DirectoryScanner</name></type> <name>ds</name> =<init> <expr><call><name>getDirectoryScanner</name><argument_list>(<argument><expr><name>srcDir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>files</name> =<init> <expr><call><name><name>ds</name>.<name>getIncludedFiles</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>scanDir</name><argument_list>(<argument><expr><name>srcDir</name></expr></argument>, <argument><expr><name>destDir</name></expr></argument>, <argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// copy the source and support files</comment>
        <expr_stmt><expr><call><name>copyFilesToDestination</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// compile the source files</comment>
        <if>if <condition>(<expr><call><name><name>compileList</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Compiling " + <call><name><name>compileList</name>.<name>size</name></name><argument_list>()</argument_list></call> + " source file"
                 + (<call><name><name>compileList</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1 ? "" : "s")
                 + " to " + <name>destDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>doNetRexxCompile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>removeKeepExtension</name> &amp;&amp; (!<name>compile</name> || <name>keep</name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>removeKeepExtensions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></function>


    <comment type="javadoc">/**
     * Scans the directory looking for source files to be compiled and support
     * files to be copied.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>scanDir</name><parameter_list>(<param><decl><type><name>File</name></type> <name>srcDir</name></decl></param>, <param><decl><type><name>File</name></type> <name>destDir</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>files</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>files</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>File</name></type> <name>srcFile</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>srcDir</name></expr></argument>, <argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>File</name></type> <name>destFile</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>destDir</name></expr></argument>, <argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>filename</name> =<init> <expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <comment type="line">// if it's a non source file, copy it if a later date than the</comment>
            <comment type="line">// dest</comment>
            <comment type="line">// if it's a source file, see if the destination class file</comment>
            <comment type="line">// needs to be recreated via compilation</comment>
            <if>if <condition>(<expr><call><name><name>filename</name>.<name>toLowerCase</name></name><argument_list>()</argument_list></call>.<call><name>endsWith</name><argument_list>(<argument><expr>".nrx"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>File</name></type> <name>classFile</name> =<init>
                    <expr>new <call><name>File</name><argument_list>(<argument><expr><name>destDir</name></expr></argument>,
                    <argument><expr><call><name><name>filename</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>filename</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr>'.'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> + ".class"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>File</name></type> <name>javaFile</name> =<init>
                    <expr>new <call><name>File</name><argument_list>(<argument><expr><name>destDir</name></expr></argument>,
                    <argument><expr><call><name><name>filename</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>filename</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr>'.'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                    + (<name>removeKeepExtension</name> ? ".java" : ".java.keep")</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// nocompile case tests against .java[.keep] file</comment>
                <if>if <condition>(<expr>!<name>compile</name> &amp;&amp; <call><name><name>srcFile</name>.<name>lastModified</name></name><argument_list>()</argument_list></call> &gt; <call><name><name>javaFile</name>.<name>lastModified</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>filecopyList</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>srcFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>destFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>compileList</name>.<name>addElement</name></name><argument_list>(<argument><expr><call><name><name>destFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <comment type="line">// compile case tests against .class file</comment>
                <else>else <if>if <condition>(<expr><name>compile</name> &amp;&amp; <call><name><name>srcFile</name>.<name>lastModified</name></name><argument_list>()</argument_list></call> &gt; <call><name><name>classFile</name>.<name>lastModified</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>filecopyList</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>srcFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>destFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>compileList</name>.<name>addElement</name></name><argument_list>(<argument><expr><call><name><name>destFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></else></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><call><name><name>srcFile</name>.<name>lastModified</name></name><argument_list>()</argument_list></call> &gt; <call><name><name>destFile</name>.<name>lastModified</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>filecopyList</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>srcFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>destFile</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></for>
    }</block></function>


    <comment type="javadoc">/** Copy eligible files from the srcDir to destDir  */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>copyFilesToDestination</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>filecopyList</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Copying " + <call><name><name>filecopyList</name>.<name>size</name></name><argument_list>()</argument_list></call> + " file"
                 + (<call><name><name>filecopyList</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1 ? "" : "s")
                 + " to " + <call><name><name>destDir</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Enumeration</name></type> <name>e</name> =<init> <expr><call><name><name>filecopyList</name>.<name>keys</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>fromFile</name> =<init> <expr>(<name>String</name>) <call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>toFile</name> =<init> <expr>(<name>String</name>) <call><name><name>filecopyList</name>.<name>get</name></name><argument_list>(<argument><expr><name>fromFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <try>try <block>{
                    <expr_stmt><expr><call><name><name>FileUtils</name>.<name>getFileUtils</name></name><argument_list>()</argument_list></call>.<call><name>copyFile</name><argument_list>(<argument><expr><name>fromFile</name></expr></argument>, <argument><expr><name>toFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ioe</name></decl></param>) <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>msg</name> =<init> <expr>"Failed to copy " + <name>fromFile</name> + " to " + <name>toFile</name>
                         + " due to " + <call><name><name>ioe</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ioe</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></while>
        }</block></then></if>
    }</block></function>


    <comment type="javadoc">/**
     * Rename .java.keep files (back) to .java. The netrexxc renames all
     * .java files to .java.keep if either -keep or -nocompile option is set.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>removeKeepExtensions</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>compileList</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Removing .keep extension on " + <call><name><name>compileList</name>.<name>size</name></name><argument_list>()</argument_list></call> + " file"
                 + (<call><name><name>compileList</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1 ? "" : "s")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Enumeration</name></type> <name>e</name> =<init> <expr><call><name><name>compileList</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>nrxName</name> =<init> <expr>(<name>String</name>) <call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name></type> <name>baseName</name> =<init> <expr><call><name><name>nrxName</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>nrxName</name>.<name>lastIndexOf</name></name><argument_list>(<argument><expr>'.'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>File</name></type> <name>fromFile</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>baseName</name> + ".java.keep"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>File</name></type> <name>toFile</name> =<init> <expr>new <call><name>File</name><argument_list>(<argument><expr><name>baseName</name> + ".java"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>fromFile</name>.<name>renameTo</name></name><argument_list>(<argument><expr><name>toFile</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Successfully renamed " + <name>fromFile</name> + " to " + <name>toFile</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Failed to rename " + <name>fromFile</name> + " to " + <name>toFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></while>
        }</block></then></if>
    }</block></function>


    <comment type="javadoc">/** Performs a compile using the NetRexx 1.1.x compiler  */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>doNetRexxCompile</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>BuildException</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Using NetRexx compiler"</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>String</name></type> <name>classpath</name> =<init> <expr><call><name>getCompileClasspath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>compileOptions</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// create an array of strings for input to the compiler: one array</comment>
        <comment type="line">// comes from the compile options, the other from the compileList</comment>
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>compileOptionsArray</name> =<init> <expr><call><name>getCompileOptionsAsArray</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>fileListArray</name> =<init> <expr>new <name><name>String</name><index>[<expr><call><name><name>compileList</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Enumeration</name></type> <name>e</name> =<init> <expr><call><name><name>compileList</name>.<name>elements</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name><name>e</name>.<name>hasMoreElements</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><name><name>fileListArray</name><index>[<expr><name>j</name></expr>]</index></name> = (<name>String</name>) <call><name><name>e</name>.<name>nextElement</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
        }</block></while>
        <comment type="line">// create a single array of arguments for the compiler</comment>
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>compileArgs</name> =<init> <expr>new <name><name>String</name><index>[<expr><name><name>compileOptionsArray</name>.<name>length</name></name> + <name><name>fileListArray</name>.<name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>compileOptionsArray</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>compileArgs</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>compileOptionsArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>fileListArray</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>compileArgs</name><index>[<expr><name>i</name> + <name><name>compileOptionsArray</name>.<name>length</name></name></expr>]</index></name> = <name><name>fileListArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// print nice output about what we are doing for the log</comment>
        <expr_stmt><expr><call><name><name>compileOptions</name>.<name>append</name></name><argument_list>(<argument><expr>"Compilation args: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>compileOptionsArray</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name><name>compileOptions</name>.<name>append</name></name><argument_list>(<argument><expr><name><name>compileOptionsArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>compileOptions</name>.<name>append</name></name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><call><name><name>compileOptions</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>String</name></type> <name>eol</name> =<init> <expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"line.separator"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>niceSourceList</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>(<argument><expr>"Files to be compiled:" + <name>eol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name> =<init> <expr><call><name><name>compileList</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name><name>niceSourceList</name>.<name>append</name></name><argument_list>(<argument><expr>"    "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>niceSourceList</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>compileList</name>.<name>elementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>niceSourceList</name>.<name>append</name></name><argument_list>(<argument><expr><name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><call><name><name>niceSourceList</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// need to set java.class.path property and restore it later</comment>
        <comment type="line">// since the NetRexx compiler has no option for the classpath</comment>
        <decl_stmt><decl><type><name>String</name></type> <name>currentClassPath</name> =<init> <expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"java.class.path"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Properties</name></type> <name>currentProperties</name> =<init> <expr><call><name><name>System</name>.<name>getProperties</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>currentProperties</name>.<name>put</name></name><argument_list>(<argument><expr>"java.class.path"</expr></argument>, <argument><expr><name>classpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <try>try <block>{
            <decl_stmt><decl><type><name>StringWriter</name></type> <name>out</name> =<init> <expr>new <call><name>StringWriter</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PrintWriter</name></type> <name>w</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init>
                <expr><call><name><name>COM</name>.<name>ibm</name>.<name>netrexx</name>.<name>process</name>.<name>NetRexxC</name>.<name>main</name></name><argument_list>(<argument><expr>new <call><name>Rexx</name><argument_list>(<argument><expr><name>compileArgs</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><name>w</name> = new <call><name>PrintWriter</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>sdir</name> =<init> <expr><call><name><name>srcDir</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>ddir</name> =<init> <expr><call><name><name>destDir</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>doReplace</name> =<init> <expr>!(<call><name><name>sdir</name>.<name>equals</name></name><argument_list>(<argument><expr><name>ddir</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>dlen</name> =<init> <expr><call><name><name>ddir</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>l</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BufferedReader</name></type> <name>in</name> =<init> <expr>new <call><name>BufferedReader</name><argument_list>(<argument><expr>new <call><name>StringReader</name><argument_list>(<argument><expr><call><name><name>out</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"replacing destdir '" + <name>ddir</name> + "' through sourcedir '"
                + <name>sdir</name> + "'"</expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr>(<name>l</name> = <call><name><name>in</name>.<name>readLine</name></name><argument_list>()</argument_list></call>) != <name>null</name></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

                <while>while <condition>(<expr><name>doReplace</name> &amp;&amp; ((<name>idx</name> = <call><name><name>l</name>.<name>indexOf</name></name><argument_list>(<argument><expr><name>ddir</name></expr></argument>)</argument_list></call>) != -1)</expr>)</condition> <block>{
                    <comment type="line">// path is mentioned in the message</comment>
                    <expr_stmt><expr><name>l</name> = (new <call><name>StringBuffer</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call>).<call><name>replace</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>idx</name> + <name>dlen</name></expr></argument>, <argument><expr><name>sdir</name></expr></argument>)</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></while>
                <comment type="line">// verbose level logging for suppressed messages</comment>
                <if>if <condition>(<expr><name>suppressMethodArgumentNotUsed</name>
                    &amp;&amp; <call><name><name>l</name>.<name>indexOf</name></name><argument_list>(<argument><expr><name>MSG_METHOD_ARGUMENT_NOT_USED</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>suppressPrivatePropertyNotUsed</name>
                    &amp;&amp; <call><name><name>l</name>.<name>indexOf</name></name><argument_list>(<argument><expr><name>MSG_PRIVATE_PROPERTY_NOT_USED</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>suppressVariableNotUsed</name>
                    &amp;&amp; <call><name><name>l</name>.<name>indexOf</name></name><argument_list>(<argument><expr><name>MSG_VARIABLE_NOT_USED</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>suppressExceptionNotSignalled</name>
                    &amp;&amp; <call><name><name>l</name>.<name>indexOf</name></name><argument_list>(<argument><expr><name>MSG_EXCEPTION_NOT_SIGNALLED</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>suppressDeprecation</name>
                    &amp;&amp; <call><name><name>l</name>.<name>indexOf</name></name><argument_list>(<argument><expr><name>MSG_DEPRECATION</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>l</name>.<name>indexOf</name></name><argument_list>(<argument><expr>"Error:"</expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
                    <comment type="line">// error level logging for compiler errors</comment>
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_ERR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>l</name>.<name>indexOf</name></name><argument_list>(<argument><expr>"Warning:"</expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
                    <comment type="line">// warning for all warning messages</comment>
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_WARN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_INFO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// info level for the rest.</comment>
                }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
            }</block></while>
            <if>if <condition>(<expr><name>rc</name> &gt; 1</expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Compile failed, messages should "
                    + "have been provided."</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>w</name>.<name>checkError</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Encountered an error"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ioe</name></decl></param>) <block>{
            <throw>throw <expr>new <call><name>BuildException</name><argument_list>(<argument><expr>"Unexpected IOException while "
                + "playing with Strings"</expr></argument>, <argument><expr><name>ioe</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch> <finally>finally <block>{
            <comment type="line">// need to reset java.class.path property</comment>
            <comment type="line">// since the NetRexx compiler has no option for the classpath</comment>
            <expr_stmt><expr><name>currentProperties</name> = <call><name><name>System</name>.<name>getProperties</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>currentProperties</name>.<name>put</name></name><argument_list>(<argument><expr>"java.class.path"</expr></argument>, <argument><expr><name>currentClassPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>

    }</block></function>


    <comment type="javadoc">/** Builds the compilation classpath.  */</comment>
    <function><type><specifier>private</specifier> <name>String</name></type> <name>getCompileClasspath</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>classpath</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// add dest dir to classpath so that previously compiled and</comment>
        <comment type="line">// untouched classes are on classpath</comment>
        <expr_stmt><expr><call><name><name>classpath</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>destDir</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// add our classpath to the mix</comment>
        <if>if <condition>(<expr><name><name>this</name>.<name>classpath</name></name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>addExistingToClasspath</name><argument_list>(<argument><expr><name>classpath</name></expr></argument>, <argument><expr><name><name>this</name>.<name>classpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// add the system classpath</comment>
        <comment type="line">// addExistingToClasspath(classpath,System.getProperty("java.class.path"));</comment>
        <return>return <expr><call><name><name>classpath</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="javadoc">/** This  */</comment>
    <function><type><specifier>private</specifier> <name>String</name><index>[]</index></type> <name>getCompileOptionsAsArray</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>Vector</name></type> <name>options</name> =<init> <expr>new <call><name>Vector</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>binary</name> ? "-binary" : "-nobinary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>comments</name> ? "-comments" : "-nocomments"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>compile</name> ? "-compile" : "-nocompile"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>compact</name> ? "-compact" : "-nocompact"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>console</name> ? "-console" : "-noconsole"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>crossref</name> ? "-crossref" : "-nocrossref"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>decimal</name> ? "-decimal" : "-nodecimal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>diag</name> ? "-diag" : "-nodiag"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>explicit</name> ? "-explicit" : "-noexplicit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>format</name> ? "-format" : "-noformat"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>keep</name> ? "-keep" : "-nokeep"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>logo</name> ? "-logo" : "-nologo"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>replace</name> ? "-replace" : "-noreplace"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>savelog</name> ? "-savelog" : "-nosavelog"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>sourcedir</name> ? "-sourcedir" : "-nosourcedir"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>strictargs</name> ? "-strictargs" : "-nostrictargs"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>strictassign</name> ? "-strictassign" : "-nostrictassign"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>strictcase</name> ? "-strictcase" : "-nostrictcase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>strictimport</name> ? "-strictimport" : "-nostrictimport"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>strictprops</name> ? "-strictprops" : "-nostrictprops"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>strictsignal</name> ? "-strictsignal" : "-nostrictsignal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>symbols</name> ? "-symbols" : "-nosymbols"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>time</name> ? "-time" : "-notime"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr>"-" + <name>trace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr><name>utf8</name> ? "-utf8" : "-noutf8"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>options</name>.<name>addElement</name></name><argument_list>(<argument><expr>"-" + <name>verbose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>results</name> =<init> <expr>new <name><name>String</name><index>[<expr><call><name><name>options</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>options</name>.<name>copyInto</name></name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>results</name></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Takes a classpath-like string, and adds each element of this string to
     * a new classpath, if the components exist. Components that don't exist,
     * aren't added. We do this, because jikes issues warnings for
     * non-existant files/dirs in his classpath, and these warnings are pretty
     * annoying.
     *
     * @param target - target classpath
     * @param source - source classpath to get file objects.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>addExistingToClasspath</name><parameter_list>(<param><decl><type><name>StringBuffer</name></type> <name>target</name></decl></param>, <param><decl><type><name>String</name></type> <name>source</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>StringTokenizer</name></type> <name>tok</name> =<init> <expr>new <call><name>StringTokenizer</name><argument_list>(<argument><expr><name>source</name></expr></argument>,
            <argument><expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"path.separator"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name><name>tok</name>.<name>hasMoreTokens</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>File</name></type> <name>f</name> =<init> <expr><call><name>getProject</name><argument_list>()</argument_list></call>.<call><name>resolveFile</name><argument_list>(<argument><expr><call><name><name>tok</name>.<name>nextToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>f</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>target</name>.<name>append</name></name><argument_list>(<argument><expr><name><name>File</name>.<name>pathSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>target</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>f</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>log</name><argument_list>(<argument><expr>"Dropping from classpath: "
                    + <call><name><name>f</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Project</name>.<name>MSG_VERBOSE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>

    }</block></function>


    <comment type="javadoc">/**
     * Enumerated class corresponding to the trace attribute.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>TraceAttr</name> <super><extends>extends <name>EnumeratedAttribute</name></extends></super> <block>{
        <comment type="javadoc">/** {@inheritDoc}. */</comment>
        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getValues</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>new <name><name>String</name><index>[]</index></name><block>{<expr>"trace"</expr>, <expr>"trace1"</expr>, <expr>"trace2"</expr>, <expr>"notrace"</expr>}</block></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * Enumerated class corresponding to the verbose attribute.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>VerboseAttr</name> <super><extends>extends <name>EnumeratedAttribute</name></extends></super> <block>{
        <comment type="javadoc">/** {@inheritDoc}. */</comment>
        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getValues</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr>new <name><name>String</name><index>[]</index></name><block>{<expr>"verbose"</expr>, <expr>"verbose0"</expr>, <expr>"verbose1"</expr>,
                <expr>"verbose2"</expr>, <expr>"verbose3"</expr>, <expr>"verbose4"</expr>,
                <expr>"verbose5"</expr>, <expr>"noverbose"</expr>}</block></expr>;</return>
        }</block></function>
    }</block></class>
}</block></class>

</unit>
