<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\zip\ZipUtil.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Calendar</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Date</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>zip</name>.<name>CRC32</name></name>;</import>

<comment type="javadoc">/**
 * Utility class for handling DOS and Java time conversions.
 * @since Ant 1.8.1
 */</comment>
<class><specifier>public</specifier> <specifier>abstract</specifier> class <name>ZipUtil</name> <block>{
    <comment type="javadoc">/**
     * Smallest date/time ZIP can handle.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>DOS_TIME_MIN</name> =<init> <expr><call><name><name>ZipLong</name>.<name>getBytes</name></name><argument_list>(<argument><expr>0x00002100L</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Convert a Date object to a DOS date/time field.
     * @param time the &lt;code&gt;Date&lt;/code&gt; to convert
     * @return the date as a &lt;code&gt;ZipLong&lt;/code&gt;
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ZipLong</name></type> <name>toDosTime</name><parameter_list>(<param><decl><type><name>Date</name></type> <name>time</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>new <call><name>ZipLong</name><argument_list>(<argument><expr><call><name>toDosTime</name><argument_list>(<argument><expr><call><name><name>time</name>.<name>getTime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Convert a Date object to a DOS date/time field.
     *
     * &lt;p&gt;Stolen from InfoZip's &lt;code&gt;fileio.c&lt;/code&gt;&lt;/p&gt;
     * @param t number of milliseconds since the epoch
     * @return the date as a byte array
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>toDosTime</name><parameter_list>(<param><decl><type><name>long</name></type> <name>t</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Calendar</name></type> <name>c</name> =<init> <expr><call><name><name>Calendar</name>.<name>getInstance</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>c</name>.<name>setTimeInMillis</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>year</name> =<init> <expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>YEAR</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>year</name> &lt; 1980</expr>)</condition><then> <block>{
            <return>return <expr><call><name>copy</name><argument_list>(<argument><expr><name>DOS_TIME_MIN</name></expr></argument>)</argument_list></call></expr>;</return> <comment type="line">// stop callers from changing the array</comment>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>month</name> =<init> <expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>MONTH</name></name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>value</name> =<init>  <expr>((<name>year</name> - 1980) &lt;&lt; 25)
            |         (<name>month</name> &lt;&lt; 21)
            |         (<call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>DAY_OF_MONTH</name></name></expr></argument>)</argument_list></call> &lt;&lt; 16)
            |         (<call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>HOUR_OF_DAY</name></name></expr></argument>)</argument_list></call> &lt;&lt; 11)
            |         (<call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>MINUTE</name></name></expr></argument>)</argument_list></call> &lt;&lt; 5)
            |         (<call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>SECOND</name></name></expr></argument>)</argument_list></call> &gt;&gt; 1)</expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>ZipLong</name>.<name>getBytes</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Assumes a negative integer really is a positive integer that
     * has wrapped around and re-creates the original value.
     *
     * &lt;p&gt;This methods is no longer used as of Apache Ant 1.9.0&lt;/p&gt;
     *
     * @param i the value to treat as unsigned int.
     * @return the unsigned int as a long.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>long</name></type> <name>adjustToLong</name><parameter_list>(<param><decl><type><name>int</name></type> <name>i</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
            <return>return <expr>2 * ((<name>long</name>) <name><name>Integer</name>.<name>MAX_VALUE</name></name>) + 2 + <name>i</name></expr>;</return>
        }</block></then> <else>else <block>{
            <return>return <expr><name>i</name></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Convert a DOS date/time field to a Date object.
     *
     * @param zipDosTime contains the stored DOS time.
     * @return a Date instance corresponding to the given time.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Date</name></type> <name>fromDosTime</name><parameter_list>(<param><decl><type><name>ZipLong</name></type> <name>zipDosTime</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>dosTime</name> =<init> <expr><call><name><name>zipDosTime</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr>new <call><name>Date</name><argument_list>(<argument><expr><call><name>dosToJavaTime</name><argument_list>(<argument><expr><name>dosTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Converts DOS time to Java time (number of milliseconds since
     * epoch).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>long</name></type> <name>dosToJavaTime</name><parameter_list>(<param><decl><type><name>long</name></type> <name>dosTime</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>Calendar</name></type> <name>cal</name> =<init> <expr><call><name><name>Calendar</name>.<name>getInstance</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// CheckStyle:MagicNumberCheck OFF - no point</comment>
        <expr_stmt><expr><call><name><name>cal</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>YEAR</name></name></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr>(<name>dosTime</name> &gt;&gt; 25) &amp; 0x7f</expr></argument>)</argument_list></call> + 1980</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cal</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>MONTH</name></name></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr>(<name>dosTime</name> &gt;&gt; 21) &amp; 0x0f</expr></argument>)</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cal</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>DATE</name></name></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>dosTime</name> &gt;&gt; 16</expr></argument>)</argument_list></call> &amp; 0x1f</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cal</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>HOUR_OF_DAY</name></name></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>dosTime</name> &gt;&gt; 11</expr></argument>)</argument_list></call> &amp; 0x1f</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cal</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>MINUTE</name></name></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>dosTime</name> &gt;&gt; 5</expr></argument>)</argument_list></call> &amp; 0x3f</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cal</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>SECOND</name></name></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>dosTime</name> &lt;&lt; 1</expr></argument>)</argument_list></call> &amp; 0x3e</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cal</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>Calendar</name>.<name>MILLISECOND</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// CheckStyle:MagicNumberCheck ON</comment>
        <return>return <expr><call><name><name>cal</name>.<name>getTime</name></name><argument_list>()</argument_list></call>.<call><name>getTime</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * If the entry has Unicode*ExtraFields and the CRCs of the
     * names/comments match those of the extra fields, transfer the
     * known Unicode values from the extra field.
     */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type> <name>setNameAndCommentFromExtraFields</name><parameter_list>(<param><decl><type><name>ZipEntry</name></type> <name>ze</name></decl></param>,
                                                 <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>originalNameBytes</name></decl></param>,
                                                 <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>commentBytes</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>UnicodePathExtraField</name></type> <name>name</name> =<init> <expr>(<name>UnicodePathExtraField</name>)
            <call><name><name>ze</name>.<name>getExtraField</name></name><argument_list>(<argument><expr><name><name>UnicodePathExtraField</name>.<name>UPATH_ID</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>originalName</name> =<init> <expr><call><name><name>ze</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>newName</name> =<init> <expr><call><name>getUnicodeStringIfOriginalMatches</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
                                                           <argument><expr><name>originalNameBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newName</name> != <name>null</name> &amp;&amp; !<call><name><name>originalName</name>.<name>equals</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>ze</name>.<name>setName</name></name><argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>commentBytes</name> != <name>null</name> &amp;&amp; <name><name>commentBytes</name>.<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>UnicodeCommentExtraField</name></type> <name>cmt</name> =<init> <expr>(<name>UnicodeCommentExtraField</name>)
                <call><name><name>ze</name>.<name>getExtraField</name></name><argument_list>(<argument><expr><name><name>UnicodeCommentExtraField</name>.<name>UCOM_ID</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>newComment</name> =<init>
                <expr><call><name>getUnicodeStringIfOriginalMatches</name><argument_list>(<argument><expr><name>cmt</name></expr></argument>, <argument><expr><name>commentBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>newComment</name> != <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>ze</name>.<name>setComment</name></name><argument_list>(<argument><expr><name>newComment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * If the stored CRC matches the one of the given name, return the
     * Unicode name of the given field.
     *
     * &lt;p&gt;If the field is null or the CRCs don't match, return null
     * instead.&lt;/p&gt;
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> 
        <name>String</name></type> <name>getUnicodeStringIfOriginalMatches</name><parameter_list>(<param><decl><type><name>AbstractUnicodeExtraField</name></type> <name>f</name></decl></param>,
                                                 <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>orig</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>f</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>CRC32</name></type> <name>crc32</name> =<init> <expr>new <call><name>CRC32</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>crc32</name>.<name>update</name></name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>origCRC32</name> =<init> <expr><call><name><name>crc32</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>origCRC32</name> == <call><name><name>f</name>.<name>getNameCRC32</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <try>try <block>{
                    <return>return <expr><call><name><name>ZipEncodingHelper</name>
                        .<name>UTF8_ZIP_ENCODING</name>.<name>decode</name></name><argument_list>(<argument><expr><call><name><name>f</name>.<name>getUnicodeName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ex</name></decl></param>) <block>{
                    <comment type="line">// UTF-8 unsupported?  should be impossible the</comment>
                    <comment type="line">// Unicode*ExtraField must contain some bad bytes</comment>

                    <comment type="line">// TODO log this anywhere?</comment>
                    <return>return <expr><name>null</name></expr>;</return>
                }</block></catch></try>
            }</block></then></if>
        }</block></then></if>
        <return>return <expr><name>null</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Create a copy of the given array - or return null if the
     * argument is null.
     */</comment>
    <function><type><specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>copy</name><parameter_list>(<param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>from</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>from</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>to</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name><name>from</name>.<name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>to</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>to</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>null</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Whether this library is able to read or write the given entry.
     */</comment>
    <function><type><specifier>static</specifier> <name>boolean</name></type> <name>canHandleEntryData</name><parameter_list>(<param><decl><type><name>ZipEntry</name></type> <name>entry</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>supportsEncryptionOf</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>supportsMethodOf</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Whether this library supports the encryption used by the given
     * entry.
     *
     * @return true if the entry isn't encrypted at all
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>supportsEncryptionOf</name><parameter_list>(<param><decl><type><name>ZipEntry</name></type> <name>entry</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>!<call><name><name>entry</name>.<name>getGeneralPurposeBit</name></name><argument_list>()</argument_list></call>.<call><name>usesEncryption</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Whether this library supports the compression method used by
     * the given entry.
     *
     * @return true if the compression method is STORED or DEFLATED
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>supportsMethodOf</name><parameter_list>(<param><decl><type><name>ZipEntry</name></type> <name>entry</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>entry</name>.<name>getMethod</name></name><argument_list>()</argument_list></call> == <name><name>ZipEntry</name>.<name>STORED</name></name>
            || <call><name><name>entry</name>.<name>getMethod</name></name><argument_list>()</argument_list></call> == <name><name>ZipEntry</name>.<name>DEFLATED</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Checks whether the entry requires features not (yet) supported
     * by the library and throws an exception if it does.
     */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type> <name>checkRequestedFeatures</name><parameter_list>(<param><decl><type><name>ZipEntry</name></type> <name>ze</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>UnsupportedZipFeatureException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr>!<call><name>supportsEncryptionOf</name><argument_list>(<argument><expr><name>ze</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw
                <expr>new <call><name>UnsupportedZipFeatureException</name><argument_list>(<argument><expr><name><name>UnsupportedZipFeatureException</name>
                                                   .<name>Feature</name>.<name>ENCRYPTION</name></name></expr></argument>, <argument><expr><name>ze</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr>!<call><name>supportsMethodOf</name><argument_list>(<argument><expr><name>ze</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw
                <expr>new <call><name>UnsupportedZipFeatureException</name><argument_list>(<argument><expr><name><name>UnsupportedZipFeatureException</name>
                                                   .<name>Feature</name>.<name>METHOD</name></name></expr></argument>, <argument><expr><name>ze</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
    }</block></function>
}</block></class>
</unit>
