<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\ojcchar\Documents\Dropbox\Classes\W14\CSC7990 - Directed Study\Implementation\EclipseProject\redress2\test_data\code\apache-ant-1.9.3\src\main\org\apache\tools\tar\TarUtils.java"><comment type="block">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */</comment>

<comment type="block">/*
 * This package is based on the work done by Timothy Gerard Endres
 * (time@ice.com) to whom the Ant project is very grateful for his great code.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>tar</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>math</name>.<name>BigInteger</name></name>;</import>
<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name>.<name>ZipEncoding</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>tools</name>.<name>zip</name>.<name>ZipEncodingHelper</name></name>;</import>

<comment type="javadoc">/**
 * This class provides static utility methods to work with byte streams.
 *
 */</comment>
<comment type="line">// CheckStyle:HideUtilityClassConstructorCheck OFF (bc)</comment>
<class><specifier>public</specifier> class <name>TarUtils</name> <block>{

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BYTE_MASK</name> =<init> <expr>255</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>ZipEncoding</name></type> <name>DEFAULT_ENCODING</name> =<init>
        <expr><call><name><name>ZipEncodingHelper</name>.<name>getZipEncoding</name></name><argument_list>(<argument><expr><name>null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Encapsulates the algorithms used up to Ant 1.8 as ZipEncoding.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>ZipEncoding</name></type> <name>FALLBACK_ENCODING</name> =<init> <expr>new <class><super><name>ZipEncoding</name></super><argument_list>()</argument_list> <block>{
            <function><type><specifier>public</specifier> <name>boolean</name></type> <name>canEncode</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{ <return>return <expr>true</expr>;</return> }</block></function>

            <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>encode</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>)</parameter_list> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> =<init> <expr><call><name><name>name</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>buf</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>length</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <comment type="line">// copy until end of input or output is reached.</comment>
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>byte</name>) <call><name><name>name</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <return>return <expr><call><name><name>ByteBuffer</name>.<name>wrap</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></function>

            <function><type><specifier>public</specifier> <name>String</name></type> <name>decode</name><parameter_list>(<param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>)</parameter_list> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> =<init> <expr><name><name>buffer</name>.<name>length</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StringBuffer</name></type> <name>result</name> =<init> <expr>new <call><name>StringBuffer</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                    <decl_stmt><decl><type><name>byte</name></type> <name>b</name> =<init> <expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>b</name> == 0</expr>)</condition><then> <block>{ <comment type="line">// Trailing null</comment>
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><call><name><name>result</name>.<name>append</name></name><argument_list>(<argument><expr><call>(<name>char</name>) <argument_list>(<argument><expr><name>b</name> &amp; 0xFF</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Allow for sign-extension</comment>
                }</block></for>

                <return>return <expr><call><name><name>result</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** Private constructor to prevent instantiation of this utility class. */</comment>
    <constructor><specifier>private</specifier> <name>TarUtils</name><parameter_list>()</parameter_list><block>{
    }</block></constructor>

    <comment type="javadoc">/**
     * Parse an octal string from a buffer.
     *
     * &lt;p&gt;Leading spaces are ignored.
     * The buffer must contain a trailing space or NUL,
     * and may contain an additional trailing space or NUL.&lt;/p&gt;
     *
     * &lt;p&gt;The input buffer is allowed to contain all NULs,
     * in which case the method returns 0L
     * (this allows for missing fields).&lt;/p&gt;
     *
     * &lt;p&gt;To work-around some tar implementations that insert a
     * leading NUL this method returns 0 if it detects a leading NUL
     * since Ant 1.9.&lt;/p&gt;
     *
     * @param buffer The buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The maximum number of bytes to parse - must be at least 2 bytes.
     * @return The long value of the octal string.
     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>long</name></type> <name>parseOctal</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>long</name></type>    <name>result</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>     <name>end</name> =<init> <expr><name>offset</name> + <name>length</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>     <name>start</name> =<init> <expr><name>offset</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>length</name> &lt; 2</expr>)</condition><then><block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Length "+<name>length</name>+" must be at least 2"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>start</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
            <return>return <expr>0L</expr>;</return>
        }</block></then></if>

        <comment type="line">// Skip leading spaces</comment>
        <while>while <condition>(<expr><name>start</name> &lt; <name>end</name></expr>)</condition><block>{
            <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>start</name></expr>]</index></name> == ' '</expr>)</condition><then><block>{
                <expr_stmt><expr><name>start</name>++</expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <break>break;</break>
            }</block></else></if>
        }</block></while>

        <comment type="line">// Must have trailing NUL or space</comment>
        <decl_stmt><decl><type><name>byte</name></type> <name>trailer</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>trailer</name> = <name><name>buffer</name><index>[<expr><name>end</name>-1</expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>trailer</name> == 0 || <name>trailer</name> == ' '</expr>)</condition><then><block>{
            <expr_stmt><expr><name>end</name>--</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(
                    <argument><expr><call><name>exceptionMessage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>end</name>-1</expr></argument>, <argument><expr><name>trailer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></else></if>
        <comment type="line">// May have additional NUL or space</comment>
        <expr_stmt><expr><name>trailer</name> = <name><name>buffer</name><index>[<expr><name>end</name>-1</expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>trailer</name> == 0 || <name>trailer</name> == ' '</expr>)</condition><then><block>{
            <expr_stmt><expr><name>end</name>--</expr>;</expr_stmt>
        }</block></then></if>

        <for>for ( <init>;</init><condition><expr><name>start</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>start</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name></type> <name>currentByte</name> =<init> <expr><name><name>buffer</name><index>[<expr><name>start</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <comment type="line">// CheckStyle:MagicNumber OFF</comment>
            <if>if <condition>(<expr><name>currentByte</name> &lt; '0' || <name>currentByte</name> &gt; '7'</expr>)</condition><then><block>{
                <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(
                        <argument><expr><call><name>exceptionMessage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>currentByte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <expr_stmt><expr><name>result</name> = (<name>result</name> &lt;&lt; 3) + (<name>currentByte</name> - '0')</expr>;</expr_stmt> <comment type="line">// convert from ASCII</comment>
            <comment type="line">// CheckStyle:MagicNumber ON</comment>
        }</block></for>

        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/** 
     * Compute the value contained in a byte buffer.  If the most
     * significant bit of the first byte in the buffer is set, this
     * bit is ignored and the rest of the buffer is interpreted as a
     * binary number.  Otherwise, the buffer is interpreted as an
     * octal number as per the parseOctal function above.
     *
     * @param buffer The buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The maximum number of bytes to parse.
     * @return The long value of the octal or binary string.
     * @throws IllegalArgumentException if the trailing space/NUL is
     * missing or an invalid byte is detected in an octal number, or
     * if a binary number would exceed the size of a signed long
     * 64-bit integer.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>long</name></type> <name>parseOctalOrBinary</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>,
                                          <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>)</parameter_list> <block>{

        <if>if <condition>(<expr>(<name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name> &amp; 0x80) == 0</expr>)</condition><then> <block>{
            <return>return <expr><call><name>parseOctal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>negative</name> =<init> <expr><name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name> == (<name>byte</name>) 0xff</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>length</name> &lt; 9</expr>)</condition><then> <block>{
            <return>return <expr><call><name>parseBinaryLong</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>negative</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>parseBinaryBigInteger</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>negative</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>long</name></type> <name>parseBinaryLong</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>,
                                        <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>,
                                        <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>negative</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>length</name> &gt;= 9</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"At offset " + <name>offset</name> + ", "
                                               + <name>length</name> + " byte binary number"
                                               + " exceeds maximum signed long"
                                               + " value"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>long</name></type> <name>val</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>val</name> = (<name>val</name> &lt;&lt; 8) + (<name><name>buffer</name><index>[<expr><name>offset</name> + <name>i</name></expr>]</index></name> &amp; 0xff)</expr>;</expr_stmt>
        }</block></for>
        <if>if <condition>(<expr><name>negative</name></expr>)</condition><then> <block>{
            <comment type="line">// 2's complement</comment>
            <expr_stmt><expr><name>val</name>--</expr>;</expr_stmt>
            <expr_stmt><expr><name>val</name> ^= ((<name>long</name>) <call><name><name>Math</name>.<name>pow</name></name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr>(<name>length</name> - 1) * 8</expr></argument>)</argument_list></call> - 1)</expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>negative</name> ? -<name>val</name> : <name>val</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>long</name></type> <name>parseBinaryBigInteger</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>,
                                              <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>,
                                              <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>,
                                              <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>negative</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>remainder</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>length</name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name> + 1</expr></argument>, <argument><expr><name>remainder</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>length</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>BigInteger</name></type> <name>val</name> =<init> <expr>new <call><name>BigInteger</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>negative</name></expr>)</condition><then> <block>{
            <comment type="line">// 2's complement</comment>
            <expr_stmt><expr><name>val</name> = <call><name><name>val</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>BigInteger</name>.<name>valueOf</name></name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>.<call><name>not</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>val</name>.<name>bitLength</name></name><argument_list>()</argument_list></call> &gt; 63</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"At offset " + <name>offset</name> + ", "
                                               + <name>length</name> + " byte binary number"
                                               + " exceeds maximum signed long"
                                               + " value"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><name>negative</name> ? -<call><name><name>val</name>.<name>longValue</name></name><argument_list>()</argument_list></call> : <call><name><name>val</name>.<name>longValue</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Parse a boolean byte from a buffer.
     * Leading spaces and NUL are ignored.
     * The buffer may contain trailing spaces or NULs.
     *
     * @param buffer The buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @return The boolean value of the bytes.
     * @throws IllegalArgumentException if an invalid byte is detected.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>parseBoolean</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name> == 1</expr>;</return>
    }</block></function>

    <comment type="line">// Helper method to generate the exception message</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>exceptionMessage</name><parameter_list>(<param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>,
            <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>, <param><decl><type><name>int</name></type> <name>current</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>byte</name></type> <name>currentByte</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>string</name> =<init> <expr>new <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// TODO default charset?</comment>
        <expr_stmt><expr><name>string</name>=<call><name><name>string</name>.<name>replaceAll</name></name><argument_list>(<argument><expr>"\0"</expr></argument>, <argument><expr>"{NUL}"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Replace NULs to allow string to be printed</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>s</name> =<init> <expr>"Invalid byte "+<name>currentByte</name>+" at offset "+(<name>current</name>-<name>offset</name>)+" in '"+<name>string</name>+"' len="+<name>length</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>s</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Parse an entry name from a buffer.
     * Parsing stops when a NUL is found
     * or the buffer length is reached.
     *
     * @param buffer The buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The maximum number of bytes to parse.
     * @return The entry name.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>parseName</name><parameter_list>(<param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
        <try>try <block>{
            <return>return <expr><call><name>parseName</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>DEFAULT_ENCODING</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ex</name></decl></param>) <block>{
            <try>try <block>{
                <return>return <expr><call><name>parseName</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>FALLBACK_ENCODING</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ex2</name></decl></param>) <block>{
                <comment type="line">// impossible</comment>
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>ex2</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></catch></try>
    }</block></function>

    <comment type="javadoc">/**
     * Parse an entry name from a buffer.
     * Parsing stops when a NUL is found
     * or the buffer length is reached.
     *
     * @param buffer The buffer from which to parse.
     * @param offset The offset into the buffer from which to parse.
     * @param length The maximum number of bytes to parse.
     * @param encoding name of the encoding to use for file names
     * @return The entry name.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>parseName</name><parameter_list>(<param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>,
                                   <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>,
                                   <param><decl><type><specifier>final</specifier> <name>ZipEncoding</name></type> <name>encoding</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{

        <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr><name>length</name></expr></init></decl>;</decl_stmt>
        <for>for (<init>;</init> <condition><expr><name>len</name> &gt; 0</expr>;</condition> <incr><expr><name>len</name>--</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>offset</name> + <name>len</name> - 1</expr>]</index></name> != 0</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>b</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>encoding</name>.<name>decode</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr>""</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Copy a name into a buffer.
     * Copies characters from the name into the buffer
     * starting at the specified offset. 
     * If the buffer is longer than the name, the buffer
     * is filled with trailing NULs.
     * If the name is longer than the buffer,
     * the output is truncated.
     *
     * @param name The header name from which to copy the characters.
     * @param buf The buffer where the name is to be stored.
     * @param offset The starting offset into the buffer
     * @param length The maximum number of header bytes to copy.
     * @return The updated offset, i.e. offset + length
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>formatNameBytes</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
        <try>try <block>{
            <return>return <expr><call><name>formatNameBytes</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>DEFAULT_ENCODING</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ex</name></decl></param>) <block>{
            <try>try <block>{
                <return>return <expr><call><name>formatNameBytes</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
                                       <argument><expr><name>FALLBACK_ENCODING</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block> <catch>catch (<param><decl><type><name>IOException</name></type> <name>ex2</name></decl></param>) <block>{
                <comment type="line">// impossible</comment>
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>ex2</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></catch></try>
    }</block></function>

    <comment type="javadoc">/**
     * Copy a name into a buffer.
     * Copies characters from the name into the buffer
     * starting at the specified offset. 
     * If the buffer is longer than the name, the buffer
     * is filled with trailing NULs.
     * If the name is longer than the buffer,
     * the output is truncated.
     *
     * @param name The header name from which to copy the characters.
     * @param buf The buffer where the name is to be stored.
     * @param offset The starting offset into the buffer
     * @param length The maximum number of header bytes to copy.
     * @param encoding name of the encoding to use for file names
     * @return The updated offset, i.e. offset + length
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>formatNameBytes</name><parameter_list>(<param><decl><type><name>String</name></type> <name>name</name></decl></param>, <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>,
                                      <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>,
                                      <param><decl><type><specifier>final</specifier> <name>ZipEncoding</name></type> <name>encoding</name></decl></param>)</parameter_list>
        <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr><call><name><name>name</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>b</name> =<init> <expr><call><name><name>encoding</name>.<name>encode</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>b</name>.<name>limit</name></name><argument_list>()</argument_list></call> &gt; <name>length</name> &amp;&amp; <name>len</name> &gt; 0</expr>)</condition> <block>{
            <expr_stmt><expr><name>b</name> = <call><name><name>encoding</name>.<name>encode</name></name><argument_list>(<argument><expr><call><name><name>name</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>--<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>limit</name> =<init> <expr><call><name><name>b</name>.<name>limit</name></name><argument_list>()</argument_list></call> - <call><name><name>b</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><call><name><name>b</name>.<name>array</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>b</name>.<name>arrayOffset</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Pad any remaining output bytes with NUL</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>limit</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>offset</name> + <name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        }</block></for>

        <return>return <expr><name>offset</name> + <name>length</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Fill buffer with unsigned octal number, padded with leading zeroes.
     * 
     * @param value number to convert to octal - treated as unsigned
     * @param buffer destination buffer
     * @param offset starting offset in buffer
     * @param length length of buffer to fill
     * @throws IllegalArgumentException if the value will not fit in the buffer
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>formatUnsignedOctalString</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buffer</name></decl></param>,
            <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>remaining</name> =<init> <expr><name>length</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>remaining</name>--</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>value</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name> + <name>remaining</name>--</expr>]</index></name> = (<name>byte</name>) '0'</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>long</name></type> <name>val</name> =<init> <expr><name>value</name></expr></init></decl>;</decl_stmt>
            <for>for (<init>;</init> <condition><expr><name>remaining</name> &gt;= 0 &amp;&amp; <name>val</name> != 0</expr>;</condition> <incr><expr>--<name>remaining</name></expr></incr>) <block>{
                <comment type="line">// CheckStyle:MagicNumber OFF</comment>
                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name> + <name>remaining</name></expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name>byte</name>) '0' + <call>(<name>byte</name>) <argument_list>(<argument><expr><name>val</name> &amp; 7</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>val</name> = <name>val</name> &gt;&gt;&gt; 3</expr>;</expr_stmt>
                <comment type="line">// CheckStyle:MagicNumber ON</comment>
            }</block></for>
            <if>if <condition>(<expr><name>val</name> != 0</expr>)</condition><then><block>{
                <throw>throw <expr>new <call><name>IllegalArgumentException</name>
                <argument_list>(<argument><expr><name>value</name>+"="+<call><name><name>Long</name>.<name>toOctalString</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>+ " will not fit in octal number buffer of length "+<name>length</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
        }</block></else></if>

        <for>for (<init>;</init> <condition><expr><name>remaining</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>remaining</name></expr></incr>) <block>{ <comment type="line">// leading zeros</comment>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name> + <name>remaining</name></expr>]</index></name> = (<name>byte</name>) '0'</expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Write an octal integer into a buffer.
     *
     * Uses {@link #formatUnsignedOctalString} to format
     * the value as an octal string with leading zeros.
     * The converted number is followed by space and NUL
     * 
     * @param value The value to write
     * @param buf The buffer to receive the output
     * @param offset The starting offset into the buffer
     * @param length The size of the output buffer
     * @return The updated offset, i.e offset+length
     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>formatOctalBytes</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>)</parameter_list> <block>{

        <decl_stmt><decl><type><name>int</name></type> <name>idx</name>=<init><expr><name>length</name>-2</expr></init></decl>;</decl_stmt> <comment type="line">// For space and trailing null</comment>
        <expr_stmt><expr><call><name>formatUnsignedOctalString</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>offset</name> + <name>idx</name>++</expr>]</index></name> = (<name>byte</name>) ' '</expr>;</expr_stmt> <comment type="line">// Trailing space</comment>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>offset</name> + <name>idx</name></expr>]</index></name>   = 0</expr>;</expr_stmt> <comment type="line">// Trailing null</comment>

        <return>return <expr><name>offset</name> + <name>length</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Write an octal long integer into a buffer.
     * 
     * Uses {@link #formatUnsignedOctalString} to format
     * the value as an octal string with leading zeros.
     * The converted number is followed by a space.
     * 
     * @param value The value to write as octal
     * @param buf The destinationbuffer.
     * @param offset The starting offset into the buffer.
     * @param length The length of the buffer
     * @return The updated offset
     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>formatLongOctalBytes</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>)</parameter_list> <block>{

        <decl_stmt><decl><type><name>int</name></type> <name>idx</name>=<init><expr><name>length</name>-1</expr></init></decl>;</decl_stmt> <comment type="line">// For space</comment>

        <expr_stmt><expr><call><name>formatUnsignedOctalString</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>offset</name> + <name>idx</name></expr>]</index></name> = (<name>byte</name>) ' '</expr>;</expr_stmt> <comment type="line">// Trailing space</comment>

        <return>return <expr><name>offset</name> + <name>length</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Write an long integer into a buffer as an octal string if this
     * will fit, or as a binary number otherwise.
     * 
     * Uses {@link #formatUnsignedOctalString} to format
     * the value as an octal string with leading zeros.
     * The converted number is followed by a space.
     * 
     * @param value The value to write into the buffer.
     * @param buf The destination buffer.
     * @param offset The starting offset into the buffer.
     * @param length The length of the buffer.
     * @return The updated offset.
     * @throws IllegalArgumentException if the value (and trailer)
     * will not fit in the buffer.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>formatLongOctalOrBinaryBytes</name><parameter_list>(
        <param><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>)</parameter_list> <block>{

        <comment type="line">// Check whether we are dealing with UID/GID or SIZE field</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>maxAsOctalChar</name> =<init> <expr><name>length</name> == <name><name>TarConstants</name>.<name>UIDLEN</name></name> ? <name><name>TarConstants</name>.<name>MAXID</name></name> : <name><name>TarConstants</name>.<name>MAXSIZE</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>negative</name> =<init> <expr><name>value</name> &lt; 0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>negative</name> &amp;&amp; <name>value</name> &lt;= <name>maxAsOctalChar</name></expr>)</condition><then> <block>{ <comment type="line">// OK to store as octal chars</comment>
            <return>return <expr><call><name>formatLongOctalBytes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>length</name> &lt; 9</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>formatLongBinary</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>negative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>formatBigIntegerBinary</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>negative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>offset</name></expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>negative</name> ? 0xff : 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>offset</name> + <name>length</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>formatLongBinary</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buf</name></decl></param>,
                                         <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>,
                                         <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>negative</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>bits</name> =<init> <expr>(<name>length</name> - 1) * 8</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>max</name> =<init> <expr>1l &lt;&lt; <name>bits</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>val</name> =<init> <expr><call><name><name>Math</name>.<name>abs</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>val</name> &gt;= <name>max</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Value " + <name>value</name> +
                " is too large for " + <name>length</name> + " byte field."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>negative</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>val</name> ^= <name>max</name> - 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>val</name> |= 0xff &lt;&lt; <name>bits</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>val</name>++</expr>;</expr_stmt>
        }</block></then></if>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>offset</name> + <name>length</name> - 1</expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= <name>offset</name></expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>byte</name>) <name>val</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>val</name> &gt;&gt;= 8</expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>formatBigIntegerBinary</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buf</name></decl></param>,
                                               <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>,
                                               <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>,
                                               <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>negative</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>BigInteger</name></type> <name>val</name> =<init> <expr><call><name><name>BigInteger</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>b</name> =<init> <expr><call><name><name>val</name>.<name>toByteArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> =<init> <expr><name><name>b</name>.<name>length</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>off</name> =<init> <expr><name>offset</name> + <name>length</name> - <name>len</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name></type> <name>fill</name> =<init> <expr><call>(<name>byte</name>) <argument_list>(<argument><expr><name>negative</name> ? 0xff : 0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>offset</name> + 1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>off</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name>fill</name></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Writes an octal value into a buffer.
     * 
     * Uses {@link #formatUnsignedOctalString} to format
     * the value as an octal string with leading zeros.
     * The converted number is followed by NUL and then space.
     *
     * @param value The value to convert
     * @param buf The destination buffer
     * @param offset The starting offset into the buffer.
     * @param length The size of the buffer.
     * @return The updated value of offset, i.e. offset+length
     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>formatCheckSumOctalBytes</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>buf</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name></decl></param>)</parameter_list> <block>{

        <decl_stmt><decl><type><name>int</name></type> <name>idx</name>=<init><expr><name>length</name>-2</expr></init></decl>;</decl_stmt> <comment type="line">// for NUL and space</comment>
        <expr_stmt><expr><call><name>formatUnsignedOctalString</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>offset</name> + <name>idx</name>++</expr>]</index></name>   = 0</expr>;</expr_stmt> <comment type="line">// Trailing null</comment>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>offset</name> + <name>idx</name></expr>]</index></name>     = (<name>byte</name>) ' '</expr>;</expr_stmt> <comment type="line">// Trailing space</comment>

        <return>return <expr><name>offset</name> + <name>length</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Compute the checksum of a tar entry header.
     *
     * @param buf The tar entry's header buffer.
     * @return The computed checksum.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>long</name></type> <name>computeCheckSum</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>buf</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>sum</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>buf</name>.<name>length</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <expr_stmt><expr><name>sum</name> += <name>BYTE_MASK</name> &amp; <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>

        <return>return <expr><name>sum</name></expr>;</return>
    }</block></function>

}</block></class>
</unit>
